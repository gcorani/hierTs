#if h=1, the possible preds are the whole test size lenght;
#if h=2, the possible preds are the (test size lenght -1); etc.
possiblePreds <- testSize - h + 1
totTs <- nrow(smatrix(hierTs))
maeBu <- matrix(nrow = possiblePreds, ncol = totTs)
maeComb <- matrix(nrow = possiblePreds, ncol = totTs)
maeCombWls <- matrix(nrow = possiblePreds, ncol = totTs)
maeCombMint <- matrix(nrow = possiblePreds, ncol = totTs)
maeBayes <- matrix(nrow = possiblePreds, ncol = totTs)
iTest <- 1
timeIdx <- time(hierTs$bts[,1])
endTrain <- length(timeIdx) - h - (iTest - 1)
train <- window(hierTs, start = timeIdx[1], end = timeIdx[endTrain] )
test <- window(hierTs, start =timeIdx[endTrain +1], end=timeIdx[endTrain + h])
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
fcastBu <- forecast(train, h = h, method = "bu", fmethod = fmethod)
fcastComb <- forecast(train, h = h, method = "comb", weights="ols", fmethod=fmethod)
fcastCombWls <- forecast(train, h = h, method = "comb", weights="wls", fmethod=fmethod)
fcastCombMint <- forecast(train, h = h, method = "comb", weights="mint", fmethod=fmethod)
fcastBu
fcastBu$method
fcastBu$fmethod
fcastBu$bts
hierTs$bts
ts(allTsTrain[,i])
i<-1
ts(allTsTrain[,i])
#recompute predictions to be easily accessed by the Bayesian method
allTsTrain <- allts(train)
numTs <- ncol(allTsTrain)
alpha <- 0.2
sigma <- vector(length = numTs)
preds <- vector(length = numTs)
ts(allTsTrain[,i])
?rw
?rwf
rwf(ts(allTsTrain[,i]),h=h)
a<-rwf(ts(allTsTrain[,i]),h=h)
class(a)
b<-auto.arima(ts(allTsTrain[,i]))
class(b)
model <- ets(ts(allTsTrain[,i]))
tmp <- forecast(model, h=h, level=1-alpha)
tmp
rwf(ts(allTsTrain[,i]))
rwf(ts(allTsTrain[,i]), h=1)
tmp <- forecast(model, h=h, level=1-alpha)
tmp
alpha
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
tmp <- rwf(ts(allTsTrain[,i]),h=h, level=1-alpha)
preds[i] <- tmp$mean[h]
sigma[i] <- abs ( (tmp$mean[h] - tmp$upper[h])  / (qnorm(alpha / 2)) )
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
load("~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/results.Rdata")
a <- hier(htseg1)
a
view(a)
iew(a)
View(a)
a
resultsHtseg1[[1]]
a[[1]]
a[[4]]
resultsHtseg1[[4]]
resultsHtseg1[[5]]
resultsHtseg1[[5]]==a[[5]]
resultsHtseg1[[4]]==a[[4]]
resultsHtseg1[[3]]==a[[3]]
resultsHtseg1[[5]]==a[[5]]
resultsHtseg1[[6]]==a[[6]]
resultsHtseg1[[6]]
a[[6]]
a
a[[6]]
resultsHtseg1[[6]]
a
a$maeBayes==resultsHtseg1$maeBayes
a$maeBu==resultsHtseg1$maeBu
a$maeComb==resultsHtseg1$maeComb
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
a <- hier(htseg2)
b <- hier(htseg2, fmethod = "arima")
c <- hier(htseg2, fmethod = "rw")
View(a)
View(b)
View(c)
a <- hier(infantgts, fmethod = "rw")
b <- hier(infantgts, fmethod = "rw", h=4)
View(a)
View(b)
a <- hier(infantgts, fmethod = "arima", h=1)
View(a)
a <- hier(infantgts, fmethod = "arima", h=4)
View(a)
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
a <- hier(htseg1, fmethod = "ets", h=4)
library(thief)
??thief
z <- thief(AEdemand[,12], usemodel='arima')
z
class(z)
z
?hts
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier(htseg1)
fcastComb
class(fcastComb)
fcastComb
fcastComb$bts
fcastComb$histy
fcastComb$labels
fcastComb$method
fcastComb$fmethod
fcastComb$nodes
install.packages(tsfeatures)
install.packages("tsfeatures")
library(tsfeatures)
devtools::install_github("robjhyndman/tsfeatures")
?hts
?forecast.gts
ally <- aggts(htseg1)
n <- nrow(ally)
p <- ncol(ally)
allf <- matrix(NA, nrow = h, ncol = p)
res <- matrix(NA, nrow = n, ncol = p)
h <- 1
ally <- aggts(htseg1)
n <- nrow(ally)
p <- ncol(ally)
allf <- matrix(NA, nrow = h, ncol = p)
res <- matrix(NA, nrow = n, ncol = p)
for(i in 1:p)
{
fit <- auto.arima(ally[, i])
allf[, i] <- forecast(fit, h = h)$mean
res[, i] <- na.omit(ally[, i] - fitted(fit))
}
allf <- ts(allf, start = 51)
y.f <- MinT(allf, get_nodes(htseg1), residual = res, covariance = "shr",
keep = "gts", algorithms = "lu")
y.f
y.f$bts
y.f$nodes
y.f$labels
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
y.f$labels
hier(0)
hier()
hier(htseg1)
y.f <- MinT(train, get_nodes(htseg1), residual = res, covariance = "shr",
keep = "gts", algorithms = "lu")
?gamma
?rgamma
hist(rgamma(10000,1,1))
?rgamma
hist(rgamma(10000,0.1,1))
hist(rgamma(100000,0.1,1))
hist(rgamma(100000,0.01,1))
?rgamma
hist(rgamma(100000,0.01,100))
libvrary(hts)
library(hts)
?hts
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier(htseg1)
allts(htseg1)
a<-allts(htseg1)
a
class(a)
class(htseg1)
htseg1$bts
htseg1$nodes
htseg1$labels
S
smatrix(htseg1)
maeBayes
htseg1$labels
htseg1$nodes
summary(htseg1)
htseg1$nodes
htseg1
htseg1$nodes
htseg1$labels
class(htseg1$labels)
length(htseg1$labels)
htseg1$labels[[1]]
htseg1$labels[[2]]
htseg1$labels[[3]]
htse1[[3]]
htseg1[[3]]
install.packages("MASS")
?MASS
library("MASS", lib.loc="/Library/Frameworks/R.framework/Versions/3.5/Resources/library")
install.packages("mvtnorm")
library(mtvnorm)
library("mvtnorm")
?mvtno
?mvtno rm
?mvtnorm
?v
?mvtnorm
?qmvnorm
qmvnorm(p, interval = NULL, tail = c("lower.tail",
"upper.tail", "both.tails"), mean = 0, corr = NULL,
sigma = NULL, algorithm = GenzBretz(),
ptol = 0.001, maxiter = 500, trace = FALSE, ...)
qmvnorm(.95, tail=("both.tails"), mean=c(0,0), sigma=matrix(data = c(1,0,0,1), nrow = 2))
qmvnorm(0.95, sigma = diag(2), tail = "both")
qmvnorm(0.95, sigma = diag(1), tail = "both")
diag(3)
a <- c(1,2,3)
diag(a)
diag(a^2)
?daig
?diaf
?diag
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier(htseg1)
m <- priorCov
priorCov <- matrix (nrow = p, ncol = p)
for (i in 1:p) {
priorCov[i,i] <- sigma[i]^2
}
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier(htseg1)
m <- priorCov
hier(htseg1)
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier(htseg1,1)
hier(htseg1)
p
priorCov
diag(sigma[i]^2)
sigma[i]^2
hier(htseg1)
sigma
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier(htseg1)
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier(htseg1)
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier(htseg1)
priorCov
a<-diag(sigma^3)
a<-diag(sigma^2)
a
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier(htseg1)
hier(htseg1,h=2)
a<-hier(htseg1,h=2)
a
a<-hier(htseg1,h=2)
a <- priorCov
a == priorCov
a
priorCov
sigma[1]
sigma[1]^2
priorCov[1,1]
a[1,1]
sigma[bottomIdx]^2
sigma[bottomIdx]
bottomIdx
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier(htseg1)
priorCov
Sigma_y
bottomIdx
hierTs$bts
hierTs
hierTs$nodes
hierTs$labels
allTsTrain[,1]
allTsTrain[,2]
allTsTrain[,3]
allTsTrain[,bottomIdx]
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier(htseg1)
sigma
sigma^2
19^2
Sigma_y
priorCov
A
hier(htseg1)
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier(htseg1)
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/batchHier.R')
batchHier()
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
(85-100)/100
(85-100)/((100+85)/2)
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
?hts
library(readr)
tourism <- read_csv("tourism.R")
View(tourism)
tourism
library(readr)
TourismData_v3 <- read_csv("TourismData_v3.csv",
na = "empty")
View(TourismData_v3)
tourism <- read_csv("TourismData_v3.csv",
na = "empty")
class(tourism)
colnames(tourims)
colnames(tourism)
?ts
#the first two columns contain the time
tourism <- tourism[-1:2,]
#the first two columns contain the time
tourism <- tourism[-1:-2,]
tourims
tourism
colnames(tourism)
#the first two columns contain the time
tourism <- tourism[-1:-2,]
dim(tourism)
#the first two columns contain the time
tourism <- tourism[,-1:-2]
dim(tourism)
colnames(tourims)
colnames(tourism)
tourism <- read_csv("TourismData_v3.csv",
na = "empty")
#the first two columns contain the time
tourism <- tourism[,-1:-2]
dim(tourism)
hierTourism <- hts(y=tourism, bnames = colnames(tourism))
hierTourism <- hts(y=tourism, bnames = colnames(tourism),
characters = c(3,3))
hierTourism
?ts
hierTourism <- hts(y=tourism, bnames = colnames(tourism),
characters = c(3,3), start=c(1998, 1))
hierTourism <- hts(y=tourism, bnames = colnames(tourism),
characters = c(3,3))
hts
hierTourism
time(hierTourism)
summary(hierTourism)
source("loadTourism.R")
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
source("loadTourism.R")
if (hierTs=="tourism"){
hierTs <- loadTourism()
}
hierTs<-"tourism"
hierTs <- loadTourism()
hierTs
summary(hierTs)
hier("tourism")
possiblePreds
totTs
hier("tourism")
DataFrameCallback
hier("tourism")
hierTs
hier("tourism")
hierTs
hier("tourism")
testSize <- 2
myList
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier(htseg1)
dset
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier(htseg1)
dset
hier(htseg1)
dset
#TODO: check how to compute percentages
library(hts)
dset="htseg1"
h=1
#TODO: check how to compute percentages
library(hts)
source("loadTourism.R")
dset
source("loadTourism.R")
#The buReconcile function computes the bu prediction given the predictions (1 x tot time series) and the S matrix
#(tot time series X bottom time series)
#predsAllTs is a flag: is set to true, the input preds contains predictions for all the hierarchy
#and the function retrieves the bottom series; if set to false, this is not needed
#as preds only contains only bottom time series
buReconcile <- function (preds,S, predsAllTs = FALSE) {
bottomPreds <- preds
if (predsAllTs) {
#retrieves the bottom prediction from all predictions
upperIdx <- 1 : (nrow(S) - ncol(S))
bottomIdx <- setdiff (1:nrow(S), upperIdx)
bottomPreds <- preds [,bottomIdx]
}
buPreds <- preds
#nrow(S) is the total number of time series
for (i in 1:nrow(S)){
buPreds[i] <- S[i,] %*% bottomPreds
}
return (buPreds)
}
hierMae <- function (htsPred, htsActual) {
#receives two hts objects, containing  forecast and actual value.
#computes the mae for the relevant forecast horizon only
#Sets correctly the columns names currently not possible
maeHts <- abs (allts(htsPred) - allts(htsActual))[h,]
# colnames(maeHts) <- colnames(allts(htsPred))
return (maeHts)
}
#extract the time from the data set to then split into train / test (test set contains 25 or 5 time points)
set.seed(seed = 0)
dset
if (dset=="tourism"){
hierTs <- loadTourism()
}
else if (dset=="htseg1"){
hierTs <- htseg1
}
else if (dset=="htseg2"){
hierTs <- htseg2
}
else if (dset=="infantgts"){
hierTs <- infantgts
}
dset
hierTourism
hierTs
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier(htseg1)
#TODO: check how to compute percentages
library(hts)
source("loadTourism.R")
#The buReconcile function computes the bu prediction given the predictions (1 x tot time series) and the S matrix
#(tot time series X bottom time series)
#predsAllTs is a flag: is set to true, the input preds contains predictions for all the hierarchy
#and the function retrieves the bottom series; if set to false, this is not needed
#as preds only contains only bottom time series
buReconcile <- function (preds,S, predsAllTs = FALSE) {
bottomPreds <- preds
if (predsAllTs) {
#retrieves the bottom prediction from all predictions
upperIdx <- 1 : (nrow(S) - ncol(S))
bottomIdx <- setdiff (1:nrow(S), upperIdx)
bottomPreds <- preds [,bottomIdx]
}
buPreds <- preds
#nrow(S) is the total number of time series
for (i in 1:nrow(S)){
buPreds[i] <- S[i,] %*% bottomPreds
}
return (buPreds)
}
hierMae <- function (htsPred, htsActual) {
#receives two hts objects, containing  forecast and actual value.
#computes the mae for the relevant forecast horizon only
#Sets correctly the columns names currently not possible
maeHts <- abs (allts(htsPred) - allts(htsActual))[h,]
# colnames(maeHts) <- colnames(allts(htsPred))
return (maeHts)
}
a <- htseg1
htseg1
class(htseg1)
#The buReconcile function computes the bu prediction given the predictions (1 x tot time series) and the S matrix
#(tot time series X bottom time series)
#predsAllTs is a flag: is set to true, the input preds contains predictions for all the hierarchy
#and the function retrieves the bottom series; if set to false, this is not needed
#as preds only contains only bottom time series
buReconcile <- function (preds,S, predsAllTs = FALSE) {
bottomPreds <- preds
if (predsAllTs) {
#retrieves the bottom prediction from all predictions
upperIdx <- 1 : (nrow(S) - ncol(S))
bottomIdx <- setdiff (1:nrow(S), upperIdx)
bottomPreds <- preds [,bottomIdx]
}
buPreds <- preds
#nrow(S) is the total number of time series
for (i in 1:nrow(S)){
buPreds[i] <- S[i,] %*% bottomPreds
}
return (buPreds)
c
hier(htseg1)
dswe
dset
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier(htseg1)
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier(htseg1)
dset
hier("htseg1")
class("pippo")
is.character(dset)
dset <- "a"
is.character(dset)
!is.character(dset)
is.character(dset) == FALSE
is.character(dset) == TRUE
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier(htseg1)
?error
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier(htseg1)
hier("htseg1")
hier("tourism")
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/loadTourism.R')
hier("tourism")
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/batchHier.R')
batchHier()
