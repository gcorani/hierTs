check <- abs(roots)>1
if mean(check)==1 {
unstable <- FALSE
}
alpha
ts <- vector(length = n + order)
ts[1:order] <- runif(order)
for (i in (order+1):(order+n)){
ts[i] <- crossprod(ts[(i-order):(i-1)], alpha )
}
plot(ts)
unstable <- TRUE
while (unstable){
alpha <- runif(order)
#check that alpha is stable
#get the implied roots
roots <- polyroot(rbind(-1,-alpha))
check <- abs(roots)>1
if mean(check)==1 {
unstable <- FALSE
}
roots
abs(roots)
check
unstable <- TRUE
while (unstable){
alpha <- runif(order)
#check that alpha is stable
#get the implied roots
roots <- polyroot(rbind(-1,-alpha))
check <- abs(roots)>1
if (mean(check)==1) {
unstable <- FALSE
}
alpha
ts <- vector(length = n + order)
ts[1:order] <- runif(order)
for (i in (order+1):(order+n)){
ts[i] <- crossprod(ts[(i-order):(i-1)], alpha )
}
plot(ts)
roots
check
abs(roots)
?tsCV
library(fpp2)
?tsCV
far2 <- function(x, h)
{forecast(auto.arima, h=h)}
e <- tsCV(lynx, far2, h=1)
e
far2 <- function(x, h){forecast(Arima(x, order=c(2,0,0)), h=h)}
e <- tsCV(lynx, far2, h=1)
e
farima <- function(x, h) {
forecast(auto.arima(x),h=h)
}
e <- tsCV(lynx, farima, h=1)
htseg1
library(hts)
htseg2[[1]]
htseg2[[1]][,1]
library(fpp2)
library(hts)
farima <- function(x, h) {
forecast(auto.arima(x),h=h)
}
1:dim(htseg2[[1]][2])
dim(htseg2[[1]][2])
dim(htseg2[[1]])
dim(htseg2[[1]])1:dim(htseg2[[1]])[2]
1:dim(htseg2[[1]])[2]
i <- 1
e <- tsCV(ts, farima, h=1)
fets <- function(x, h) {
forecast(ets(x), h = h)
}
i
ts <- htseg2[[1]][,i]
ts
e <- tsCV(ts, fets, h=1)
model <- ets(ts)
sd(e)
sd(e, na.rm = TRUE)
forecast(model,h=1)
-1.21321 - -1.356712
-1.21321  -1.356712
-2.569922 / 1.96
e
model$residuals
sd(model$residuals)
sd(e, na.rm = TRUE)
forecast(model,h=1, level = 95)
-1.21321 + -1.356712
(-1.21321  -1.356712)
(-1.21321  1.356712)
(-1.21321 +  1.356712)
(-1.21321  1.356712) / 1.96
(-1.21321  +  1.356712) / 1.96
a<-1
a==1
a!=1
hier(htseg1)
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier(htseg1)
hier("htseg1")
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier("htseg1")
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier("htseg1")
hier("htseg1", cv = TRUE)
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier("htseg1", cv = TRUE)
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier("htseg1", cv = TRUE)
sigma[i]
abs ( (tmp$mean[h] - tmp$upper[h])  / (qnorm(alpha / 2)) )
sigma[i]
i
sigma[1]
hier("htseg1", cv = TRUE)
hier("htseg1", h=2)
hier("htseg1", h=2, cv = TRUE)
hier("htseg2", h=1)
hier("htseg2", h=1, cv = TRUE)
hier("htseg2", h=2, cv = TRUE)
hier("htseg2", h=2)
?tsCV
i <- 1
a <- tsCV(ts(allTsTrain[,i]), fets, h=1)
a <- tsCV(eggs, fets, h=1)
length(eggs)
length(a)
a <- tsCV(eggs, fets, h=1, window = 30)
length(a)
b <- tsCV(eggs, fets, h=1)
length(b)
length(a)
b
a
htseg2
length(htseg2)
length(htseg2[[1]])
length(htseg2[[1]][,1])
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier("htseg2", h=2, cv = TRUE)
errs
sigma[i]
abs ( (tmp$mean[h] - tmp$upper[h])  / (qnorm(alpha / 2)) )
h
sigma[i]
sigma[1]
hier("htseg2", h=2)
hier("htseg2", h=1)
hier("htseg2", h=2)
hier("htseg2", h=3)
hier("htseg2", h=1, cv = TRUE)
hier("htseg2", h=2, cv = TRUE)
library(readr)
dataset <- read_csv(NULL)
View(dataset)
?gts
library(gts)
library(hts)
infantgts
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier("infantgts",h=1)
hier("infantgts",h=1, cv = TRUE)
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier (infantgts, h=1, fmethod="arima", cv=FALSE)
hier ("infantgts", h=1, fmethod="arima", cv=FALSE)
hier ("infantgts", h=1, fmethod="arima", cv=TRUE)
library(readr)
Sheet_2_Table_1 <- read_csv("tmp.csv/Sheet 2-Table 1.csv",
locale = locale(grouping_mark = "'"))
View(Sheet_2_Table_1)
tmp
tmp <- Sheet_2_Table_1
rank(tmp)
?friedman.test
a <- friedman.test(tmp)
rank(tmp[1,])
tmp[1,]
rank(tmp[1,])
rank(as.numeric(tmp[1,]))
rank(as.numeric(tmp[2,]))
sampleRank <- matrix(ncol=ncol(tmp),nrow=nrow(tmp))
for (i in 1:nrow(tmp)) sampleRank[i,]<-rank(tmp[i,])
for (i in 1:nrow(tmp)) sampleRank[i,]<-rank(as.numeric(tmp[i,]))
tmp
sampleRank
rowMeans(sampleRank)
colMeans(sampleRank)
tmp <- tmp[-1,]
for (i in 1:nrow(tmp)) sampleRank[i,]<-rank(as.numeric(tmp[i,]))
sampleRank
sampleRank <- matrix(ncol=ncol(tmp),nrow=nrow(tmp))
for (i in 1:nrow(tmp)) sampleRank[i,]<-rank(as.numeric(tmp[i,]))
sampleRank
tmp
tmp <- tmp[,-1]
tmp
for (i in 1:nrow(tmp)) sampleRank[i,]<-rank(as.numeric(tmp[i,]))
sampleRank <- matrix(ncol=ncol(tmp),nrow=nrow(tmp))
for (i in 1:nrow(tmp)) sampleRank[i,]<-rank(as.numeric(tmp[i,]))
sampleRank
rowMeans(sampleRank)
colMeans(sampleRank)
library(hts)
source("loadTourism.R")
# library(tidyverse)
tourism <- read.csv("TourismData_v3.csv",
na = "empty")
tourism
View(tourism)
#the first two columns contain the time
tourism <- tourism[,-1:-2]
class(toursim)
class(tourism)
#we known that it start in Jan 1998
y=ts(tourism, frequency = 12, start = c(1998,1))
class(tourism)
class(y)
y
View(y)
time(y)
hierTourism <- hts(y=y, bnames = colnames(tourism),
characters = c(3,3))
summary(hierTourism)
library(hts)
source("loadTourism.R")
dset="htseg1"
h=1
fmethod="ets"
library(hts)
source("loadTourism.R")
if (is.character(dset) == FALSE) {
stop ("dset should be a string")
}
#for tsCV
fets <- function(x, h) {
forecast(ets(x), h = h)
}
farima <- function(x, h) {
forecast(auto.arima(x), h=h)
}
bottomPreds <- preds
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
?forecast
?hts::forecast.gts
iTest <- 1
timeIdx             <- time(hierTs$bts[,1])
hierTs <- htseg1
testSize <- 25
if (length(hierTs$bts[,1]) < 25){
testSize <- 5
}
#if h=1, the possible preds are the whole test size lenght;
#if h=2, the possible preds are the (test size lenght -1); etc.
possiblePreds <- testSize - h + 1
totTs       <- nrow(smatrix(hierTs))
maeBase     <- matrix(nrow = possiblePreds, ncol = totTs)
maeBu       <- matrix(nrow = possiblePreds, ncol = totTs)
maeComb     <- matrix(nrow = possiblePreds, ncol = totTs)
maeCombWls  <- matrix(nrow = possiblePreds, ncol = totTs)
maeCombMint <- matrix(nrow = possiblePreds, ncol = totTs)
maeBayes    <- matrix(nrow = possiblePreds, ncol = totTs)
#These vectors will contain the global mse, summed over all the time series of the hierarchy
mseBase     <- vector(length   = possiblePreds)
mseBu       <- vector(length   = possiblePreds)
mseComb     <- vector(length   = possiblePreds)
mseCombWls  <- vector(length   = possiblePreds)
mseCombMint <- vector(length   = possiblePreds)
mseBayes    <- vector(length   = possiblePreds)
elapsedBase     <- vector(length   = possiblePreds)
elapsedBu     <- vector(length   = possiblePreds)
elapsedComb     <- vector(length   = possiblePreds)
elapsedCombMint  <- vector(length   = possiblePreds)
elapsedBayes    <- vector(length   = possiblePreds)
iTest <-1
timeIdx             <- time(hierTs$bts[,1])
endTrain            <- length(timeIdx) - h - (iTest - 1)
train               <- window(hierTs, start = timeIdx[1], end = timeIdx[endTrain] )
test                <- window(hierTs, start =timeIdx[endTrain +1], end=timeIdx[endTrain + h])
endTrain
ptm <- proc.time()
fcastBu             <- forecast(train, h = h, method = "bu", fmethod = fmethod)
View(fcastBu)
h
summary(htseg1)
elapsedComb[iTest] <- (proc.time() - ptm)["elapsed"]
fcastComb           <- forecast(train, h = h, method = "comb", weights="ols", fmethod=fmethod)
fcastComb
fcastComb[[1]]
fcastComb[[2]]
fcastComb[[3]]
fcastComb[[4]]
fcastComb[[5]]
fcastBu
test
?allts
fcastBu[[1]]
fcastBu[[2]]
#recompute predictions to be easily accessed by the Bayesian method
allTsTrain <- allts(train)
numTs <- ncol(allTsTrain)
alpha <- 0.2
sigma <- vector(length = numTs)
preds <- vector(length = numTs)
i <- 1
#recompute predictions to be easily accessed by the Bayesian method
allTsTrain <- allts(train)
numTs <- ncol(allTsTrain)
alpha <- 0.2
sigma <- vector(length = numTs)
preds <- vector(length = numTs)
print(paste(as.character(i),"/",as.character(numTs)))
model <- ets(ts(allTsTrain[,i]))
View(model)
tmp <- forecast(model, h=h, level=1-alpha)
tmp
tmp$mean
tmp$upper
sigma[i] <- abs ( (tmp$mean[h] - tmp$upper[h])  / (qnorm(alpha / 2)) )
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
source("hier.R")
for (h in c(1,2,3,4)) {
for (method in c("ets","arima")){
print(paste("infantgts ", as.character(method), "h=", as.character(h)))
a <- hier("infantgts", h=h, fmethod = method)
}
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
source("hier.R")
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
for (h in c(1,2,3,4)) {
for (method in c("ets","arima")){
print(paste("infantgts ", as.character(method), "h=", as.character(h)))
a <- hier("infantgts", h=h, fmethod = method)
}
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/parseM3results.R')
parseM3Results()
favorableSign
View(results)
friedman.test
#prepares the AEdemand dataset and launches the temporal reconciliation experiment
#the fmethod is forced to be arima as the expsmoothing does not support such long seasonality
library(thief)
library(fpp2)
source("thier.R")
#prepares the AEdemand dataset and launches the temporal reconciliation experiment
#the fmethod is forced to be arima as the expsmoothing does not support such long seasonality
library(thief)
library(fpp2)
source("thier.R")
fmethod="arima"
i <- 1
i <- 3
freq <- frequency(AEdemand[,i])
n <- length(AEdemand[,i])
endTrain <- time(AEdemand[,i])[n - freq]
print(paste("AEdemand: ",colnames(AEdemand)[i]))
freq <- frequency(AEdemand[,i])
n <- length(AEdemand[,i])
endTrain <- time(AEdemand[,i])[n - freq]
startTest <- time(AEdemand[,i])[n - freq +1]
train <- window(AEdemand[,i], end=endTrain)
test <- window(AEdemand[,i], start=startTest)
tsObj<- list()
tsObj$x <- train
tsObj$xx <- test
tsObj$sn <- colnames(AEdemand)[i]
thier (tsObj, fmethod=fmethod, periodType="weekly")
auto.arima(trainHier[[i]])
a <- auto.arima(trainHier[[i]])
a
trainHier[[1]]
class(trainHier[[1]])
frequency(trainHier[[1]])
frequency(trainHier[[2]])
b <- auto.arima(trainHier[[i]])
b
36*6
fc[[1]]
autoplot(fc[[1]])
autoplot(fc[[2]])
frequency(trainHier[[2]])
i
autoplot(fc[[i]])
autoplot(fc[[3]])
auto.arima(trainHier[[i]]), h=h, , level = (1-alpha))
auto.arima(trainHier[[3]])
frequency(trainHier[[3]])
fc[[2]]
a <- auto.arima(trainHier[[2]])
a
autoplot(forecast(auto.arima(trainHier[[i]]), h=104, , level = (1-alpha)))
autoplot(forecast(auto.arima(trainHier[[1]]), h=104, , level = (1-alpha)))
tmp <- (forecast(auto.arima(trainHier[[1]]), h=104, , level = (1-alpha)))
tmp
checkresiduals(auto.arima(trainHier[[i]]))
auto.arima(trainHier[[1]]))
auto.arima(trainHier[[1]])
b <- auto.arima(trainHier[[2]])
b
auto.arima(trainHier[[3]])
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/parseM3results.R')
parseM3Results()
View(results)
a <- cbind(results$mseBu/results$mseBase,results$mseThief/results$mseBase, results$mseBayes/results$mseBase)
boxplot(a)
boxplot(a, outline= FALSE)
boxplot(log(a), outline= FALSE)
boxplot(a, outline= FALSE)
boxplot(log(a), outline= FALSE)
boxplot(a, outline= FALSE)
boxplot(log(a))
boxplot(log10(a))
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/parseM3results.R')
parseM3Results()
parseM3Results(type="monthly", fmethod="arima")
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/parseM3results.R')
parseM3Results(type="monthly", fmethod="arima")
parseM3Results(type="monthly", fmethod="ets")
parseM3Results(type="quarterly", fmethod="ets")
parseM3Results(type="quarterly", fmethod="arima")
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/parseM3results.R')
type="weekly"
fmethod="arima"
library(readr)
filename <- paste("results/temporalHier","_",type,"_",fmethod,".csv",sep = "")
results <- read_csv(filename)
if (type=="weekly"){
warning("the AE experiment is only over 13 time series")
freqs <- c("_Weekly","_2-Weekly","_4-Weekly","_Quarterly","_Biannual","_Annual")
}
names <- colnames(results)
baseMethods <- c("Bu","Thief")
myMethod <-"Bayes"
comparisons <- length(freqs) * length (baseMethods)
improvIndicator <- matrix(0, ncol = comparisons, nrow = nrow(results))
improvNames <- vector(length = comparisons)
favorableSign <- vector(length = comparisons)
pValueSign <- vector(length = comparisons)
meanImprovement <- vector(length = comparisons)
isMseImproved  <- vector(length = comparisons)
mseImprovement  <- vector(length = comparisons)
counter <- 1
for (method in baseMethods) {
for (freq in freqs){
improvNames[counter] <- paste(method,freq)
colBase <- intersect(grep(method,names) , grep(freq,names))
colMy <- intersect(grep(myMethod,names) , grep(freq,names))
favorableSign[counter] <- mean (results[,colBase] > results[,colMy] )
#computing the improvIndicator
#unfortunaltely, this yields a single-columns *data frame* which we then have to cast as a vector
currentImprovement <- ( results[,colBase] - results[,colMy] ) / ((results[,colBase]  + results[,colMy]) /2 )
#casting as vector
currentImprovement <- currentImprovement[,1]
improvIndicator[,counter] <- currentImprovement
meanImprovement[counter] <- mean (currentImprovement)
counter <- counter + 1
}
improvIndicator <- as.data.frame(improvIndicator)
colnames(improvIndicator) <- improvNames
meanImprovement <-  as.data.frame(t(meanImprovement))
colnames(meanImprovement) <- improvNames
favorableSign <- as.data.frame(t(favorableSign))
colnames(favorableSign) <- improvNames
#generate the bplot
pdfname <- paste("results/temporalHier","_",type,"_",fmethod,".pdf",sep = "")
pdf(pdfname)
denom <- results$mseBase
a <-  cbind(results$mseBu/denom,
results$mseThief/denom, results$mseBayes/denom)
boxplot(log10(a),names=c("bu","thief","bayes"), outline=TRUE, ylab="Relative MSE (log10)")
dev.off()
#      ylab="mse(Bayes)", xlim = c(0,1e+9), ylim= c(0,1e+9))
# }
# else if (type=="quarterly"){
#   plot(results$mseThief,results$mseBayes, xlab = "mse (thief)",
#        ylab="mse(Bayes)", xlim = c(0,1e+8), ylim= c(0,1e+8))
# }
# abline(0,1)
# dev.off()
#
#test comparing thief and bayes
wilcoxPval <- wilcox.test(a[,2],a[,3],paired = TRUE, alternative = "greater")
ttestPval <-  t.test(a[,2],a[,3],paired = TRUE, alternative = "greater")
return (list("favorableSign" = favorableSign, "meanImprovement" = meanImprovement,
"wilcoxPval" = wilcoxPval, "ttestPval"=ttestPval, "improvIndicator"=improvIndicator ) )
a <- parseM3Results ()
favorableSign
mean(results$mseBase<results$mseBayes)
mean(results$mseBase>results$mseBayes)
mean(results$mseBu>results$mseBayes)
mean(results$mseThief>results$mseBayes)
parseM3Results(fmethod = "arima")
mean(results$mseThief>results$mseBayes)
mean(results$mseBu>results$mseBayes)
mean(results$mseBase>results$mseBayes)
parseM3Results(type="quarterly",fmethod = "arima")
mean(results$mseBase>results$mseBayes)
mean(results$mseBu>results$mseBayes)
mean(results$mseThief>results$mseBayes)
parseM3Results(type="quarterly",fmethod = "ets")
mean(results$mseBu>results$mseBayes)
mean(results$mseThief>results$mseBayes)
mean(results$mseBase>results$mseBayes)
parseM3Results(type="weekly",fmethod = "arima")
mean(results$mseBase>results$mseBayes)
mean(results$mseBu>results$mseBayes)
mean(results$mseThief>results$mseBayes)
