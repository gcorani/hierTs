scale_y_continuous(name = "Log10 (MSE / MSE base) ")
ylim1 = boxplot.stats(log(dataPlot$V1))$stats[c(1, 5)]
currentPlot = currentPlot + coord_cartesian(ylim = ylim1*1.1)  + geom_hline(yintercept = 0)
print(currentPlot)
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/parseHierResults_aggregatedH.R')
ylim1 = boxplot.stats(log(dataPlot$V1))$stats[c(1, 5)]
currentPlot = currentPlot + coord_cartesian(ylim = ylim1*1.1)  + geom_hline(yintercept = 0, color='darkblue')
print(currentPlot)
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/parseHierResults_aggregatedH.R')
currentPlot <- ggplot(dataPlot, aes(x = label, y = log10(relMse))) + geom_boxplot()  +
stat_boxplot(geom = "errorbar", width = 0.5) +  #draw the whiskers
scale_x_discrete(name = "") +
scale_y_continuous(name = "Log10 (MSE / MSE base) ")
currentPlot <- ggplot(dataPlot, aes(x = label, y = log10(relMse))) + geom_boxplot()  +
stat_boxplot(geom = "errorbar", width = 0.5) +  #draw the whiskers
scale_x_discrete(name = "") +
scale_y_continuous(name = "Log10 (MSE / MSE base) ")
ylim1 = boxplot.stats(log(dataPlot$V1))$stats[c(1, 5)]
currentPlot = currentPlot + coord_cartesian(ylim = ylim1*1.1)  + geom_hline(yintercept = 0, color='darkred')
print(currentPlot)
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/parseHierResults_aggregatedH.R')
currentPlot = currentPlot + coord_cartesian(ylim = ylim1*1.1)  + geom_hline(yintercept = 0, color='darkblue')
parseHierResults_aggregatedH <- function (dset){
#parse the results of hierarchical non-temporal reconciliation
#readt the mse, extract the proportion of favorable signs and the produces the boxplot
library(readr)
results <- read_csv(paste("results/mseHierReconc",dset,".csv",sep=""))
results <- unique(results) #because some experiements on the cluster are duplicated
fmethods <- unique(results$fmethod)
dsets <- unique(results$dset)
configs <- length(fmethods) * length(dsets)
#the 7 fields are fmethod, dset, prop against each method
# header <- c("dset","fmethod","h","propBeatBase","propBeatBu","propBeatComb",
# "propBeatCombWls","propBeatMint")
# favorableProps <- matrix(nrow = configs, ncol = length(header))
#we need first to instantiate the data frame with placeholder values, and then we fill the correct values
favorableProps <- data.frame(dset=rep(dsets[1],configs),
fmethod=rep(fmethods[1],configs),
propBeatBase=rep(-1,configs),
propBeatMint=rep(-1,configs),
medianBaseBayes=rep(-1,configs),
medianMintBayes=rep(-1,configs),
propCorrBeatBase=rep(-1,configs),
propCorrBeatMint=rep(-1,configs),
medianBaseBayesCorr=rep(-1,configs),
medianMintBayesCorr=rep(-1,configs),
stringsAsFactors = FALSE
)
counter <- 1
for (dset in dsets){
for (fmethod in fmethods){
print(paste(fmethod,dset))
favorableProps$dset[counter] <- dset
favorableProps$fmethod[counter] <- fmethod
idx = results$fmethod==fmethod & results$dset==dset
if (sum(idx)>0){
subresults <- results[idx,]
favorableProps$propBeatBase[counter] <- mean (subresults$mseBase>subresults$mseBayes)
favorableProps$propBeatMint[counter] <- mean (subresults$mseCombMint>subresults$mseBayes)
favorableProps$medianBaseBayes[counter] <- median(subresults$mseBase / subresults$mseBayes)
favorableProps$medianMintBayes[counter] <- median(subresults$mseCombMint / subresults$mseBayes)
favorableProps$propCorrBeatBase[counter] <- mean (subresults$mseBase>subresults$mseBayesCorr)
favorableProps$propCorrBeatMint[counter] <- mean (subresults$mseCombMint>subresults$mseBayesCorr)
favorableProps$medianBaseBayesCorr[counter]  <- median(subresults$mseBase / subresults$mseBayesCorr)
favorableProps$medianMintBayesCorr[counter] <- median(subresults$mseCombMint / subresults$mseBayesCorr)
#generate the bplot with ggplot2
library(ggplot2)
pdfname <- paste("results/plot","_",dset,"_",fmethod,".pdf",sep = "")
denom <- subresults$mseBase
resLenght <- length(subresults$mseBase)
relMse <- rbind(matrix(subresults$mseCombMint/denom), matrix(subresults$mseBayes/denom), matrix(subresults$mseBayesCorr/denom))
label <-  factor(rbind(matrix(rep("Mint",resLenght)),matrix(rep("Bayes",resLenght)),matrix(rep("Bayes (corr)",resLenght))),
levels = c("Mint","Bayes","Bayes (corr)"))
dataPlot <- as.data.frame(relMse)
dataPlot$label <- label
currentPlot <- ggplot(dataPlot, aes(x = label, y = log10(relMse))) + geom_boxplot()  +
stat_boxplot(geom = "errorbar", width = 0.5) +  #draw the whiskers
scale_x_discrete(name = "") +
scale_y_continuous(name = "Log10 (MSE / MSE base) ")
ylim1 = boxplot.stats(log(dataPlot$V1))$stats[c(1, 5)]
currentPlot = currentPlot + coord_cartesian(ylim = ylim1*1.1)  + geom_hline(yintercept = 0, color='darkblue')
print(currentPlot)
ggsave(pdfname, width = 4, height = 3)
#absolute boxplot
pdfname <- paste("results/baseplot","_",dset,"_",fmethod,".pdf",sep = "")
denom <- subresults$mseBase
resLenght <- length(subresults$mseBase)
mse <- rbind(matrix(subresults$mseBase),matrix(subresults$mseCombMint), matrix(subresults$mseBayes), matrix(subresults$mseBayesCorr))
label <-  factor(rbind(matrix(rep("Base",resLenght)),matrix(rep("Mint",resLenght)),matrix(rep("Bayes",resLenght)),matrix(rep("Bayes (corr)",resLenght))),
levels = c("Base","Mint","Bayes","Bayes (corr)"))
dataPlot <- as.data.frame(mse)
dataPlot$label <- label
currentPlot <- ggplot(dataPlot, aes(x = label, y = (mse))) + geom_boxplot()  +
stat_boxplot(geom = "errorbar", width = 0.5) +  #draw the whiskers
scale_x_discrete(name = "") +
scale_y_continuous(name = " MSE ")
ylim1 = boxplot.stats(subresults$mseBase)$stats[c(1, 5)]
currentPlot = currentPlot + coord_cartesian(ylim = ylim1*1.3)
print(currentPlot)
ggsave(pdfname, width = 4, height = 3)
counter <- counter + 1
}
filename=paste("results/summary",dset,".csv",sep="")
write.table(favorableProps,file=filename,sep=",",row.names = FALSE)
return (favorableProps)
}
parseHierResults_aggregatedH <- function (dset){
#parse the results of hierarchical non-temporal reconciliation
#readt the mse, extract the proportion of favorable signs and the produces the boxplot
library(readr)
results <- read_csv(paste("results/mseHierReconc",dset,".csv",sep=""))
results <- unique(results) #because some experiements on the cluster are duplicated
fmethods <- unique(results$fmethod)
dsets <- unique(results$dset)
configs <- length(fmethods) * length(dsets)
#the 7 fields are fmethod, dset, prop against each method
# header <- c("dset","fmethod","h","propBeatBase","propBeatBu","propBeatComb",
# "propBeatCombWls","propBeatMint")
# favorableProps <- matrix(nrow = configs, ncol = length(header))
#we need first to instantiate the data frame with placeholder values, and then we fill the correct values
favorableProps <- data.frame(dset=rep(dsets[1],configs),
fmethod=rep(fmethods[1],configs),
propBeatBase=rep(-1,configs),
propBeatMint=rep(-1,configs),
medianBaseBayes=rep(-1,configs),
medianMintBayes=rep(-1,configs),
propCorrBeatBase=rep(-1,configs),
propCorrBeatMint=rep(-1,configs),
medianBaseBayesCorr=rep(-1,configs),
medianMintBayesCorr=rep(-1,configs),
stringsAsFactors = FALSE
)
counter <- 1
for (dset in dsets){
for (fmethod in fmethods){
print(paste(fmethod,dset))
favorableProps$dset[counter] <- dset
favorableProps$fmethod[counter] <- fmethod
idx = results$fmethod==fmethod & results$dset==dset
if (sum(idx)>0){
subresults <- results[idx,]
favorableProps$propBeatBase[counter] <- mean (subresults$mseBase>subresults$mseBayes)
favorableProps$propBeatMint[counter] <- mean (subresults$mseCombMint>subresults$mseBayes)
favorableProps$medianBaseBayes[counter] <- median(subresults$mseBase / subresults$mseBayes)
favorableProps$medianMintBayes[counter] <- median(subresults$mseCombMint / subresults$mseBayes)
favorableProps$propCorrBeatBase[counter] <- mean (subresults$mseBase>subresults$mseBayesCorr)
favorableProps$propCorrBeatMint[counter] <- mean (subresults$mseCombMint>subresults$mseBayesCorr)
favorableProps$medianBaseBayesCorr[counter]  <- median(subresults$mseBase / subresults$mseBayesCorr)
favorableProps$medianMintBayesCorr[counter] <- median(subresults$mseCombMint / subresults$mseBayesCorr)
#generate the bplot with ggplot2
library(ggplot2)
pdfname <- paste("results/plot","_",dset,"_",fmethod,".pdf",sep = "")
denom <- subresults$mseBase
resLenght <- length(subresults$mseBase)
relMse <- rbind(matrix(subresults$mseCombMint/denom), matrix(subresults$mseBayes/denom), matrix(subresults$mseBayesCorr/denom))
label <-  factor(rbind(matrix(rep("Mint",resLenght)),matrix(rep("Bayes",resLenght)),matrix(rep("Bayes (corr)",resLenght))),
levels = c("Mint","Bayes","Bayes (corr)"))
dataPlot <- as.data.frame(relMse)
dataPlot$label <- label
currentPlot <- ggplot(dataPlot, aes(x = label, y = log10(relMse))) + geom_boxplot()  +
stat_boxplot(geom = "errorbar", width = 0.5) +  #draw the whiskers
scale_x_discrete(name = "") +
scale_y_continuous(name = "Log10 (MSE / MSE base) ")
ylim1 = boxplot.stats(log(dataPlot$V1))$stats[c(1, 5)]
currentPlot = currentPlot + coord_cartesian(ylim = ylim1*1.1)  + geom_hline(yintercept = 0, color='darkblue')
print(currentPlot)
ggsave(pdfname, width = 4, height = 3)
#absolute boxplot
pdfname <- paste("results/baseplot","_",dset,"_",fmethod,".pdf",sep = "")
denom <- subresults$mseBase
resLenght <- length(subresults$mseBase)
mse <- rbind(matrix(subresults$mseBase),matrix(subresults$mseCombMint), matrix(subresults$mseBayes), matrix(subresults$mseBayesCorr))
label <-  factor(rbind(matrix(rep("Base",resLenght)),matrix(rep("Mint",resLenght)),matrix(rep("Bayes",resLenght)),matrix(rep("Bayes (corr)",resLenght))),
levels = c("Base","Mint","Bayes","Bayes (corr)"))
dataPlot <- as.data.frame(mse)
dataPlot$label <- label
currentPlot <- ggplot(dataPlot, aes(x = label, y = (mse))) + geom_boxplot()  +
stat_boxplot(geom = "errorbar", width = 0.5) +  #draw the whiskers
scale_x_discrete(name = "") +
scale_y_continuous(name = " MSE ")
ylim1 = boxplot.stats(subresults$mseBase)$stats[c(1, 5)]
currentPlot = currentPlot + coord_cartesian(ylim = ylim1*1.3)
print(currentPlot)
ggsave(pdfname, width = 4, height = 3)
counter <- counter + 1
}
filename=paste("results/summary",dset,".csv",sep="")
write.table(favorableProps,file=filename,sep=",",row.names = FALSE)
return (favorableProps)
}
parseHierResults_aggregatedH("infantgts")
parseHierResults_aggregatedH("tourism")
?hts
library(hts)
?thief
library("thief")
library("thief")?thief
?thief
citation("thief")
print(citation("thief"),bibtex=TRUE)
print(citation("hts"),bibtex=TRUE)
print(citation("mcomp"),bibtex=TRUE)
library(Mcomp)
print(citation("Mcomp"),bibtex=TRUE)
print(citation("huge"),bibtex=TRUE)
?infantgts
summary(infantgts)\
summary(infantgts)
?minT
??minT
infantgts[[1]]
summary(tourism)
library(hts)
library(huge)
source("loadTourism.R")
bayesRecon <- function (correlation){
S <- smatrix(train)
bottomIdx <- seq( nrow(S) - ncol(S) +1, nrow(S))
upperIdx <- setdiff(1:nrow(S),bottomIdx)
#prior mean and covariance of the bottom time series
priorMean <- preds[bottomIdx]
Y_vec <- preds[upperIdx]
Sigma_y <- matrix(nrow = length(upperIdx), ncol = length(upperIdx))
#prior covariance for the bottom time series
bottomVar <- sigma[bottomIdx]^2
priorCov <- diag(bottomVar)
if (correlation){
#the covariances are the covariances of the time series
#the variances are the variances of the forecasts, hence the variances of the residuals
bottomResiduals <- residuals[,bottomIdx]
priorCov <- cov(bottomResiduals)
out.glasso <- huge(bottomResiduals, method = "glasso", cov.output = TRUE)
out.select <- huge.select(out.glasso, criterion = "stars")
priorCov <- out.select$opt.cov
}
#covariance for the upper time series
upperVar <- sigma[upperIdx]^2
Sigma_y <- diag(upperVar)
if (correlation){
#get variance and covariance of the residuals
upperResiduals <- residuals[,upperIdx]
Sigma_y <- cov(upperResiduals)
out.glasso <- huge(upperResiduals, method = "glasso", cov.output = TRUE)
out.select <- huge.select(out.glasso, criterion = "stars")
Sigma_y <- out.select$opt.cov
}
#==updating
#A explains how to combin the bottom series in order to obtain the
# upper series
A <- t(S[upperIdx,])
M <- ncol ( t(A) %*% priorCov %*% A + Sigma_y )
correl <- priorCov %*% A %*%
solve (t(A) %*% priorCov %*% A + Sigma_y + 1e-6*diag(M))
postMean <- priorMean + correl  %*%
(Y_vec - t(A) %*% priorMean)
bayesPreds <- buReconcile(postMean, S, predsAllTs = FALSE)
return(bayesPreds)
}
#The buReconcile function computes the bu prediction given the predictions (1 x tot time series) and the S matrix
#(tot time series X bottom time series)
#predsAllTs is a flag: is set to true, the input preds contains predictions for all the hierarchy
#and the function retrieves the bottom series; if set to false, this is not needed
#as preds only contains only bottom time series
buReconcile <- function (preds,S, predsAllTs = FALSE) {
bottomPreds <- preds
if (predsAllTs) {
#retrieves the bottom prediction from all predictions
upperIdx <- 1 : (nrow(S) - ncol(S))
bottomIdx <- setdiff (1:nrow(S), upperIdx)
bottomPreds <- preds [,bottomIdx]
}
buPreds <- preds
#nrow(S) is the total number of time series
for (i in 1:nrow(S)){
buPreds[i] <- S[i,] %*% bottomPreds
}
return (buPreds)
}
#check the calibration of the prediction interval with coverage (1-currentAlpha)
checkCalibration <- function(preds,sigmas,htsActual,coverage){
stdQuant <- abs(qnorm((1-coverage)/2))
included <- vector(length = length(preds))
actual <- allts(htsActual)[h,]
for (ii in seq_along(preds)){
upper <- preds[ii] + stdQuant * sigmas[ii]
lower <- preds[ii] - stdQuant * sigmas[ii]
included[ii] <- (actual[ii] > lower) &  (actual[ii] < upper)
}
return (mean(included))
}
hierMse <- function (htsPred, htsActual, h) {
#receives two hts objects, containing  forecast and actual value.
#computes the mse for the whole hierarchy.
mse <- mean  ( (allts(htsPred)[h,] - allts(htsActual)[h,])^2 )
return (mse)
}
#extract the time from the data set to then split into train / test (test set contains 25 or 5 time points)
set.seed(seed = 0)
hierTs <- loadTourism()
summary(hierTs)
?infantgts
summary(infantgts)
tourism
#here the experiment starts
timeIdx             <- time(hierTs$bts[,1])
endTrain            <- length(timeIdx) - h - (iTest - 1)
train               <- window(hierTs, start = timeIdx[1], end = timeIdx[endTrain] )
test                <- window(hierTs, start =timeIdx[endTrain +1], end=timeIdx[endTrain + h])
fcastCombMint       <- forecast(train, h = h, method = "comb", weights="mint", fmethod=fmethod)
mseCombMint  <- hierMse(fcastCombMint, test,  h)
hierTs <- loadTourism()
a<-allts(hierTs)
class(a)
cor(a)
mean(abs(cor(a))>0.5)
mean(abs(cor(a))>0.8)
a
diag(a)<-0
mean(abs(cor(a))>0.8)
mean(abs(cor(a))>0.5)
mean(abs(cor(a))>0.4)
b<-allts(infantgts)
mean(abs(cor(b))>0.4)
diag(b)<-0
mean(abs(cor(b))>0.4)
summary(infantgts)
dim(cor(b))
b
b<-allts(infantgts)
corb<-cor(b)
diag(corb)<-0
corb
mean(corb>0.5)
corTour<-cor(allts(tourism))
corTour<-cor(allts(hierTs))
diag(corTour)<-0
mean(corTour>.4)
library(thief)
?thief
parseHierResults_aggregatedH <- function (dset){
#parse the results of hierarchical non-temporal reconciliation
#readt the mse, extract the proportion of favorable signs and the produces the boxplot
library(readr)
results <- read_csv(paste("results/mseHierReconc",dset,".csv",sep=""))
results <- unique(results) #because some experiements on the cluster are duplicated
fmethods <- unique(results$fmethod)
dsets <- unique(results$dset)
configs <- length(fmethods) * length(dsets)
#the 7 fields are fmethod, dset, prop against each method
# header <- c("dset","fmethod","h","propBeatBase","propBeatBu","propBeatComb",
# "propBeatCombWls","propBeatMint")
# favorableProps <- matrix(nrow = configs, ncol = length(header))
#we need first to instantiate the data frame with placeholder values, and then we fill the correct values
favorableProps <- data.frame(dset=rep(dsets[1],configs),
fmethod=rep(fmethods[1],configs),
propBeatBase=rep(-1,configs),
propBeatMint=rep(-1,configs),
medianBaseBayes=rep(-1,configs),
medianMintBayes=rep(-1,configs),
propCorrBeatBase=rep(-1,configs),
propCorrBeatMint=rep(-1,configs),
medianBaseBayesCorr=rep(-1,configs),
medianMintBayesCorr=rep(-1,configs),
stringsAsFactors = FALSE
)
counter <- 1
for (dset in dsets){
for (fmethod in fmethods){
print(paste(fmethod,dset))
favorableProps$dset[counter] <- dset
favorableProps$fmethod[counter] <- fmethod
idx = results$fmethod==fmethod & results$dset==dset
if (sum(idx)>0){
subresults <- results[idx,]
favorableProps$propBeatBase[counter] <- mean (subresults$mseBase>subresults$mseBayes)
favorableProps$propBeatMint[counter] <- mean (subresults$mseCombMint>subresults$mseBayes)
favorableProps$medianBaseBayes[counter] <- median(subresults$mseBase / subresults$mseBayes)
favorableProps$medianMintBayes[counter] <- median(subresults$mseCombMint / subresults$mseBayes)
favorableProps$propCorrBeatBase[counter] <- mean (subresults$mseBase>subresults$mseBayesCorr)
favorableProps$propCorrBeatMint[counter] <- mean (subresults$mseCombMint>subresults$mseBayesCorr)
favorableProps$medianBaseBayesCorr[counter]  <- median(subresults$mseBase / subresults$mseBayesCorr)
favorableProps$medianMintBayesCorr[counter] <- median(subresults$mseCombMint / subresults$mseBayesCorr)
#generate the bplot with ggplot2
library(ggplot2)
pdfname <- paste("results/plot","_",dset,"_",fmethod,".pdf",sep = "")
denom <- subresults$mseBase
resLenght <- length(subresults$mseBase)
relMse <- rbind(matrix(subresults$mseCombMint/denom), matrix(subresults$mseBayes/denom), matrix(subresults$mseBayesCorr/denom))
label <-  factor(rbind(matrix(rep("Mint",resLenght)),matrix(rep("Bayes",resLenght)),matrix(rep("Bayes (corr)",resLenght))),
levels = c("Mint","Bayes","Bayes (corr)"))
dataPlot <- as.data.frame(relMse)
dataPlot$label <- label
currentPlot <- ggplot(dataPlot, aes(x = label, y = log10(relMse))) + geom_boxplot()  +
stat_boxplot(geom = "errorbar", width = 0.5) +  #draw the whiskers
scale_x_discrete(name = "") +
scale_y_continuous(name = "Log10 (MSE / MSE base) ")
ylim1 = boxplot.stats(log(dataPlot$V1))$stats[c(1, 5)]
currentPlot = currentPlot + coord_cartesian(ylim = ylim1*1.1)  + geom_hline(yintercept = 0, color='darkblue')
print(currentPlot)
ggsave(pdfname, width = 4, height = 3)
#absolute boxplot
pdfname <- paste("results/baseplot","_",dset,"_",fmethod,".pdf",sep = "")
denom <- subresults$mseBase
resLenght <- length(subresults$mseBase)
mse <- rbind(matrix(subresults$mseBase),matrix(subresults$mseCombMint), matrix(subresults$mseBayes), matrix(subresults$mseBayesCorr))
label <-  factor(rbind(matrix(rep("Base",resLenght)),matrix(rep("Mint",resLenght)),matrix(rep("Bayes",resLenght)),matrix(rep("Bayes (corr)",resLenght))),
levels = c("Base","Mint","Bayes","Bayes (corr)"))
dataPlot <- as.data.frame(mse)
dataPlot$label <- label
currentPlot <- ggplot(dataPlot, aes(x = label, y = (mse))) + geom_boxplot()  +
stat_boxplot(geom = "errorbar", width = 0.5) +  #draw the whiskers
scale_x_discrete(name = "") +
scale_y_continuous(name = " MSE ")
ylim1 = boxplot.stats(subresults$mseBase)$stats[c(1, 5)]
currentPlot = currentPlot + coord_cartesian(ylim = ylim1*1.3)
print(currentPlot)
ggsave(pdfname, width = 4, height = 3)
counter <- counter + 1
}
filename=paste("results/summary",dset,".csv",sep="")
write.table(favorableProps,file=filename,sep=",",row.names = FALSE)
return (favorableProps)
}
parseHierResults_aggregatedH("tourism")
parseHierResults_aggregatedH("infantgts")
parseHierResults_aggregatedH <- function (dset){
#parse the results of hierarchical non-temporal reconciliation
#readt the mse, extract the proportion of favorable signs and the produces the boxplot
library(readr)
results <- read_csv(paste("results/mseHierReconc",dset,".csv",sep=""))
results <- unique(results) #because some experiements on the cluster are duplicated
fmethods <- unique(results$fmethod)
dsets <- unique(results$dset)
configs <- length(fmethods) * length(dsets)
#the 7 fields are fmethod, dset, prop against each method
# header <- c("dset","fmethod","h","propBeatBase","propBeatBu","propBeatComb",
# "propBeatCombWls","propBeatMint")
# favorableProps <- matrix(nrow = configs, ncol = length(header))
#we need first to instantiate the data frame with placeholder values, and then we fill the correct values
favorableProps <- data.frame(dset=rep(dsets[1],configs),
fmethod=rep(fmethods[1],configs),
propBeatBase=rep(-1,configs),
propBeatMint=rep(-1,configs),
medianBaseBayes=rep(-1,configs),
medianMintBayes=rep(-1,configs),
propCorrBeatBase=rep(-1,configs),
propCorrBeatMint=rep(-1,configs),
medianBaseBayesCorr=rep(-1,configs),
medianMintBayesCorr=rep(-1,configs),
stringsAsFactors = FALSE
)
counter <- 1
for (dset in dsets){
for (fmethod in fmethods){
print(paste(fmethod,dset))
favorableProps$dset[counter] <- dset
favorableProps$fmethod[counter] <- fmethod
idx = results$fmethod==fmethod & results$dset==dset
if (sum(idx)>0){
subresults <- results[idx,]
favorableProps$propBeatBase[counter] <- mean (subresults$mseBase>subresults$mseBayes)
favorableProps$propBeatMint[counter] <- mean (subresults$mseCombMint>subresults$mseBayes)
favorableProps$medianBaseBayes[counter] <- median(subresults$mseBase / subresults$mseBayes)
favorableProps$medianMintBayes[counter] <- median(subresults$mseCombMint / subresults$mseBayes)
favorableProps$propCorrBeatBase[counter] <- mean (subresults$mseBase>subresults$mseBayesCorr)
favorableProps$propCorrBeatMint[counter] <- mean (subresults$mseCombMint>subresults$mseBayesCorr)
favorableProps$medianBaseBayesCorr[counter]  <- median(subresults$mseBase / subresults$mseBayesCorr)
favorableProps$medianMintBayesCorr[counter] <- median(subresults$mseCombMint / subresults$mseBayesCorr)
#generate the bplot with ggplot2
library(ggplot2)
pdfname <- paste("results/plot","_",dset,"_",fmethod,".pdf",sep = "")
denom <- subresults$mseBase
resLenght <- length(subresults$mseBase)
relMse <- rbind(matrix(subresults$mseCombMint/denom), matrix(subresults$mseBayes/denom), matrix(subresults$mseBayesCorr/denom))
label <-  factor(rbind(matrix(rep("Mint",resLenght)),matrix(rep("Bayes",resLenght)),matrix(rep("Bayes (corr)",resLenght))),
levels = c("Mint","Bayes","Bayes (corr)"))
dataPlot <- as.data.frame(relMse)
dataPlot$label <- label
currentPlot <- ggplot(dataPlot, aes(x = label, y = log10(relMse))) + geom_boxplot()  +
stat_boxplot(geom = "errorbar", width = 0.5) +  #draw the whiskers
scale_x_discrete(name = "") +
scale_y_continuous(name = "Log10 (MSE / MSE base) ")
ylim1 = boxplot.stats(log(dataPlot$V1))$stats[c(1, 5)]
currentPlot = currentPlot + coord_cartesian(ylim = ylim1*1.1)  + geom_hline(yintercept = 0, color='darkblue')
print(currentPlot)
ggsave(pdfname, width = 4, height = 3)
# #absolute boxplot
# pdfname <- paste("results/baseplot","_",dset,"_",fmethod,".pdf",sep = "")
# denom <- subresults$mseBase
# resLenght <- length(subresults$mseBase)
# mse <- rbind(matrix(subresults$mseBase),matrix(subresults$mseCombMint), matrix(subresults$mseBayes), matrix(subresults$mseBayesCorr))
# label <-  factor(rbind(matrix(rep("Base",resLenght)),matrix(rep("Mint",resLenght)),matrix(rep("Bayes",resLenght)),matrix(rep("Bayes (corr)",resLenght))),
#                  levels = c("Base","Mint","Bayes","Bayes (corr)"))
#
# dataPlot <- as.data.frame(mse)
# dataPlot$label <- label
# currentPlot <- ggplot(dataPlot, aes(x = label, y = (mse))) + geom_boxplot()  +
#   stat_boxplot(geom = "errorbar", width = 0.5) +  #draw the whiskers
#   scale_x_discrete(name = "") +
#   scale_y_continuous(name = " MSE ")
# ylim1 = boxplot.stats(subresults$mseBase)$stats[c(1, 5)]
# currentPlot = currentPlot + coord_cartesian(ylim = ylim1*1.3)
#
# print(currentPlot)
# ggsave(pdfname, width = 4, height = 3)
counter <- counter + 1
}
filename=paste("results/summary",dset,".csv",sep="")
write.table(favorableProps,file=filename,sep=",",row.names = FALSE)
return (favorableProps)
}
parseHierResults_aggregatedH("infantgts")
