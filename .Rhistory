seasonal[t+m] <- gamma * (y[t] - l0 - b0) + gamma * seasonal[t]
}
else{
fitted[t] = level[t-1] + slope[t-1] + seasonal[t]
level[t]  = alpha * (y[t] -seasonal[t] ) + (1-alpha) * (level[t-1] + slope[t-1])
slope[t]  = beta * ( level[t] - level[t-1]) + (1 - beta) * slope[t-1]
seasonal[t+m] <- gamma * (y[t] - level[t-1] - slope[t-1]) + gamma * seasonal[t]
}
#plot the  actual and the fitted value
#before, we need to cast y and fitted as ts objects
y <- ts(y)
fitted <- ts(fitted)
#we pass the name of the series in order to
#have a sensible legend
autoplot(y, series="y") + autolayer(fitted, series="fitted") +
ggtitle("Actual vs fitted")
s0
ggseasonplot(y)
y <- ts(c(30,21,29,31,40,48,53,47,37,39,31,29,17,9,20,24,27,35,41,38,
27,31,27,26,21,13,21,18,33,35,40,36,22,24,21,20,17,14,17,19,
26,29,40,31,20,24,18,26,17,9,17,21,28,32,46,33,23,28,22,27,
18,8,17,21,31,34,44,38,31,30,26,32), frequency = 12)
source('~/switchDrive/teaching/AnSeqData/scripts/seasonal.R')
y <- ts(c(30,21,29,31,40,48,53,47,37,39,31,29,17,9,20,24,27,35,41,38,
27,31,27,26,21,13,21,18,33,35,40,36,22,24,21,20,17,14,17,19,
26,29,40,31,20,24,18,26,17,9,17,21,28,32,46,33,23,28,22,27,
18,8,17,21,31,34,44,38,31,30,26,32), frequency = 12)
ggseasonplot(y)
ggsubseriesplot()
ggsubseriesplot(y)
ggsubseriesplot(fitted)
alpha <- 0.52
beta <-  0.03
gamma <- 0.01
l0 <- 39.5
b0 <- -0.39
s0 <-
c(-0.31, -2.96, 2.12, -0.79, 10.01, 16.55, 7.90,
3.25, -5.05, -7.29, -15.12, -8.31)
#better init
for (j in (1:12)){
idx = seq(from=j, to=length(y), by = 12 )
s0[j] <- mean(y[idx]) - mean(y)
}
#length of the period
m <- frequency(y)
#level[t] and slope[t]  contains level and slope, as updated after
#having observed the value of yt.
level <- vector(length = length(y))
slope <- vector(length = length(y))
#fitted[t] contains the value predicted at time (t-1) for t
fitted <- vector(length = length(y))
#difference between y[t] and fitted[t]
residual <- vector(length = length(y))
#seasonal[t] is s(t-m).
#Hence it is used at time t for updating the estimate of the level.
#When at time t we update the seasonal component, we store it in
#seasonal[t+frequency], where frequency denotes the length of the period
#(12 for a monthly time series).
seasonal  <- vector(length = ( length(y) + m) )
seasonal[1:m] <- s0
#compute fitted values on the training data
for (t in (1:length(y))){
if (t==1){
fitted[t] = l0 + b0 + seasonal[t]
level[t]  = alpha * (y[t] -seasonal[t] ) + (1-alpha) * (l0 + b0)
slope[t]  = beta * ( level[t] - l0) + (1 - beta) * b0
seasonal[t+m] <- gamma * (y[t] - l0 - b0) + gamma * seasonal[t]
}
else{
fitted[t] = level[t-1] + slope[t-1] + seasonal[t]
level[t]  = alpha * (y[t] -seasonal[t] ) + (1-alpha) * (level[t-1] + slope[t-1])
slope[t]  = beta * ( level[t] - level[t-1]) + (1 - beta) * slope[t-1]
seasonal[t+m] <- gamma * (y[t] - level[t-1] - slope[t-1]) + gamma * seasonal[t]
}
#tail is a function which extracts the last n values from a vector
lastLevel <- tail(level,1)
lastSlope <- tail(slope,1)
lastSeasonal <- tail(slope,12)
lastSeasonal
#h is the forecast horizon
fcast <- vector(length = (2*m))
for (h in (1: (2*m))) {
seasIdx <- h %% m
#works correctly apart from h=12, 24, 36.
#e.g. h=6  and h=18 both yield (h %% m) = 6
#but  h=12  and h=24 both yield (h %% m) = 0, hence the need
#for the fix below
if ( (h %% m) == 0) {
seasIdx <- m
}
fcast[h] <- lastLevel + h * lastSlope + lastSeasonal[seasIdx]
}
ggsubseriesplot(ts(fitted, frequency = m))
#compute fitted values on the training data
for (t in (1:length(y))){
if (t==1){
fitted[t] = l0 + b0 + seasonal[t]
level[t]  = alpha * (y[t] -seasonal[t] ) + (1-alpha) * (l0 + b0)
slope[t]  = beta * ( level[t] - l0) + (1 - beta) * b0
seasonal[t+m] <- gamma * (y[t] - l0 - b0) + gamma * seasonal[t]
}
else{
fitted[t] = level[t-1] + slope[t-1] + seasonal[t]
level[t]  = alpha * (y[t] -seasonal[t] ) + (1-alpha) * (level[t-1] + slope[t-1])
slope[t]  = beta * ( level[t] - level[t-1]) + (1 - beta) * slope[t-1]
seasonal[t+m] <- gamma * (y[t] - level[t-1] - slope[t-1]) + gamma * seasonal[t]
}
library(fpp2)
y <- ts(c(30,21,29,31,40,48,53,47,37,39,31,29,17,9,20,24,27,35,41,38,
27,31,27,26,21,13,21,18,33,35,40,36,22,24,21,20,17,14,17,19,
26,29,40,31,20,24,18,26,17,9,17,21,28,32,46,33,23,28,22,27,
18,8,17,21,31,34,44,38,31,30,26,32), frequency = 12)
#those parameters should be obtained by minimizing
#the squared residuals on the training data; in this case they are given
alpha <- 0.52
beta <-  0.03
gamma <- 0.01
l0 <- 39.5
b0 <- -0.39
s0 <-
c(-0.31, -2.96, 2.12, -0.79, 10.01, 16.55, 7.90,
3.25, -5.05, -7.29, -15.12, -8.31)
#better init
for (j in (1:12)){
idx = seq(from=j, to=length(y), by = 12 )
s0[j] <- mean(y[idx]) - mean(y)
}
#length of the period
m <- frequency(y)
#level[t] and slope[t]  contains level and slope, as updated after
#having observed the value of yt.
level <- vector(length = length(y))
slope <- vector(length = length(y))
#fitted[t] contains the value predicted at time (t-1) for t
fitted <- vector(length = length(y))
#difference between y[t] and fitted[t]
residual <- vector(length = length(y))
#seasonal[t] is s(t-m).
#Hence it is used at time t for updating the estimate of the level.
#When at time t we update the seasonal component, we store it in
#seasonal[t+frequency], where frequency denotes the length of the period
#(12 for a monthly time series).
seasonal  <- vector(length = ( length(y) + m) )
seasonal[1:m] <- s0
seasonal[1]
seasonal[1:12]
fitted[1:12]
#compute fitted values on the training data
for (t in (1:length(y))){
if (t==1){
fitted[t] = l0 + b0 + seasonal[t]
level[t]  = alpha * (y[t] -seasonal[t] ) + (1-alpha) * (l0 + b0)
slope[t]  = beta * ( level[t] - l0) + (1 - beta) * b0
seasonal[t+m] <- gamma * (y[t] - l0 - b0) + gamma * seasonal[t]
}
else{
fitted[t] = level[t-1] + slope[t-1] + seasonal[t]
level[t]  = alpha * (y[t] -seasonal[t] ) + (1-alpha) * (level[t-1] + slope[t-1])
slope[t]  = beta * ( level[t] - level[t-1]) + (1 - beta) * slope[t-1]
seasonal[t+m] <- gamma * (y[t] - level[t-1] - slope[t-1]) + gamma * seasonal[t]
}
fitted[1:12]
autoplot(ts(seasonal))
debugSource('~/switchDrive/teaching/AnSeqData/scripts/seasonal.R')
library(fpp2)
y <- ts(c(30,21,29,31,40,48,53,47,37,39,31,29,17,9,20,24,27,35,41,38,
27,31,27,26,21,13,21,18,33,35,40,36,22,24,21,20,17,14,17,19,
26,29,40,31,20,24,18,26,17,9,17,21,28,32,46,33,23,28,22,27,
18,8,17,21,31,34,44,38,31,30,26,32), frequency = 12)
#those parameters should be obtained by minimizing
#the squared residuals on the training data; in this case they are given
alpha <- 0.52
beta <-  0.03
gamma <- 0.01
l0 <- 39.5
b0 <- -0.39
s0 <-
c(-0.31, -2.96, 2.12, -0.79, 10.01, 16.55, 7.90,
3.25, -5.05, -7.29, -15.12, -8.31)
#better init
for (j in (1:12)){
idx = seq(from=j, to=length(y), by = 12 )
s0[j] <- mean(y[idx]) - mean(y)
}
#length of the period
m <- frequency(y)
#level[t] and slope[t]  contains level and slope, as updated after
#having observed the value of yt.
level <- vector(length = length(y))
slope <- vector(length = length(y))
#fitted[t] contains the value predicted at time (t-1) for t
fitted <- vector(length = length(y))
#difference between y[t] and fitted[t]
residual <- vector(length = length(y))
#seasonal[t] is s(t-m).
#Hence it is used at time t for updating the estimate of the level.
#When at time t we update the seasonal component, we store it in
#seasonal[t+frequency], where frequency denotes the length of the period
#(12 for a monthly time series).
seasonal  <- vector(length = ( length(y) + m) )
seasonal[1:m] <- s0
#compute fitted values on the training data
for (t in (1:length(y))){
if (t==1){
fitted[t] = l0 + b0 + seasonal[t]
level[t]  = alpha * (y[t] -seasonal[t] ) + (1-alpha) * (l0 + b0)
slope[t]  = beta * ( level[t] - l0) + (1 - beta) * b0
seasonal[t+m] <- gamma * (y[t] - l0 - b0) + (1-gamma) * seasonal[t]
}
else{
fitted[t] = level[t-1] + slope[t-1] + seasonal[t]
level[t]  = alpha * (y[t] -seasonal[t] ) + (1-alpha) * (level[t-1] + slope[t-1])
slope[t]  = beta * ( level[t] - level[t-1]) + (1 - beta) * slope[t-1]
seasonal[t+m] <- gamma * (y[t] - level[t-1] - slope[t-1]) + (1-gamma) * seasonal[t]
}
#forecast the next two seasons
#tail is a function which extracts the last n values from a vector
lastLevel <- tail(level,1)
lastSlope <- tail(slope,1)
lastSeasonal <- tail(slope,12)
#h is the forecast horizon
fcast <- vector(length = (2*m))
for (h in (1: (2*m))) {
seasIdx <- h %% m
#works correctly apart from h=12, 24, 36.
#e.g. h=6  and h=18 both yield (h %% m) = 6
#but  h=12  and h=24 both yield (h %% m) = 0, hence the need
#for the fix below
if ( (h %% m) == 0) {
seasIdx <- m
}
fcast[h] <- lastLevel + h * lastSlope + lastSeasonal[seasIdx]
}
#plot the  actual and the fitted value
#before, we need to cast y and fitted as ts objects
fitted <- ts(fitted)
#we pass the name of the series in order to
#have a sensible legend
autoplot(y, series="y") + autolayer(fitted, series="fitted") +
ggtitle("Actual vs fitted")
#plot the forecast
autoplot(ts(fcast))
#plot the decomposed time series
#we pass the name of the series in order to
#have a sensible legend
autoplot(y, series="y") + autolayer(fitted, series="fitted") +
ggtitle("Actual vs fitted")
source('~/switchDrive/teaching/AnSeqData/scripts/seasonal.R')
#plot the  actual and the fitted value
#before, we need to cast y and fitted as ts objects
fitted <- ts(fitted, frequency = 12)
#we pass the name of the series in order to
#have a sensible legend
autoplot(y, series="y") + autolayer(fitted, series="fitted") +
ggtitle("Actual vs fitted")
#plot the forecast
autoplot(ts(fcast))
lastSeasonal
#tail is a function which extracts the last n values from a vector
lastLevel <- tail(level,1)
lastSlope <- tail(slope,1)
lastSeasonal <- tail(seasonal,12)
#h is the forecast horizon
fcast <- vector(length = (2*m))
for (h in (1: (2*m))) {
seasIdx <- h %% m
#works correctly apart from h=12, 24, 36.
#e.g. h=6  and h=18 both yield (h %% m) = 6
#but  h=12  and h=24 both yield (h %% m) = 0, hence the need
#for the fix below
if ( (h %% m) == 0) {
seasIdx <- m
}
fcast[h] <- lastLevel + h * lastSlope + lastSeasonal[seasIdx]
}
#plot the  actual and the fitted value
#before, we need to cast y and fitted as ts objects
fitted <- ts(fitted, frequency = 12)
#we pass the name of the series in order to
#have a sensible legend
autoplot(y, series="y") + autolayer(fitted, series="fitted") +
ggtitle("Actual vs fitted")
#plot the forecast
autoplot(ts(fcast))
#plot the forecast
autoplot(ts(fcast), series="forecast") + ggtitle("Forecast
of the next two seasons")
#plot the forecast
autoplot(ts(fcast), series="forecast") +
ggtitle("Forecast of the next two seasons")
#plot the forecast
autoplot(ts(fcast), series="forecast") + ggtitle("Forecasts")
#plot the forecast
autoplot(ts(fcast)) + ggtitle("Forecasts")
source('~/switchDrive/teaching/AnSeqData/scripts/seasonal.R')
#plot the decomposed time series
autoplot(y, series="y") +
autolayer(slope, series="slope") +
autolayer(level, series="level") +
autolayer(seasonal, series="season") +
autolayer(residual, series="residual") +
ggtitle("Decomposed time series")
source('~/switchDrive/teaching/AnSeqData/scripts/seasonal.R')
#plot the decomposed time series
autoplot(y, series="y") +
autolayer(ts(slope), series="slope") +
autolayer(ts(level), series="level") +
autolayer(ts(seasonal), series="season") +
autolayer(ts(residual), series="residual") +
ggtitle("Decomposed time series")
source('~/switchDrive/teaching/AnSeqData/scripts/seasonal.R')
#plot the decomposed time series
autoplot(y, series="y") +
autolayer(ts(slope), series="slope") +
autolayer(ts(level), series="level") +
autolayer(ts(seasonal[1:length(y)]), series="season") +
autolayer(ts(residual), series="residual") +
ggtitle("Decomposed time series")
source('~/switchDrive/teaching/AnSeqData/scripts/seasonal.R')
#plot the decomposed time series
autoplot(ts(y), series="y") +
autolayer(ts(slope), series="slope") +
autolayer(ts(level), series="level") +
autolayer(ts(seasonal[1:length(y)]), series="season") +
autolayer(ts(residual), series="residual") +
ggtitle("Decomposed time series")
a <- ets(y)
autoplot(a)
source('~/switchDrive/teaching/AnSeqData/scripts/seasonal.R')
#plot the decomposed time series
autoplot(ts(y), series="y") +
autolayer(ts(level), series="level") +
autolayer(ts(seasonal[1:length(y)]), series="season") +
autolayer(ts(residual), series="residual") +
ggtitle("Decomposed time series")
source('~/switchDrive/teaching/AnSeqData/scripts/seasonal-exercise.R')
source('~/switchDrive/teaching/AnSeqData/scripts/seasonalExpSmooth-text.R')
library(fpp2)
a <- ses(goog)
length(goog)
length(a$residuals) * log(sum(a$residuals^2)) + 2 *3
a$model$aic
a <- ses(goog)
aic <- length(a$residuals) * log(sum(a$residuals^2)) + 2 *3
a$model$aic
a
aic
a$model$aic
a <- ses(goog * 1000)
aic <- length(a$residuals) * log(sum(a$residuals^2)) + 2 *3
a$model$aic
aic
y <- goog
a <- ses(y)
b <- holt(y)
aic <- length(a$residuals) * log(sum(a$residuals^2)) + 2 *3
a$model$aic
y <- goog
a <- ses(y)
b <- holt(y)
# aic <- length(a$residuals) * log(sum(a$residuals^2)) + 2 *3
a$model$aic
# aic <- length(a$residuals) * log(sum(a$residuals^2)) + 2 *3
a$model$aic
b$model$aic
y <- goog * 1000
a <- ses(y)
b <- holt(y)
# aic <- length(a$residuals) * log(sum(a$residuals^2)) + 2 *3
a$model$aic
b$model$aic
print(a$residuals)
print(log(sum(a$residuals^2)))
print(log(sum(b$residuals^2)))
print(log(sum(c$residuals^2)))
y <- goog
a <- ses(y)
b <- holt(y)
c <- ses(y * 1000)
d <- ses(y * 1000)
aic <- length(a$residuals) * log(sum(a$residuals^2)) + 2 *3
print(log(sum(a$residuals^2)))
print(log(sum(b$residuals^2)))
print(log(sum(c$residuals^2)))
print(log(sum(d$residuals^2)))
a <- ses(y)
b <- holt(y)
c <- ses(y * 1000)
d <- ses(y * 1000)
aic <- length(a$residuals) * log(sum(a$residuals^2)) + 2 *3
print(log(sum(a$residuals^2)))
print(log(sum(b$residuals^2)))
print(log(sum(c$residuals^2)))
print(log(sum(d$residuals^2)))
a$model$aic
b$model$aic
c$model$aic
d$model$aic
d <- holt(y * 1000)
d$model$aic
print(log(sum(a$residuals^2)))
print(log(sum(b$residuals^2)))
print(log(sum(c$residuals^2)))
print(log(sum(d$residuals^2)))
autoplot(hw(gas, seasonal = "additive"))
autoplot(hw(gas, seasonal = "multiplicative"))
accuracy(hw(gas, seasonal = "multiplicative"))
accuracy(hw(gas, seasonal = "additive"))
accuracy(hw(gas, seasonal = "additive", damped = TRUE))
accuracy(hw(gas, seasonal = "multiplicative", damped = TRUE))
checkresiduals(hw(gas, seasonal = "multiplicative"))
a <- hw(gas, seasonal = "multiplicative")
coef(a)
autoplot(a)
?coef
a <- ets(gas, seasonal = "multiplicative")
a <- ets(gas)
coef(a)
plot(a)
autoplot(a)
simulate(a)
library(fpp2)
autoplot(ets(coal))
autoplot(ets(bicoal))
autoplot(forecast(ets(bicoal),h=10))
autoplot(forecast(ets(chicken),h=10))
autoplot(fitted(ets(chicken)))
autoplot(fitted(ets(chicken))) + autolayer(chicken)
autoplot(fitted(ets(dole))) + autolayer(dole)
autoplot(fitted(ets(ibmclose))) + autolayer(ibmclose)
autoplot(fitted(ets(ibmclose))[1:50]) + autolayer(ibmclose[1:50])
a <- ets(ibmclose)
summary(a)
?ndiff
library(fpp2)
?ndiff
??ndiff
ndiffs
library(urca)
?urca
??urca
window(ausair, start=1990, end=2004) %>% holt(damped=TRUE, h=5, PI=FALSE)
library(fpp2)
window(ausair, start=1990, end=2004) %>% holt(damped=TRUE, h=5, PI=FALSE)
window(ausair, start=1990, end=2004) %>% holt(damped=TRUE, h=5, PI=FALSE) %>% summary
log(915)
log(815)
library(fpp2)
fit <- ets(bicaoil)
list <- c(bicoal, chicken, dole, usdeaths,
bricksq, lynx, ibmclose, eggs, bricksq, ausbeer)
tsList <- c(bicoal, chicken, dole, usdeaths,
bricksq, lynx, ibmclose, eggs, bricksq, ausbeer)
tsList
tsList[[1]]
tsList[[2]]
fit <- ets(bicoal)
accuracy(fit, bicoal)
accuracy(fit)
fit <- ets(chicken)
accuracy(fit)
tsList <- list(bicoal, chicken, dole, usdeaths,
bricksq, lynx, ibmclose, eggs, bricksq, ausbeer)
tsList[[1]]
a<-accuracy(fit)
a
a["MAP"]
a["MPA"]
a["MPE"]
a
class(a)
a["ME"]
names(a)
nrow(a)
a[4]
tsList[[1]]
names <- list("bicoal", "chicken", "dole", "usdeaths",
"bricksq", "lynx", "ibmclose", "eggs", "bricksq", "ausbeer")
tsList <- list(bicoal, chicken, dole, usdeaths,
bricksq, lynx, ibmclose, eggs, bricksq, ausbeer)
names <- list("bicoal", "chicken", "dole", "usdeaths",
"bricksq", "lynx", "ibmclose", "eggs", "bricksq", "ausbeer")
for (i in 1:length(tsList)) {
fit <- ets(tsList[[i]])
acc <- accuracy(fit)
mpe <- acc[4] #could not find a nicer way to assess it
print (paste(names[[i]]," mpe: ", as.character(mpe)))
}
fit <- ets(bicaol)
fit <- ets(bicoal)
?bicaol
?bicoal
autoplot(bicaol)
autoplot(bicoal)
fit <- ets(bicoal)
fit
autoplot(bicoal) + autolayer(fitted(fit))
?chicken
autoplot(chicken)
fit <- ets (chicken)
fit
autoplot(chicken) + autolayer(fitted(chicken))
autoplot(chicken) + autolayer(fitted(fit))
fit <- ets (eggs)
accuracy(fit)
autoplot(eggs) + autolayer(fitted(fit))
fit
fit <- ets (lynx)
autoplot(lynx) + autolayer(fitted(fit))
fit
summary(lynx)
