relMse <- rbind(matrix(subresults$mseBu/denom), matrix(subresults$mseComb/denom), matrix(subresults$mseCombWls/denom),
matrix(subresults$mseCombMint/denom), matrix(subresults$mseBayes/denom))
relMse
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/parseHierResults.R')
#generate the bplot with ggplot2
library(ggplot2)
pdfname <- paste("results/GGPLOThier","_",dset,"_",fmethod,".pdf",sep = "")
denom <- subresults$mseBase
resLenght <- length(results$mseBase)
relMse <- rbind(matrix(subresults$mseBu/denom), matrix(subresults$mseComb/denom), matrix(subresults$mseCombWls/denom),
matrix(subresults$mseCombMint/denom), matrix(subresults$mseBayes/denom))
label <-  factor(rbind(matrix(rep("Bu",resLenght)),matrix(rep("Comb",resLenght)),matrix(rep("CombWls",resLenght)),
matrix(rep("Mint",resLenght)),matrix(rep("Bayes",resLenght))),
levels = c("Bu","Comb","CombWls","Mint","Bayes"))
dataPlot <- as.data.frame(relMse)
dataPlot$label <- label
dataPlot <- as.data.frame(relMse)
dim(dataPlot)
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/parseHierResults.R')
pdfname <- paste("results/GGPLOThier","_",dset,"_",fmethod,".pdf",sep = "")
denom <- subresults$mseBase
resLenght <- length(subresults$mseBase)
relMse <- rbind(matrix(subresults$mseBu/denom), matrix(subresults$mseComb/denom), matrix(subresults$mseCombWls/denom),
matrix(subresults$mseCombMint/denom), matrix(subresults$mseBayes/denom))
label <-  factor(rbind(matrix(rep("Bu",resLenght)),matrix(rep("Comb",resLenght)),matrix(rep("CombWls",resLenght)),
matrix(rep("Mint",resLenght)),matrix(rep("Bayes",resLenght))),
levels = c("Bu","Comb","CombWls","Mint","Bayes"))
dataPlot <- as.data.frame(relMse)
dataPlot$label <- label
currentPlot <- ggplot(dataPlot, aes(x = label, y = log10(relMse))) + geom_boxplot()  +
stat_boxplot(geom = "errorbar", width = 0.5) +  #draw the whiskers
scale_x_discrete(name = "") +
scale_y_continuous(name = "Log10 (MSE / MSE base) ")
print(currentPlot)
ggsave(pdfname, width = 4, height = 3)
parseHierResults()
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/parseHierResults.R')
parseHierResults()
dset="tourism"
h=4
fmethod="ets"
library(hts)
source("loadTourism.R")
if (is.character(dset) == FALSE) {
stop ("dset should be a string")
}
#The buReconcile function computes the bu prediction given the predictions (1 x tot time series) and the S matrix
#(tot time series X bottom time series)
#predsAllTs is a flag: is set to true, the input preds contains predictions for all the hierarchy
#and the function retrieves the bottom series; if set to false, this is not needed
#as preds only contains only bottom time series
buReconcile <- function (preds,S, predsAllTs = FALSE) {
bottomPreds <- preds
if (predsAllTs) {
#retrieves the bottom prediction from all predictions
upperIdx <- 1 : (nrow(S) - ncol(S))
bottomIdx <- setdiff (1:nrow(S), upperIdx)
bottomPreds <- preds [,bottomIdx]
}
buPreds <- preds
#nrow(S) is the total number of time series
for (i in 1:nrow(S)){
buPreds[i] <- S[i,] %*% bottomPreds
}
return (buPreds)
}
hierMae <- function (htsPred, htsActual) {
#receives two hts objects, containing  forecast and actual value.
#computes the mae for the relevant forecast horizon only
#Sets correctly the columns names currently not possible
maeHts <- abs (allts(htsPred) - allts(htsActual))[h,]
# colnames(maeHts) <- colnames(allts(htsPred))
return (maeHts)
}
hierMse <- function (htsPred, htsActual) {
#receives two hts objects, containing  forecast and actual value.
#computes the mse for the whole hierarchy.
mse <- mean  ( ((allts(htsPred) - allts(htsActual))[h,])^2 )
return (mse)
}
#extract the time from the data set to then split into train / test (test set contains 25 or 5 time points)
set.seed(seed = 0)
if (dset=="tourism"){
hierTs <- loadTourism()
}
hierTs <- loadTourism()
testSize <- 25
if (length(hierTs$bts[,1]) < 25){
testSize <- 5
}
#if h=1, the possible preds are the whole test size lenght;
#if h=2, the possible preds are the (test size lenght -1); etc.
possiblePreds <- testSize - h + 1
totTs       <- nrow(smatrix(hierTs))
maeBase     <- matrix(nrow = possiblePreds, ncol = totTs)
maeBu       <- matrix(nrow = possiblePreds, ncol = totTs)
maeComb     <- matrix(nrow = possiblePreds, ncol = totTs)
maeCombWls  <- matrix(nrow = possiblePreds, ncol = totTs)
maeCombMint <- matrix(nrow = possiblePreds, ncol = totTs)
maeBayes    <- matrix(nrow = possiblePreds, ncol = totTs)
#These vectors will contain the global mse, summed over all the time series of the hierarchy
mseBase     <- vector(length   = possiblePreds)
mseBu       <- vector(length   = possiblePreds)
mseComb     <- vector(length   = possiblePreds)
mseCombWls  <- vector(length   = possiblePreds)
mseCombMint <- vector(length   = possiblePreds)
mseBayes    <- vector(length   = possiblePreds)
elapsedBase     <- vector(length   = possiblePreds)
elapsedBu     <- vector(length   = possiblePreds)
elapsedComb     <- vector(length   = possiblePreds)
elapsedCombMint  <- vector(length   = possiblePreds)
elapsedBayes    <- vector(length   = possiblePreds)
iTest <- 2
timeIdx             <- time(hierTs$bts[,1])
endTrain            <- length(timeIdx) - h - (iTest - 1)
train               <- window(hierTs, start = timeIdx[1], end = timeIdx[endTrain] )
test                <- window(hierTs, start =timeIdx[endTrain +1], end=timeIdx[endTrain + h])
fcastBu             <- forecast(train, h = h, method = "bu", fmethod = fmethod)
#recompute predictions to be easily accessed by the Bayesian method
allTsTrain <- allts(train)
numTs <- ncol(allTsTrain)
alpha <- 0.2
sigma <- vector(length = numTs)
preds <- vector(length = numTs)
for (i in 1:numTs){
if (fmethod=="ets"){
model <- ets(ts(allTsTrain[,i]))
tmp <- forecast(model, h=h, level=1-alpha)
print(paste(as.character(i),"/",as.character(numTs)))
print(model$components)
}
else if (fmethod=="arima"){
model <- auto.arima(ts(allTsTrain[,i]))
tmp <- forecast(model, h=h, level=1-alpha)
}
preds[i] <- tmp$mean[h]
sigma[i] <- abs ( (tmp$mean[h] - tmp$upper[h])  / (qnorm(alpha / 2)) )
}
preds[379]
fcastBu
fcastBu[[301]]
fcastBu[[,301]]
fcastBu[[301,]]
fcastBu[301,]
fcastBu[,301]
fcastBu
fcastBu$bts
fcastBu$bts[,301]
fcastBu$bts[,302]
preds[length(preds)-2]
ts(allTsTrain[,302])
ts(allTsTrain[,])
dim(ts(allTsTrain))
ts(allTsTrain[,379])
ts(allTsTrain[,380])
ts(allTsTrain[,381])
ts(allTsTrain[,380])
ts(allTsTrain[,379])
allTsTrain[,379]
tmpModelGC <- ets(allTsTrain[,379])
tmpModelGC
forecast(model, h=h, level=1-alpha)
forecast(tmp, h=h, level=1-alpha)
forecast(tmpModelGC, h=h, level=1-alpha)
View(fcastBu)
dim(fcastBu$bts)
fcastBu$bts[,302]
preds
h
numTs
i<-379
model <- ets(ts(allTsTrain[,i]))
tmp <- forecast(model, h=h, level=1-alpha)
tmp
summary(ts(allTsTrain[,i]))
summary(allTsTrain[,379])
frequency(allTsTrain[,379])
ets(allTsTrain[,379])
ets(ts(allTsTrain[,i]))
ets((allTsTrain[,i]))
frequency(allTsTrain[,i])
frequency(ts(allTsTrain[,i]))
allTsTrain[,i]
ts(allTsTrain[,i])
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
dset
fcastBu$bts
for (iTest in 1:possiblePreds) {
timeIdx             <- time(hierTs$bts[,1])
endTrain            <- length(timeIdx) - h - (iTest - 1)
train               <- window(hierTs, start = timeIdx[1], end = timeIdx[endTrain] )
test                <- window(hierTs, start =timeIdx[endTrain +1], end=timeIdx[endTrain + h])
ptm <- proc.time()
fcastBu             <- forecast(train, h = h, method = "bu", fmethod = fmethod)
elapsedBu[iTest] <- (proc.time() - ptm)["elapsed"]
ptm <- proc.time()
fcastComb           <- forecast(train, h = h, method = "comb", weights="ols", fmethod=fmethod)
elapsedComb[iTest] <- (proc.time() - ptm)["elapsed"]
fcastCombWls        <- forecast(train, h = h, method = "comb", weights="wls", fmethod=fmethod)
ptm <- proc.time()
fcastCombMint       <- forecast(train, h = h, method = "comb", weights="mint", fmethod=fmethod)
elapsedCombMint[iTest] <- (proc.time() - ptm)["elapsed"]
mseBu[iTest]        <- hierMse(fcastBu, test )
mseComb[iTest]      <- hierMse(fcastComb, test )
mseCombWls[iTest]   <- hierMse(fcastCombWls, test )
mseCombMint[iTest]  <- hierMse(fcastCombMint, test )
#recompute predictions to be easily accessed by the Bayesian method
allTsTrain <- allts(train)
numTs <- ncol(allTsTrain)
alpha <- 0.2
sigma <- vector(length = numTs)
preds <- vector(length = numTs)
#compute, for each  ts, predictions and sigma (h-steps ahead)
ptm <- proc.time()
for (i in 1:numTs){
if (fmethod=="ets"){
model <- ets(allTsTrain[,i])
tmp <- forecast(model, h=h, level=1-alpha)
print(paste(as.character(i),"/",as.character(numTs)))
print(model$components)
}
else if (fmethod=="arima"){
model <- auto.arima(allTsTrain[,i])
tmp <- forecast(model, h=h, level=1-alpha)
}
preds[i] <- tmp$mean[h]
sigma[i] <- abs ( (tmp$mean[h] - tmp$upper[h])  / (qnorm(alpha / 2)) )
}
elapsedBase[iTest] <- (proc.time() - ptm)["elapsed"]
mseBase[iTest] =  mean  ( (allts(test)[h,] - preds)^2 )
S <- smatrix(train)
ptm <- proc.time()
#Bayesian reconciliation
bottomIdx <- seq( nrow(S) - ncol(S) +1, nrow(S))
upperIdx <- setdiff(1:nrow(S),bottomIdx)
#prior mean and covariance of the bottom time series
priorMean <- preds[bottomIdx]
#prior mean and covariance of the upper time series
Y_vec <- preds[upperIdx]
Sigma_y <- matrix(nrow = length(upperIdx), ncol = length(upperIdx))
#prior covariance for the bottom time series
bottomVar <- sigma[bottomIdx]^2
priorCov <- diag(bottomVar)
#covariance for the upper time series
upperVar <- sigma[upperIdx]^2
Sigma_y <- diag(upperVar)
#==update in a single shot
#A explains how to combin the bottom series in order to obtain the
# upper series
A <- t(S[upperIdx,])
correl <- priorCov %*% A %*%
solve (t(A) %*% priorCov %*% A + Sigma_y)
postMean <- priorMean + correl  %*%
(Y_vec - t(A) %*% priorMean)
bayesPreds <- buReconcile(postMean, S, predsAllTs = FALSE)
elapsedBayes[iTest] <- (proc.time() - ptm)["elapsed"]
mseBayes[iTest] =  mean  ( (allts(test)[h,] - bayesPreds)^2 )
}
iTest
iTest<-2
for (i in 1:numTs){
if (fmethod=="ets"){
model <- ets(allTsTrain[,i])
tmp <- forecast(model, h=h, level=1-alpha)
print(paste(as.character(i),"/",as.character(numTs)))
print(model$components)
}
else if (fmethod=="arima"){
model <- auto.arima(allTsTrain[,i])
tmp <- forecast(model, h=h, level=1-alpha)
}
preds[i] <- tmp$mean[h]
sigma[i] <- abs ( (tmp$mean[h] - tmp$upper[h])  / (qnorm(alpha / 2)) )
}
preds
fcastBu$bts
fcastBu$bts[h,]
cbind(preds fcastBu$bts[h,])
cbind(preds, fcastBu$bts[h,])
fcastBu$bts[h,]
length(fcastBu$bts[h,])
cbind(tail(preds,304), fcastBu$bts[h,])
mean(tail(preds,304)==fcastBu$bts[h,])
S <- smatrix(train)
ptm <- proc.time()
#Bayesian reconciliation
bottomIdx <- seq( nrow(S) - ncol(S) +1, nrow(S))
upperIdx <- setdiff(1:nrow(S),bottomIdx)
#prior mean and covariance of the bottom time series
priorMean <- preds[bottomIdx]
#prior mean and covariance of the upper time series
Y_vec <- preds[upperIdx]
Sigma_y <- matrix(nrow = length(upperIdx), ncol = length(upperIdx))
#prior covariance for the bottom time series
bottomVar <- sigma[bottomIdx]^2
priorCov <- diag(bottomVar)
#covariance for the upper time series
upperVar <- sigma[upperIdx]^2
Sigma_y <- diag(upperVar)
myPreds <- buReconcile(priorMean, S, predsAllTs = FALSE)
myPreds
allts(fcastBu)
allts(fcastBu)[4,]
summary(allts(fcastBu)[4,])
summary(myPreds)
library(hts)
source("loadTourism.R")
if (is.character(dset) == FALSE) {
stop ("dset should be a string")
}
#The buReconcile function computes the bu prediction given the predictions (1 x tot time series) and the S matrix
#(tot time series X bottom time series)
#predsAllTs is a flag: is set to true, the input preds contains predictions for all the hierarchy
#and the function retrieves the bottom series; if set to false, this is not needed
#as preds only contains only bottom time series
buReconcile <- function (preds,S, predsAllTs = FALSE) {
bottomPreds <- preds
if (predsAllTs) {
#retrieves the bottom prediction from all predictions
upperIdx <- 1 : (nrow(S) - ncol(S))
bottomIdx <- setdiff (1:nrow(S), upperIdx)
bottomPreds <- preds [,bottomIdx]
}
buPreds <- preds
#nrow(S) is the total number of time series
for (i in 1:nrow(S)){
buPreds[i] <- S[i,] %*% bottomPreds
}
return (buPreds)
}
hierMae <- function (htsPred, htsActual) {
#receives two hts objects, containing  forecast and actual value.
#computes the mae for the relevant forecast horizon only
#Sets correctly the columns names currently not possible
maeHts <- abs (allts(htsPred) - allts(htsActual))[h,]
# colnames(maeHts) <- colnames(allts(htsPred))
return (maeHts)
}
hierMse <- function (htsPred, htsActual) {
#receives two hts objects, containing  forecast and actual value.
#computes the mse for the whole hierarchy.
mse <- mean  ( ((allts(htsPred) - allts(htsActual))[h,])^2 )
return (mse)
}
#extract the time from the data set to then split into train / test (test set contains 25 or 5 time points)
set.seed(seed = 0)
if (dset=="tourism"){
hierTs <- loadTourism()
}
dset
testSize <- 25
if (length(hierTs$bts[,1]) < 25){
testSize <- 5
}
#if h=1, the possible preds are the whole test size lenght;
#if h=2, the possible preds are the (test size lenght -1); etc.
possiblePreds <- testSize - h + 1
totTs       <- nrow(smatrix(hierTs))
maeBase     <- matrix(nrow = possiblePreds, ncol = totTs)
maeBu       <- matrix(nrow = possiblePreds, ncol = totTs)
maeComb     <- matrix(nrow = possiblePreds, ncol = totTs)
maeCombWls  <- matrix(nrow = possiblePreds, ncol = totTs)
maeCombMint <- matrix(nrow = possiblePreds, ncol = totTs)
maeBayes    <- matrix(nrow = possiblePreds, ncol = totTs)
#These vectors will contain the global mse, summed over all the time series of the hierarchy
mseBase     <- vector(length   = possiblePreds)
mseBu       <- vector(length   = possiblePreds)
mseComb     <- vector(length   = possiblePreds)
mseCombWls  <- vector(length   = possiblePreds)
mseCombMint <- vector(length   = possiblePreds)
mseBayes    <- vector(length   = possiblePreds)
elapsedBase     <- vector(length   = possiblePreds)
elapsedBu     <- vector(length   = possiblePreds)
elapsedComb     <- vector(length   = possiblePreds)
elapsedCombMint  <- vector(length   = possiblePreds)
elapsedBayes    <- vector(length   = possiblePreds)
iTest <- 3
timeIdx             <- time(hierTs$bts[,1])
endTrain            <- length(timeIdx) - h - (iTest - 1)
train               <- window(hierTs, start = timeIdx[1], end = timeIdx[endTrain] )
test                <- window(hierTs, start =timeIdx[endTrain +1], end=timeIdx[endTrain + h])
ptm <- proc.time()
fcastBu             <- forecast(train, h = h, method = "bu", fmethod = fmethod)
elapsedBu[iTest] <- (proc.time() - ptm)["elapsed"]
ptm <- proc.time()
mseBu[iTest]        <- hierMse(fcastBu, test )
mseBu[iTest]
S <- smatrix(train)
ptm <- proc.time()
#Bayesian reconciliation
bottomIdx <- seq( nrow(S) - ncol(S) +1, nrow(S))
upperIdx <- setdiff(1:nrow(S),bottomIdx)
#prior mean and covariance of the bottom time series
priorMean <- preds[bottomIdx]
#prior mean and covariance of the upper time series
Y_vec <- preds[upperIdx]
Sigma_y <- matrix(nrow = length(upperIdx), ncol = length(upperIdx))
#prior covariance for the bottom time series
bottomVar <- sigma[bottomIdx]^2
priorCov <- diag(bottomVar)
#covariance for the upper time series
upperVar <- sigma[upperIdx]^2
Sigma_y <- diag(upperVar)
#recompute predictions to be easily accessed by the Bayesian method
allTsTrain <- allts(train)
numTs <- ncol(allTsTrain)
alpha <- 0.2
sigma <- vector(length = numTs)
preds <- vector(length = numTs)
#compute, for each  ts, predictions and sigma (h-steps ahead)
ptm <- proc.time()
for (i in 1:numTs){
if (fmethod=="ets"){
model <- ets(allTsTrain[,i])
tmp <- forecast(model, h=h, level=1-alpha)
print(paste(as.character(i),"/",as.character(numTs)))
print(model$components)
}
else if (fmethod=="arima"){
model <- auto.arima(allTsTrain[,i])
tmp <- forecast(model, h=h, level=1-alpha)
}
preds[i] <- tmp$mean[h]
sigma[i] <- abs ( (tmp$mean[h] - tmp$upper[h])  / (qnorm(alpha / 2)) )
}
mseBase[iTest] =  mean  ( (allts(test)[h,] - preds)^2 )
mseBase[iTest]
mseBu[iTest]
S <- smatrix(train)
ptm <- proc.time()
#Bayesian reconciliation
bottomIdx <- seq( nrow(S) - ncol(S) +1, nrow(S))
upperIdx <- setdiff(1:nrow(S),bottomIdx)
#prior mean and covariance of the bottom time series
priorMean <- preds[bottomIdx]
#prior mean and covariance of the upper time series
Y_vec <- preds[upperIdx]
Sigma_y <- matrix(nrow = length(upperIdx), ncol = length(upperIdx))
#prior covariance for the bottom time series
bottomVar <- sigma[bottomIdx]^2
priorCov <- diag(bottomVar)
#covariance for the upper time series
upperVar <- sigma[upperIdx]^2
Sigma_y <- diag(upperVar)
#==update in a single shot
#A explains how to combin the bottom series in order to obtain the
# upper series
A <- t(S[upperIdx,])
correl <- priorCov %*% A %*%
solve (t(A) %*% priorCov %*% A + Sigma_y)
postMean <- priorMean + correl  %*%
(Y_vec - t(A) %*% priorMean)
bayesPreds <- buReconcile(postMean, S, predsAllTs = FALSE)
elapsedBayes[iTest] <- (proc.time() - ptm)["elapsed"]
mseBayes[iTest] =  mean  ( (allts(test)[h,] - bayesPreds)^2 )
mseBayes[iTest]
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier <- ("infantgts", h=1, fmethod="ets")
hier ("infantgts", h=1, fmethod="ets")
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier("tourism")
hierMse(fcastBu, test )
hierMse(fcastComb, test )
allts(fcastBu)
dim(allts(fcastBu))
dim(allts(fcastComb))
hierMse(fcastBu, test )
allts(fcastBu) - allts(test)
allts(fcastBu) - allts(test)[h,]
(allts(fcastBu) - allts(test)[h,])^2
mean(allts(fcastBu) - allts(test)[h,])^2
hierMse(fcastBu, test )
mean  ( ((allts(fcastBu) - allts(test))[h,])^2 )
mean  ( ((allts(fcastComb) - allts(test))[h,])^2 )
dim(allts(test))[h,])
dim(allts(test))[h,]))
dim(allts(test)[h,])
dim(allts(test))[h,]
mean  ( ((allts(fcastBu) - allts(test))[h,])^2 )
( (allts(fcastBu) - allts(test))[h,])
( (allts(fcastComb) - allts(test))[h,])
dim(allts(fcastComb))
dim(allts(fcastBu))
fcastBu
scatter(allts(fcastBu),allts(fcastComb))
scatter.smooth(allts(fcastBu),allts(fcastComb))
dim(allts(fcastBu))
dim(allts(fcastComb))
cbind(allts(fcastBu),allts(fcastComb))
rbind(allts(fcastBu),allts(fcastComb))
( (allts(fcastComb) - allts(test))[h,])
allts(fcastComb) - allts(test)
allts(fcastComb) - allts(test)[h,]
allts(fcastBu) - allts(test)[h,]
mean((allts(fcastBu) - allts(test)[h,])^2)
hierMse(fcastBu, test )
hierMse <- function (htsPred, htsActual) {
#receives two hts objects, containing  forecast and actual value.
#computes the mse for the whole hierarchy.
mse <- mean  ( (allts(htsPred) - allts(htsActual)[h,])^2 )
return (mse)
}
mseBu[iTest]
hierMse(fcastBu, test )
hierMse(fcastComb, test )
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier("tourism",h=1)
mseBu
mseComb
mseCombWls
mseCombMint
mean  ( (allts(test)[h,] - preds)^2 )
