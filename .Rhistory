library(hts)
library(huge)#covariance matrix via glasso
library(SHIP)#shrinkage of covarianca matrix
source("loadTourism.R")
set.seed(seed)
#covariance can be "diagonal", "sam" or "glasso"
bayesRecon <- function (covariance){
S <- smatrix(train)
bottomIdx <- seq( nrow(S) - ncol(S) +1, nrow(S))
upperIdx <- setdiff(1:nrow(S),bottomIdx)
#prior mean and covariance of the bottom time series
priorMean <- preds[bottomIdx]
Y_vec <- preds[upperIdx]
#prior covariance for the bottom time series
bottomVar <- sigma[bottomIdx]^2
bottomResiduals <- residuals[,bottomIdx]
if (covariance=="diagonal"){
priorCov <- diag(bottomVar)
}
else if (covariance=="sam"){
#the covariances are the covariances of the time series
#the variances are the variances of the forecasts, hence the variances of the residuals
priorCov <- cov(bottomResiduals)
}
else if (covariance=="glasso"){
#the covariances are the covariances of the time series
#the variances are the variances of the forecasts, hence the variances of the residuals
out.glasso <- huge(bottomResiduals, method = "glasso", cov.output = TRUE)
out.select <- huge.select(out.glasso, criterion = "ebic")
priorCov <- out.select$opt.cov
}
else if (covariance=="shr"){
sigmaDiag <- diag(bottomVar)
priorCov <-  shrink.estim(bottomResiduals, tar=build.target(bottomResiduals,type="D"))[[1]]
}
upperVar <- sigma[upperIdx]^2
#covariance for the upper time series; we need managing separately the case where only a single time series is present
#as diag will try to create a matrix of size upperVar instead.
upperResiduals <- residuals[,upperIdx]
if (length(upperIdx)==1) {
Sigma_y <- upperVar
}
else if (covariance=="diagonal"){
Sigma_y <- diag(upperVar)
}
#if we only one upper time series, there is no covariance matrix to be estimated.
else if (covariance=="glasso") {
#get variance and covariance of the residuals
out.glasso <- huge(upperResiduals, method = "glasso", cov.output = TRUE)
out.select <- huge.select(out.glasso, criterion = "ebic")
Sigma_y <- out.select$opt.cov
}
else if (covariance=="sam") {
#get variance and covariance of the residuals
Sigma_y <- cov(upperResiduals)
}
else if (covariance=="shr") {
sigma_y_diag <- diag(upperVar)
Sigma_y <-  shrink.estim(upperResiduals, tar=build.target(upperResiduals,type="D"))[[1]]
}
#==updating
#A explains how to combin the bottom series in order to obtain the
# upper series
#if upperIdx contains a single row, R behaves oddily; hence we need to manually manage that case.
if (length(upperIdx)==1){
A <- cbind(S[upperIdx,])
}
else {
A <- t(S[upperIdx,])
}
M <- ncol ( t(A) %*% priorCov %*% A + Sigma_y )
correl <- priorCov %*% A %*%
solve (t(A) %*% priorCov %*% A + Sigma_y + 1e-6*diag(M))
postMean <- priorMean + correl  %*%
(Y_vec - t(A) %*% priorMean)
bayesPreds <- buReconcile(postMean, S, predsAllTs = FALSE)
return(bayesPreds)
}
for (h in (seq(1:maxH))){
for (i in 1:numTs){
model <- auto.arima(allTsTrain[,i])
tmp <- forecast(model, h=h, level=1-alpha)
residuals[,i] <- model$residuals
preds[i] <- tmp$mean[h]
}
mseBase =  mean  ( (allts(test)[h,] - preds)^2 )
reconcBayes[h,] <- bayesRecon(covariance="shr")
mseBayesShr =  mean   (allts(test)[h,] - reconcBayes[h,])^2
base[h,] <- preds
actual <- allts(test)
}
bottomIdx <- 1
actual <- hierTs$bts[,bottomIdx]
base   <- ts(base[,3+bottomIdx], start=timeIdx[endTrain +1])
reconc <- ts(reconcBayes[,3+bottomIdx], start=timeIdx[endTrain +1])
p <- forecast::autoplot(actual, size = 0.5) + autolayer(base, size = 1)   + autolayer(reconc, size = 1)
p
train
forecast(train, h = h, method = "comb", weights="mint", fmethod=fmethod,
covariance="shr")
fmint <- matrix(nrow=dim(allTsTrain)[1], ncol = numTs)
base <- matrix(ncol=numTs, nrow=maxH)
reconcBayes <- matrix(ncol=numTs, nrow=maxH)
for (h in (seq(1:maxH))){
for (i in 1:numTs){
model <- auto.arima(allTsTrain[,i])
tmp <- forecast(model, h=h, level=1-alpha)
residuals[,i] <- model$residuals
preds[i] <- tmp$mean[h]
}
mseBase =  mean  ( (allts(test)[h,] - preds)^2 )
reconcBayes[h,] <- bayesRecon(covariance="shr")
mseBayesShr =  mean   (allts(test)[h,] - reconcBayes[h,])^2
base[h,] <- preds
actual <- allts(test)
fmint[h,] <-
forecast(train, h = h, method = "comb", weights="mint", fmethod=fmethod,
covariance="shr")
}
fitted <- matrix(nrow=dim(allTsTrain)[1], ncol = numTs)
actual <- matrix(nrow=dim(allTsTrain)[1], ncol = numTs)
fmint <- matrix(nrow=dim(allTsTrain)[1], ncol = numTs)
forecast(train, h = h, method = "comb", weights="mint", fmethod=fmethod,
covariance="shr")
a <-  forecast(train, h = h, method = "comb", weights="mint", fmethod=fmethod,
covariance="shr")
class(a)
allts(a)
for (h in (seq(1:maxH))){
for (i in 1:numTs){
model <- auto.arima(allTsTrain[,i])
tmp <- forecast(model, h=h, level=1-alpha)
residuals[,i] <- model$residuals
preds[i] <- tmp$mean[h]
}
mseBase =  mean  ( (allts(test)[h,] - preds)^2 )
reconcBayes[h,] <- bayesRecon(covariance="shr")
mseBayesShr =  mean   (allts(test)[h,] - reconcBayes[h,])^2
base[h,] <- preds
actual <- allts(test)
fmint[h,] <-
allts(forecast(train, h = h, method = "comb", weights="mint", fmethod=fmethod,
covariance="shr"))
}
allts(forecast(train, h = h, method = "comb", weights="mint", fmethod=fmethod,
covariance="shr"))
h
base <- matrix(ncol=numTs, nrow=maxH)
reconcBayes <- matrix(ncol=numTs, nrow=maxH)
for (h in (seq(1:maxH))){
for (i in 1:numTs){
model <- auto.arima(allTsTrain[,i])
tmp <- forecast(model, h=h, level=1-alpha)
residuals[,i] <- model$residuals
preds[i] <- tmp$mean[h]
}
mseBase =  mean  ( (allts(test)[h,] - preds)^2 )
reconcBayes[h,] <- bayesRecon(covariance="shr")
mseBayesShr =  mean   (allts(test)[h,] - reconcBayes[h,])^2
base[h,] <- preds
actual <- allts(test)
fmint[h,] <-
allts(forecast(train, h = h, method = "comb", weights="mint", fmethod=fmethod,
covariance="shr"))[h,]
}
mseMint <-  mean   (allts(test)[h,] - fmint[h,])^2
mseMint
mseBayesShr
p <- forecast::autoplot(actual, size = 0.5) + autolayer(base, size = 1)
p <- forecast::autoplot(actual, size = 0.5) + autolayer(base, size = 1) + autolayer(reconc, size = 1)  + autolayer(fmint, size = 1)
fmint <- ts(fmint[,3+bottomIdx], start=timeIdx[endTrain +1])
p <- forecast::autoplot(actual, size = 0.5) + autolayer(base, size = 1) + autolayer(reconc, size = 1)  + autolayer(fmint, size = 1)
actual <- hierTs$bts[,bottomIdx]
base   <- ts(base[,3+bottomIdx], start=timeIdx[endTrain +1])
reconc <- ts(reconcBayes[,3+bottomIdx], start=timeIdx[endTrain +1])
fmint <- ts(fmint[,3+bottomIdx], start=timeIdx[endTrain +1])
fmint
p <- autoplot(actual, size = 0.5) + autolayer(base, size = 1) + autolayer(reconc, size = 1)  + autolayer(fmint, size = 1)
p <- autoplot(actual, size = 0.5) + autolayer(base, size = 1) + autolayer(reconc, size = 1) #  + autolayer(fmint, size = 1)
autoplot(actual, size = 0.5)
autoplot(actual, size = 0.5) + autolayer(base, size = 1)
base   <- ts(base[,3+bottomIdx], start=timeIdx[endTrain +1])
base
base   <- ts(base[,3+bottomIdx], start=timeIdx[endTrain +1])
base
p <- autoplot(actual, size = 0.5) + autolayer(base, size = 1) + autolayer(reconc, size = 1) #  + autolayer(fmint, size = 1)
base
actual
actual <- hierTs$bts[,bottomIdx]
base   <- ts(base[,3+bottomIdx], start=timeIdx[endTrain +1])
#recompute predictions to be  accessed by the Bayesian method
allTsTrain <- allts(train)
numTs <- ncol(allTsTrain)
alpha <- 0.2
sigma <- vector(length = numTs)
preds <- vector(length = numTs)
#the residuals for the model fitted on each time series
residuals <- matrix(nrow=dim(allTsTrain)[1], ncol = numTs)
fitted <- matrix(nrow=dim(allTsTrain)[1], ncol = numTs)
actual <- matrix(nrow=dim(allTsTrain)[1], ncol = numTs)
fmint <- matrix(nrow=dim(allTsTrain)[1], ncol = numTs)
base <- matrix(ncol=numTs, nrow=maxH)
reconcBayes <- matrix(ncol=numTs, nrow=maxH)
for (h in (seq(1:maxH))){
for (i in 1:numTs){
model <- auto.arima(allTsTrain[,i])
tmp <- forecast(model, h=h, level=1-alpha)
residuals[,i] <- model$residuals
preds[i] <- tmp$mean[h]
}
mseBase =  mean  ( (allts(test)[h,] - preds)^2 )
reconcBayes[h,] <- bayesRecon(covariance="shr")
mseBayesShr =  mean   (allts(test)[h,] - reconcBayes[h,])^2
base[h,] <- preds
actual <- allts(test)
fmint[h,] <-
allts(forecast(train, h = h, method = "comb", weights="mint", fmethod=fmethod,
covariance="shr"))[h,]
mseMint <-  mean   (allts(test)[h,] - fmint[h,])^2
}
bottomIdx <- 1
actual <- hierTs$bts[,bottomIdx]
base   <- ts(base[,3+bottomIdx], start=timeIdx[endTrain +1])
reconc <- ts(reconcBayes[,3+bottomIdx], start=timeIdx[endTrain +1])
fmint <- ts(fmint[,3+bottomIdx], start=timeIdx[endTrain +1])
p <- autoplot(actual, size = 0.5) + autolayer(base, size = 1) + autolayer(reconc, size = 1) #  + autolayer(fmint, size = 1)
p
p <- autoplot(actual, size = 0.5) + autolayer(base, size = 1) + autolayer(reconc, size = 1)   + autolayer(fmint, size = 1)
p
p <- autoplot(actual, size = 0.5) + autolayer(base, size = 1) + autolayer(Bayes, size = 1)   + autolayer(fmint, size = 1)
p
set.seed(seed)
source("drawLargeHierarchy.R")
fmethod <- "arima"
synth_n <- 20
#we generate the hierarchy with *four* bottom time series
synthTs <- simulFourBottom(n=synth_n)
y=ts(synthTs, frequency = 1)
hierTs <- hts(y, bnames = colnames(y), characters=c(1,1))
maxH = 4
iTest <- 1
timeIdx <- time(hierTs$bts[,1])
startTrain          <- timeIdx[1]
endTrain            <- length(timeIdx) - maxH - (iTest - 1)
train               <- window(hierTs, start = startTrain, end = timeIdx[endTrain] )
test                <- window(hierTs, start =timeIdx[endTrain +1], end=timeIdx[endTrain +   maxH])
#recompute predictions to be  accessed by the Bayesian method
allTsTrain <- allts(train)
numTs <- ncol(allTsTrain)
alpha <- 0.2
sigma <- vector(length = numTs)
preds <- vector(length = numTs)
#the residuals for the model fitted on each time series
residuals <- matrix(nrow=dim(allTsTrain)[1], ncol = numTs)
fitted <- matrix(nrow=dim(allTsTrain)[1], ncol = numTs)
actual <- matrix(nrow=dim(allTsTrain)[1], ncol = numTs)
fmint <- matrix(nrow=dim(allTsTrain)[1], ncol = numTs)
base <- matrix(ncol=numTs, nrow=maxH)
reconcBayes <- matrix(ncol=numTs, nrow=maxH)
for (h in (seq(1:maxH))){
for (i in 1:numTs){
model <- auto.arima(allTsTrain[,i])
tmp <- forecast(model, h=h, level=1-alpha)
residuals[,i] <- model$residuals
preds[i] <- tmp$mean[h]
}
mseBase =  mean  ( (allts(test)[h,] - preds)^2 )
reconcBayes[h,] <- bayesRecon(covariance="shr")
mseBayesShr =  mean   (allts(test)[h,] - reconcBayes[h,])^2
base[h,] <- preds
actual <- allts(test)
fmint[h,] <-
allts(forecast(train, h = h, method = "comb", weights="mint", fmethod=fmethod,
covariance="shr"))[h,]
mseMint <-  mean   (allts(test)[h,] - fmint[h,])^2
}
bottomIdx <- 1
y <- hierTs$bts[,bottomIdx]
base   <- ts(base[,3+bottomIdx], start=timeIdx[endTrain +1])
reconc <- ts(reconcBayes[,3+bottomIdx], start=timeIdx[endTrain +1])
fmint <- ts(fmint[,3+bottomIdx], start=timeIdx[endTrain +1])
p <- autoplot(y, size = 0.5) + autolayer(base, size = 1) + autolayer(Bayes, size = 1)   + autolayer(fmint, size = 1)
bayes <- ts(reconcBayes[,3+bottomIdx], start=timeIdx[endTrain +1])
fmint <- ts(fmint[,3+bottomIdx], start=timeIdx[endTrain +1])
#recompute predictions to be  accessed by the Bayesian method
allTsTrain <- allts(train)
numTs <- ncol(allTsTrain)
alpha <- 0.2
sigma <- vector(length = numTs)
preds <- vector(length = numTs)
#the residuals for the model fitted on each time series
residuals <- matrix(nrow=dim(allTsTrain)[1], ncol = numTs)
fitted <- matrix(nrow=dim(allTsTrain)[1], ncol = numTs)
actual <- matrix(nrow=dim(allTsTrain)[1], ncol = numTs)
fmint <- matrix(nrow=dim(allTsTrain)[1], ncol = numTs)
#recompute predictions to be  accessed by the Bayesian method
allTsTrain <- allts(train)
numTs <- ncol(allTsTrain)
alpha <- 0.2
sigma <- vector(length = numTs)
preds <- vector(length = numTs)
#the residuals for the model fitted on each time series
residuals <- matrix(nrow=dim(allTsTrain)[1], ncol = numTs)
fitted <- matrix(nrow=dim(allTsTrain)[1], ncol = numTs)
actual <- matrix(nrow=dim(allTsTrain)[1], ncol = numTs)
fmint <- matrix(nrow=dim(allTsTrain)[1], ncol = numTs)
base <- matrix(ncol=numTs, nrow=maxH)
reconcBayes <- matrix(ncol=numTs, nrow=maxH)
for (h in (seq(1:maxH))){
for (i in 1:numTs){
model <- auto.arima(allTsTrain[,i])
tmp <- forecast(model, h=h, level=1-alpha)
residuals[,i] <- model$residuals
preds[i] <- tmp$mean[h]
}
mseBase =  mean  ( (allts(test)[h,] - preds)^2 )
reconcBayes[h,] <- bayesRecon(covariance="shr")
mseBayesShr =  mean   (allts(test)[h,] - reconcBayes[h,])^2
base[h,] <- preds
actual <- allts(test)
fmint[h,] <-
allts(forecast(train, h = h, method = "comb", weights="mint", fmethod=fmethod,
covariance="shr"))[h,]
mseMint <-  mean   (allts(test)[h,] - fmint[h,])^2
}
bottomIdx <- 1
y <- hierTs$bts[,bottomIdx]
base   <- ts(base[,3+bottomIdx], start=timeIdx[endTrain +1])
bayes <- ts(reconcBayes[,3+bottomIdx], start=timeIdx[endTrain +1])
fmint <- ts(fmint[,3+bottomIdx], start=timeIdx[endTrain +1])
p <- autoplot(y, size = 0.5) + autolayer(base, size = 1) + autolayer(Bayes, size = 1)   + autolayer(fmint, size = 1)
p <- autoplot(y, size = 0.5) + autolayer(base, size = 1) + autolayer(bayes, size = 1)   + autolayer(fmint, size = 1)
p
train
train$bts
nrow(train$bts)
ncol(train$bts)
p <- autoplot(y, size = 0.5, xlim=nrow(train$bts)) + autolayer(base, size = 1) + autolayer(bayes, size = 1)   + autolayer(fmint, size = 1)
nrow(train$bts)
p <- autoplot(y, size = 0.5) + xlim=c(1,nrow(train$bts)) + autolayer(base, size = 1) + autolayer(bayes, size = 1)   + autolayer(fmint, size = 1)
p <- autoplot(y, size = 0.5) + xlim(c(1,nrow(train$bts)) + autolayer(base, size = 1) + autolayer(bayes, size = 1)   + autolayer(fmint, size = 1)
p
#create a 2 by 2 figure
#the last 4 ts are the useful ones
# for (idx in (seq(4:8))){
#   autoplot(actual[,idx])
# }
pdf("rplot.pdf")
}
p <- autoplot(y, size = 0.5) + xlim(c(1,nrow(train$bts))) + autolayer(base, size = 1) + autolayer(bayes, size = 1)   + autolayer(fmint, size = 1)
p
p <- autoplot(y, size = 0.5, xlim=c(1,nrow(train$bts))) + autolayer(base, size = 1) + autolayer(bayes, size = 1)   + autolayer(fmint, size = 1)
p
p <- autoplot(y, size = 0.5, xlim=c(1,nrow(train$bts))) + autolayer(base, size = 1) + autolayer(bayes, size = 1)   + autolayer(fmint, size = 1)
p
nrow(train$bts)
synthTs
synthTs$bts
synthTs
nrow(synthTs)
p <- autoplot(y, size = 0.5, xlim=c(1,nrow(synthTs)))
#+ autolayer(base, size = 1) + autolayer(bayes, size = 1)   + autolayer(fmint, size = 1)
p
dev.off()
p <- autoplot(y, size = 0.5, xlim=c(1,nrow(synthTs)))
#+ autolayer(base, size = 1) + autolayer(bayes, size = 1)   + autolayer(fmint, size = 1)
p
p <- autoplot(y, size = 0.5, xlim=c(1,nrow(synthTs))) + autolayer(base, size = 1) + autolayer(bayes, size = 1)   + autolayer(fmint, size = 1)
p
p <- autoplot(y, size = 0.5, xlim=c(1,nrow(synthTs))) + autolayer(base, size = 1) + autolayer(bayes, size = 1, xlim=c(1,nrow(synthTs)))   + autolayer(fmint, size = 1,xlim=c(1,nrow(synthTs)))
p
p <- autoplot(y, size = 0.5, xlim=c(1,nrow(synthTs)))+ autolayer(base, size = 1) + autolayer(bayes, size = 1)   + autolayer(fmint, size = 1)
p
?pdf
y <- hierTs$bts[,bottomIdx]
base   <- ts(base[,3+bottomIdx], start=timeIdx[endTrain +1])
debugSource('~/switchDrive/paperReconc/hierTsCode/figureFcast.R')
#create figure of forecasts for the paper
source("hierRec.R")
library(hts)
library(SHIP)
set.seed(seed)
source("drawLargeHierarchy.R")
fmethod <- "arima"
synth_n <- 20
#we generate the hierarchy with *four* bottom time series
synthTs <- simulFourBottom(n=synth_n)
y=ts(synthTs, frequency = 1)
hierTs <- hts(y, bnames = colnames(y), characters=c(1,1))
maxH = 4
iTest <- 1
timeIdx <- time(hierTs$bts[,1])
startTrain          <- timeIdx[1]
endTrain            <- length(timeIdx) - maxH - (iTest - 1)
train               <- window(hierTs, start = startTrain, end = timeIdx[endTrain] )
test                <- window(hierTs, start =timeIdx[endTrain +1], end=timeIdx[endTrain +   maxH])
#recompute predictions to be  accessed by the Bayesian method
allTsTrain <- allts(train)
numTs <- ncol(allTsTrain)
alpha <- 0.2
sigma <- vector(length = numTs)
preds <- vector(length = numTs)
#the residuals for the model fitted on each time series
residuals <- matrix(nrow=dim(allTsTrain)[1], ncol = numTs)
fitted <- matrix(nrow=dim(allTsTrain)[1], ncol = numTs)
actual <- matrix(nrow=dim(allTsTrain)[1], ncol = numTs)
fmint <- matrix(nrow=dim(allTsTrain)[1], ncol = numTs)
base <- matrix(ncol=numTs, nrow=maxH)
reconcBayes <- matrix(ncol=numTs, nrow=maxH)
for (h in (seq(1:maxH))){
for (i in 1:numTs){
model <- auto.arima(allTsTrain[,i])
tmp <- forecast(model, h=h, level=1-alpha)
residuals[,i] <- model$residuals
preds[i] <- tmp$mean[h]
}
mseBase =  mean  ( (allts(test)[h,] - preds)^2 )
reconcBayes[h,] <- bayesRecon(covariance="shr")
mseBayesShr =  mean   (allts(test)[h,] - reconcBayes[h,])^2
base[h,] <- preds
actual <- allts(test)
fmint[h,] <-
allts(forecast(train, h = h, method = "comb", weights="mint", fmethod=fmethod,
covariance="shr"))[h,]
mseMint <-  mean   (allts(test)[h,] - fmint[h,])^2
}
bottomIdx <- 1
y <- hierTs$bts[,bottomIdx]
base   <- ts(base[,3+bottomIdx], start=timeIdx[endTrain +1])
bayes <- ts(reconcBayes[,3+bottomIdx], start=timeIdx[endTrain +1])
fmint <- ts(fmint[,3+bottomIdx], start=timeIdx[endTrain +1])
autoplot(y, size = 0.5, xlim=c(1,nrow(synthTs)))+ autolayer(base, size = 1) + autolayer(bayes, size = 1)   + autolayer(fmint, size = 1)
#create a 2 by 2 figure
#the last 4 ts are the useful ones
# for (idx in (seq(4:8))){
#   autoplot(actual[,idx])
# }
pdf("rplot.pdf", width = 4, height = 3)
ggsave("rplot.pdf", width = 4, height = 3)
autoplot(y, size = 0.5, xlim=c(1,nrow(synthTs)))+ autolayer(base, size = 1) + autolayer(bayes, size = 1)   + autolayer(fmint, size = 1)
#create a 2 by 2 figure
#the last 4 ts are the useful ones
# for (idx in (seq(4:8))){
#   autoplot(actual[,idx])
# }
pdf("rplot.pdf", width = 4, height = 3)
y <- hierTs$bts[,bottomIdx]
base   <- ts(base[,3+bottomIdx], start=timeIdx[endTrain +1])
function (generic = NULL, object = NULL, ...)
autoplot(y, size = 0.5, xlim=c(1,nrow(synthTs)))+ autolayer(base, size = 1) + autolayer(bayes, size = 1)   + autolayer(fmint, size = 1)
#create figure of forecasts for the paper
source("hierRec.R")
library(hts)
library(SHIP)
set.seed(seed)
source("drawLargeHierarchy.R")
fmethod <- "arima"
synth_n <- 20
#we generate the hierarchy with *four* bottom time series
synthTs <- simulFourBottom(n=synth_n)
y=ts(synthTs, frequency = 1)
hierTs <- hts(y, bnames = colnames(y), characters=c(1,1))
maxH = 4
iTest <- 1
timeIdx <- time(hierTs$bts[,1])
startTrain          <- timeIdx[1]
endTrain            <- length(timeIdx) - maxH - (iTest - 1)
train               <- window(hierTs, start = startTrain, end = timeIdx[endTrain] )
test                <- window(hierTs, start =timeIdx[endTrain +1], end=timeIdx[endTrain +   maxH])
#recompute predictions to be  accessed by the Bayesian method
allTsTrain <- allts(train)
numTs <- ncol(allTsTrain)
alpha <- 0.2
sigma <- vector(length = numTs)
preds <- vector(length = numTs)
#the residuals for the model fitted on each time series
residuals <- matrix(nrow=dim(allTsTrain)[1], ncol = numTs)
fitted <- matrix(nrow=dim(allTsTrain)[1], ncol = numTs)
actual <- matrix(nrow=dim(allTsTrain)[1], ncol = numTs)
fmint <- matrix(nrow=dim(allTsTrain)[1], ncol = numTs)
base <- matrix(ncol=numTs, nrow=maxH)
reconcBayes <- matrix(ncol=numTs, nrow=maxH)
for (h in (seq(1:maxH))){
for (i in 1:numTs){
model <- auto.arima(allTsTrain[,i])
tmp <- forecast(model, h=h, level=1-alpha)
residuals[,i] <- model$residuals
preds[i] <- tmp$mean[h]
}
mseBase =  mean  ( (allts(test)[h,] - preds)^2 )
reconcBayes[h,] <- bayesRecon(covariance="shr")
mseBayesShr =  mean   (allts(test)[h,] - reconcBayes[h,])^2
base[h,] <- preds
actual <- allts(test)
fmint[h,] <-
allts(forecast(train, h = h, method = "comb", weights="mint", fmethod=fmethod,
covariance="shr"))[h,]
mseMint <-  mean   (allts(test)[h,] - fmint[h,])^2
}
bottomIdx <- 1
y <- hierTs$bts[,bottomIdx]
base   <- ts(base[,3+bottomIdx], start=timeIdx[endTrain +1])
bayes <- ts(reconcBayes[,3+bottomIdx], start=timeIdx[endTrain +1])
fmint <- ts(fmint[,3+bottomIdx], start=timeIdx[endTrain +1])
autoplot(y, size = 0.5, xlim=c(1,nrow(synthTs)))+ autolayer(base, size = 1) + autolayer(bayes, size = 1)   + autolayer(fmint, size = 1)
#create a 2 by 2 figure
#the last 4 ts are the useful ones
# for (idx in (seq(4:8))){
#   autoplot(actual[,idx])
# }
pdf("rplot.pdf", width = 4, height = 3)
ggsave("rplot.pdf", width = 4, height = 3)
