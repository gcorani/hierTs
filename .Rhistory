frequency(ts)
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
usdeaths
time(usdeaths)
plot(time(usdeaths))
length(usdeaths)
usdeaths[1:60]
usdeaths[,1:60]
#predict one full season ahead (12 months or 4 quarters etc)
endTrain <- length(usdeaths) - frequency(ts)
library(fpp2)
library(hts)
source("hier.R")
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
#only for debugging purposes
ts <- usdeaths
#predict one full season ahead (12 months or 4 quarters etc)
timeIdx <- time(ts)
endTrain <- length(timeIdx) - frequency(ts)
train <- window(ts, start = timeIdx[1], end = timeIdx[endTrain] )
train
usdeaths
test <- window(ts, start =timeIdx[endTrain +1])
test
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
trainTs <- tsaggregates(train)
trainTs
testTs <- tsaggregates(test)
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
library(fpp2)
library(hts)
source("hier.R")
#only for debugging purposes
ts <- usdeaths
#predict one full season ahead (12 months or 4 quarters etc)
timeIdx <- time(ts)
endTrain <- length(timeIdx) - frequency(ts)
train <- window(ts, start = timeIdx[1], end = timeIdx[endTrain] )
test <- window(ts, start =timeIdx[endTrain +1])
trainTs <- tsaggregates(train)
testTs <- tsaggregates(test)
testSize <- 25
if (length(hierTs$bts[,1]) < 25){
testSize <- 5
}
#if h=1, the possible preds are the whole test size lenght;
#if h=2, the possible preds are the (test size lenght -1); etc.
possiblePreds <- testSize - h + 1
totTs <- nrow(smatrix(hierTs))
maeBu <- matrix(nrow = possiblePreds, ncol = totTs)
function (el, set)
match(el, set, 0L) > 0L
train <- window(ts, start = timeIdx[1], end = timeIdx[endTrain] )
test <- window(ts, start =timeIdx[endTrain +1])
#predict one full season ahead (12 months or 4 quarters etc)
timeIdx <- time(ts)
endTrain <- length(timeIdx) - frequency(ts)
train <- window(ts, start = timeIdx[1], end = timeIdx[endTrain] )
test <- window(ts, start =timeIdx[endTrain +1])
trainTs <- tsaggregates(train)
testTs <- tsaggregates(test)
library(fpp2)
library(hts)
source("hier.R")
#only for debugging purposes
ts <- usdeaths
#predict one full season ahead (12 months or 4 quarters etc)
timeIdx <- time(ts)
endTrain <- length(timeIdx) - frequency(ts)
train <- window(ts, start = timeIdx[1], end = timeIdx[endTrain] )
test <- window(ts, start =timeIdx[endTrain +1])
trainTs <- tsaggregates(train)
library(thief)
trainTs <- tsaggregates(train)
testTs <- tsaggregates(test)
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
?tsaggregates
trainTs
# Compute forecasts
fc <- list()
# Compute forecasts
fc <- list()
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
?reconcilethief
# Compute forecasts one full season ahead
fc <- list()
for(i in seq_along(trainTs)){
if (fmethod == "ets") {
fc[[i]] <- forecast(ets(aggts[[i]]), h=frequency(aggts[[i]]))
}
else if (fmethod == "arima") {
fc[[i]] <- forecast(auto.arima(aggts[[i]]), h=2*frequency(aggts[[i]]))
}
fmethod = "ets"
for(i in seq_along(trainTs)){
if (fmethod == "ets") {
fc[[i]] <- forecast(ets(aggts[[i]]), h=frequency(aggts[[i]]))
}
else if (fmethod == "arima") {
fc[[i]] <- forecast(auto.arima(aggts[[i]]), h=2*frequency(aggts[[i]]))
}
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
# Compute forecasts one full season ahead
fc <- list()
# Compute forecasts one full season ahead
fc <- list()
for(i in seq_along(trainTs)){
if (fmethod == "ets") {
fc[[i]] <- forecast(ets(trainTs[[i]]), h=frequency(trainTs[[i]]))
}
else if (fmethod == "arima") {
fc[[i]] <- forecast(auto.arima(aggts[[i]]), h=2*frequency(aggts[[i]]))
}
fc
qnorm(.1)
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
?forecast
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
# Compute forecasts one full season ahead
fc <- list()
for(i in seq_along(trainTs)){
if (fmethod == "ets") {
fc[[i]] <- forecast(ets(trainTs[[i]]), h=frequency(trainTs[[i]]), level = (1-alpha))
}
else if (fmethod == "arima") {
fc[[i]] <- forecast(auto.arima(aggts[[i]]), h=2*frequency(aggts[[i]]))
}
#coverage of the PI is 0.8
alpha <- 0.2
# Compute forecasts one full season ahead
fc <- list()
for(i in seq_along(trainTs)){
if (fmethod == "ets") {
fc[[i]] <- forecast(ets(trainTs[[i]]), h=frequency(trainTs[[i]]), level = (1-alpha))
}
else if (fmethod == "arima") {
fc[[i]] <- forecast(auto.arima(aggts[[i]]), h=2*frequency(aggts[[i]]))
}
alpha
#coverage of the PI is 0.8
alpha <- 0.2
# Compute forecasts one full season ahead
fc <- list()
for(i in seq_along(trainTs)){
if (fmethod == "ets") {
fc[[i]] <- forecast(ets(trainTs[[i]]), h=frequency(trainTs[[i]]), level = (1-alpha))
}
else if (fmethod == "arima") {
fc[[i]] <- forecast(auto.arima(aggts[[i]]), h=2*frequency(aggts[[i]]))
}
fc[[1]]
# Reconcile forecasts
reconciledTh <- reconcilethief(fc)
reconciledTh
reconciledTh - testTs
reconciledTh[[1]]
testTs
testTs[[1]]
testTs[[2]]
testTs[[3]]
testTs[[4]]
testTs[[5]]
reconciledTh[[1]]
class(reconciledTh[[1]])
colnames(reconciledTh[[1]])
reconciledTh[[1]]$mean
?reconcilethief
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
# Reconcile forecasts
thiefReconc <- reconcilethief(fc, comb = "struc")
buReconc <- reconcilethief(fc, comb = "bu")
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
class(fc)
length(fc)
names(fc)
fc
class(trainTs)
trainTs
trainTs[[1]]
trainTs[[2]]
trainTs[[3]]
trainTs[[4]]
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
length(fc)
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
fc[[1]]
fc[[1]]$mean - testTs
testTs
testTs$Annual
testTs$`2-Monthly`
testTs[[1]]
testTs[[2]]
testTs[[3]]
testTs[[5]]
testTs[[4]]
testTs[[5]]
testTs[[6]]
trainTs[[1]]
fc[[1]]
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
fc[[1]]$mean
fc[[1]]$mean - testTs[[1]]
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
i <- 1
hierMae[i] <- fc[[i]]$mean - testTs[[i]]
hierMae <- vector(length = length(forecast))
hierMae[i] <- fc[[i]]$mean - testTs[[i]]
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
hierMae[i] <- mean( abs (fc[[i]]$mean - testTs[[i]]) )
hierMae
testTs[[i]])
testTs[[i]]
class(testTs[[i]])
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
testTs
class(testTs)
class(testTs
)
testTs[[1]]
testTs$Monthly
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
trainTs
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
#now reconcile using the Bayesian approach
sigma <- vector(length = numTs)
numTs <- length(trainTs) #trainTs is a list, one ts for each temporal aggregation
#now reconcile using the Bayesian approach
sigma <- vector(length = numTs)
preds <- vector(length = numTs)
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
trainTs[[1]]
class(trainTs[[1]])
frequency(trainTs[[1]])
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
#how many predictions we manage within the hierarchy
numTs <- 0
for (i in seq_along(trainTs) ){
numTs <- numTs + frequency(trainTs[[i]])
}
numTs
12 + 6 + 4 +3 +2 +1
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
?smatrix
smatrix(AEdemand)
trainTs
trainTs[[1]]
trainTs[[2]]
trainTs[[3]]
trainTs[[4]]
#Reconcile using the Bayesian approach
#how many predictions we manage within the hierarchy
numTs <- 0
for (i in seq_along(trainTs) ){
numTs <- numTs + frequency(trainTs[[i]])
}
#recover sigma and mean of each prediction
sigma <- vector(length = numTs)
preds <- vector(length = numTs)
fc
fc[[1]]
fc[[2]]
fc[[3]]
fc[[4]]
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
#recover sigma and mean of each prediction
sigma <- vector(length = numTs)
preds <- vector(length = numTs)
offset <- 1
for (i in seq_along(fc)) {
currentLenght <- length(fc[[i]]$mean)
currentPreds <- fc[[i]]$mean
preds[offset: (offset + currentLenght - 1 )] <- currentPreds
}
preds
fc[[1]]
fc[[2]]
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
fc
#recover sigma and mean of each prediction
sigma <- vector(length = numTs)
preds <- vector(length = numTs)
offset <- 1
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
offset <- 1
for (i in seq_along(fc)) {
currentLenght <- length(fc[[i]]$mean)
currentPreds <- fc[[i]]$mean
preds[offset: (offset + currentLenght - 1 )] <- currentPreds
offset <- offset + currentLenght
}
preds
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
seq_along(fc[[1]])
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
fc[[1]]$mean
fc[[1]]$mean[1]
fc[[1]]$upper[1]
length(fc[[1]])
length(fc[[2]])
fc[[1]]
time(fc[[1]])
fc[[1]]
class(fc[[1]])
class(fc[[1]]$mean)
time(fc[[1]]$mean)
length(time(fc[[1]]$mean))
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
library(fpp2)
library(hts)
library(thief)
source("hier.R")
#computes mae for temporal hierarchies
#both actual and forecast are temporal hierarchies
tHierMae <- function (actual, forecast){
hierMae <- vector(length = length(forecast))
for (i in seq_along(forecast)) {
hierMae[i] <- mean( abs (forecast[[i]]$mean - actual[[i]]) )
}
return (tHierMae)
}
#coverage of the PI is 0.8
alpha <- 0.2
#both lines temporary
ts <- usdeaths
tsName <- "pippo"
#predict one full season ahead (12 months or 4 quarters etc)
timeIdx <- time(ts)
endTrain <- length(timeIdx) - frequency(ts)
train <- window(ts, start = timeIdx[1], end = timeIdx[endTrain] )
test <- window(ts, start =timeIdx[endTrain +1])
trainTs <- tsaggregates(train)
testTs <- tsaggregates(test)
# Compute forecasts one full season ahead
fc <- list()
for(i in seq_along(trainTs)){
if (fmethod == "ets") {
fc[[i]] <- forecast(ets(trainTs[[i]]), h=frequency(trainTs[[i]]), level = (1-alpha))
}
else if (fmethod == "arima") {
fc[[i]] <- forecast(auto.arima(aggts[[i]]), h=2*frequency(aggts[[i]]))
}
fmethod<-"ets"
for(i in seq_along(trainTs)){
if (fmethod == "ets") {
fc[[i]] <- forecast(ets(trainTs[[i]]), h=frequency(trainTs[[i]]), level = (1-alpha))
}
else if (fmethod == "arima") {
fc[[i]] <- forecast(auto.arima(aggts[[i]]), h=2*frequency(aggts[[i]]))
}
# Reconcile forecasts using thief
thiefReconc <- reconcilethief(fc, comb = "struc")
buReconc <- reconcilethief(fc, comb = "bu")
#Reconcile using the Bayesian approach
#how many predictions we manage within the hierarchy
numTs <- 0
for (i in seq_along(trainTs) ){
numTs <- numTs + frequency(trainTs[[i]])
}
#recover sigma and mean of each prediction
sigma <- vector(length = numTs)
preds <- vector(length = numTs)
offset <- 1
#fill the predictions
for (i in seq_along(fc)) {
currentLenght <- length(fc[[i]]$mean)
currentPreds <- fc[[i]]$mean
preds[offset: (offset + currentLenght - 1 )] <- currentPreds
offset <- offset + currentLenght
}
currentPreds
pred
preds
#fill the sigma TO BE DEBUGGED
offset <- 0
for (i in seq_along(fc)) {
currentLenght <- length(fc[[i]]$mean)
#the sigma is different for each prediction, even if they are at the same level
for (j in seq_along(fc[[1]])){
sigma[j + offset] <- abs ( (fc[[i]]$mean[j] - fc[[i]]$upper[j])  / (qnorm(alpha / 2)) )
}
offset <- offset + length(time(fc[[i]]$mean))
}
sigma
#fill the sigma TO BE DEBUGGED
offset <- 0
i <- 1
currentLenght <- length(fc[[i]]$mean)
fc[[1]]
(fc[[1]]$mean - fc[[1]]$upper)/1.28
#the sigma is different for each prediction, even if they are at the same level
for (j in seq_along(fc[[1]])){
sigma[j + offset] <- abs ( (fc[[i]]$mean[j] - fc[[i]]$upper[j])  / (qnorm(alpha / 2)) )
}
simga
sigms
sigma
fc[[1]]
length(fc[[1]])
length(fc[[1]]$mean)
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
#recover sigma and mean of each prediction
sigma <- vector(length = numTs)
#fill the sigma TO BE DEBUGGED
offset <- 0
i <- 1
currentLenght <- length(fc[[i]]$mean)
#the sigma is different for each prediction, even if they are at the same level
for (j in 1:currentLenght) {
sigma[j + offset] <- abs ( (fc[[i]]$mean[j] - fc[[i]]$upper[j])  / (qnorm(alpha / 2)) )
}
sigma
for (i in seq_along(fc)) {
currentLenght <- length(fc[[i]]$mean)
#the sigma is different for each prediction, even if they are at the same level
for (j in 1:currentLenght) {
sigma[j + offset] <- abs ( (fc[[i]]$mean[j] - fc[[i]]$upper[j])  / (qnorm(alpha / 2)) )
}
offset <- offset + currentLenght
}
sigma
fc[[2]]
(fc[[2]]$mean-fc[[2]]$upper)/1.28
(fc[[5]]$mean-fc[[5]]$upper)/1.28
(fc[[6]]$mean-fc[[6]]$upper)/1.28
fc[[5]]
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
thier()
reconcilethief()
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
freq <- unlist(lapply(fc,frequency))
freq
fc
lapply(fc,frequency))
lapply(fc,frequency)
lapply(trainTs,frequency)
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
#setup the S matrix (code from combine.R of thief package)
freq <- unlist(lapply(trainTs,frequency))
freq
m <- max(freq)
m
?rev
nsum <- rev(rep(m/freq, freq))
nsum
unsum <- unique(nsum)
grps <- matrix(0, nrow=length(unsum)-1, ncol=m)
grps
for(i in 1:(length(unsum)-1))
{
mi <- m/unsum[i]
grps[i,] <- rep(1:mi, rep(unsum[i],mi))
}
grps
?MinT
freq
fc[[1]]
fc[[2]]
fc[[3]]
fc[[4]]
fc[[5]]
fc[[6]]
grps
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
# Set up matrix of forecasts in right structure
nc <- length(fc[[1]])/m
fmat <- matrix(0, nrow=0, ncol=nc)
for(i in rev(seq_along(fc)))
fmat
fmat <- matrix(0, nrow=0, ncol=nc)
for(i in rev(seq_along(fc)))
i <- 1
# Set up matrix of forecasts in right structure
nc <- length(fc[[1]])/m
fmat <- matrix(0, nrow=0, ncol=nc)
for(i in rev(seq_along(fc)))
i
matrix(fc[[i]], ncol=nc)
class(fc)
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
#CODE FROM THIED
forecasts <- list()
for(i in seq_along(fc))
for(i in seq_along(fc)){
forecasts[[i]] <- fc[[i]]$mean
}
#CODE FROM THIED
forecasts <- list()
for(i in seq_along(fc)){
forecasts[[i]] <- fc[[i]]$mean
}
# Set up matrix of forecasts in right structure
nc <- length(fc[[1]])/m
fmat <- matrix(0, nrow=0, ncol=nc)
for(i in rev(seq_along(fc)))
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
# Set up matrix of forecasts in right structure
nc <- length(fc[[1]])/m
fmat <- matrix(0, nrow=0, ncol=nc)
for(i in rev(seq_along(fc)))
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
# Set up matrix of forecasts in right structure
nc <- length(fc[[1]])/m
fmat <- matrix(0, nrow=0, ncol=nc)
for(i in rev(seq_along(fc))){
fmat <- rbind(fmat, matrix(forecasts[[i]], ncol=nc))
}
forecasts[[i]]
nc
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
