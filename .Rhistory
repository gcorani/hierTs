else if (fmethod=="arima"){
model <- auto.arima(allTsTrain[,i])
tmp <- forecast(model, h=h, level=1-alpha)
}
preds[i] <- tmp$mean[h]
sigma[i] <- abs ( (tmp$mean[h] - tmp$upper[h])  / (qnorm(alpha / 2)) )
}
mseBase =  mean  ( (allts(test)[h,] - preds)^2 )
S <- smatrix(train)
#Bayesian reconciliation
bottomIdx <- seq( nrow(S) - ncol(S) +1, nrow(S))
upperIdx <- setdiff(1:nrow(S),bottomIdx)
#prior mean and covariance of the bottom time series
priorMean <- preds[bottomIdx]
#prior mean and covariance of the upper time series
Y_vec <- preds[upperIdx]
Sigma_y <- matrix(nrow = length(upperIdx), ncol = length(upperIdx))
#prior covariance for the bottom time series
bottomVar <- sigma[bottomIdx]^2
priorCov <- diag(bottomVar)
#covariance for the upper time series
upperVar <- sigma[upperIdx]^2
Sigma_y <- diag(upperVar)
#==update in a single shot
#A explains how to combin the bottom series in order to obtain the
# upper series
A <- t(S[upperIdx,])
correl <- priorCov %*% A %*%
solve (t(A) %*% priorCov %*% A + Sigma_y)
postMean <- priorMean + correl  %*%
(Y_vec - t(A) %*% priorMean)
bayesPreds <- buReconcile(postMean, S, predsAllTs = FALSE)
mseBayes =  mean  ( (allts(test)[h,] - bayesPreds)^2 )
#save to file the results, at every iteration
dataFrame <- data.frame(h, fmethod, dset, mseBase,mseBu,mseComb,mseCombWls,mseCombMint,mseBayes)
filename <- "results/mseHierReconc.csv"
writeNames <- TRUE
if(file.exists(filename)){
writeNames <- FALSE
}
write.table(dataFrame, file=filename, append = TRUE, sep=",", row.names = FALSE, col.names = writeNames)
}
iTest<-1
timeIdx             <- time(hierTs$bts[,1])
endTrain            <- length(timeIdx) - h - (iTest - 1)
train               <- window(hierTs, start = timeIdx[1], end = timeIdx[endTrain] )
test                <- window(hierTs, start =timeIdx[endTrain +1], end=timeIdx[endTrain + h])
possiblePreds
timeIdx             <- time(hierTs$bts[,1])
endTrain            <- length(timeIdx) - h - (iTest - 1)
train               <- window(hierTs, start = timeIdx[1], end = timeIdx[endTrain] )
test                <- window(hierTs, start =timeIdx[endTrain +1], end=timeIdx[endTrain + h])
# ptm <- proc.time()
fcastBu             <- forecast(train, h = h, method = "bu", fmethod = fmethod)
#
# mseBu[iTest]        <- hierMse(fcastBu, test )
# mseComb[iTest]      <- hierMse(fcastComb, test )
# mseCombWls[iTest]   <- hierMse(fcastCombWls, test )
# mseCombMint[iTest]  <- hierMse(fcastCombMint, test )
mseBu        <- hierMse(fcastBu, test, h )
mseBu
#recompute predictions to be easily accessed by the Bayesian method
allTsTrain <- allts(train)
numTs <- ncol(allTsTrain)
alpha <- 0.2
sigma <- vector(length = numTs)
preds <- vector(length = numTs)
#compute, for each  ts, predictions and sigma (h-steps ahead)
for (i in 1:numTs){
if (fmethod=="ets"){
model <- ets(allTsTrain[,i])
tmp <- forecast(model, h=h, level=1-alpha)
# print(paste(as.character(i),"/",as.character(numTs)))
# print(model$components)
}
else if (fmethod=="arima"){
model <- auto.arima(allTsTrain[,i])
tmp <- forecast(model, h=h, level=1-alpha)
}
preds[i] <- tmp$mean[h]
sigma[i] <- abs ( (tmp$mean[h] - tmp$upper[h])  / (qnorm(alpha / 2)) )
}
mseBase =  mean  ( (allts(test)[h,] - preds)^2 )
mseBase
S <- smatrix(train)
#Bayesian reconciliation
bottomIdx <- seq( nrow(S) - ncol(S) +1, nrow(S))
upperIdx <- setdiff(1:nrow(S),bottomIdx)
#prior mean and covariance of the bottom time series
priorMean <- preds[bottomIdx]
myPreds <- buReconcile(priorMean, S, predsAllTs = FALSE)
mean  ( (allts(test)[h,] - myPreds)^2 )
S <- smatrix(train)
#Bayesian reconciliation
bottomIdx <- seq( nrow(S) - ncol(S) +1, nrow(S))
upperIdx <- setdiff(1:nrow(S),bottomIdx)
#prior mean and covariance of the bottom time series
priorMean <- preds[bottomIdx]
#prior mean and covariance of the upper time series
Y_vec <- preds[upperIdx]
Sigma_y <- matrix(nrow = length(upperIdx), ncol = length(upperIdx))
#prior covariance for the bottom time series
bottomVar <- sigma[bottomIdx]^2
priorCov <- diag(bottomVar)
#covariance for the upper time series
upperVar <- sigma[upperIdx]^2
Sigma_y <- diag(upperVar)
#==update in a single shot
#A explains how to combin the bottom series in order to obtain the
# upper series
A <- t(S[upperIdx,])
correl <- priorCov %*% A %*%
solve (t(A) %*% priorCov %*% A + Sigma_y)
postMean <- priorMean + correl  %*%
(Y_vec - t(A) %*% priorMean)
correl
bayesPreds <- buReconcile(postMean, S, predsAllTs = FALSE)
mseBayes =  mean  ( (allts(test)[h,] - bayesPreds)^2 )
mseBayes
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
?infantgts
library(gts)
library(hts)
?infantgts
infantgts$bts
length(infantgts$bts)
length(infantgts$bts[,1])
hierTs <- loadTourism()
source("loadTourism.R")
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
source("loadTourism.R")
#The buReconcile function computes the bu prediction given the predictions (1 x tot time series) and the S matrix
#(tot time series X bottom time series)
#predsAllTs is a flag: is set to true, the input preds contains predictions for all the hierarchy
#and the function retrieves the bottom series; if set to false, this is not needed
#as preds only contains only bottom time series
buReconcile <- function (preds,S, predsAllTs = FALSE) {
bottomPreds <- preds
if (predsAllTs) {
#retrieves the bottom prediction from all predictions
upperIdx <- 1 : (nrow(S) - ncol(S))
bottomIdx <- setdiff (1:nrow(S), upperIdx)
bottomPreds <- preds [,bottomIdx]
}
buPreds <- preds
#nrow(S) is the total number of time series
for (i in 1:nrow(S)){
buPreds[i] <- S[i,] %*% bottomPreds
}
return (buPreds)
}
hierMse <- function (htsPred, htsActual, h) {
#receives two hts objects, containing  forecast and actual value.
#computes the mse for the whole hierarchy.
mse <- mean  ( (allts(htsPred)[h,] - allts(htsActual)[h,])^2 )
return (mse)
}
hierTs <- loadTourism()
hierTs$bts
hierTs$bts[1,]
hierTs$bts[,1]
length(hierTs$bts[,1])
length(infantgts$bts[,1])
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
batchHier <- function(){
source("hier.R")
# for (h in c(1,2,3,4)) {
#   for (method in c("ets","arima")){
#     a <- hier ("htseg2", h=h, fmethod = method)
#     print(paste("htseg2 ", as.character(method)))
#   }
# }
#
# for (h in c(1,2)) {
#   for (method in c("ets","arima")){
#     print(paste("htseg1 ", as.character(method)))
#     a <- hier ("htseg1", h=h, fmethod = method)
#   }
# }
for (h in c(1,2,3,4)) {
for (method in c("ets","arima")){
print(paste("infantgts ", as.character(method), "h=", as.character(h)))
a <- hier("infantgts", h=h, fmethod = method)
}
# for (h in c(1,2,3,4)) {
#   for (method in c("ets","arima")){
#     print(paste("tourism", as.character(method)))
#     a <- hier("tourism", h=h, fmethod = method)
#   }
# }
#
}
batchHier()
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
batchHier()
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
batchHier()
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/parseHierResults.R')
parseHierResults()
batchHier <- function(){
source("hier.R")
# for (h in c(1,2,3,4)) {
#   for (method in c("ets","arima")){
#     a <- hier ("htseg2", h=h, fmethod = method)
#     print(paste("htseg2 ", as.character(method)))
#   }
# }
#
# for (h in c(1,2)) {
#   for (method in c("ets","arima")){
#     print(paste("htseg1 ", as.character(method)))
#     a <- hier ("htseg1", h=h, fmethod = method)
#   }
# }
for (h in c(1,2,3,4)) {
for (method in c("ets","arima")){
print(paste("infantgts ", as.character(method), "h=", as.character(h)))
a <- hier("infantgts", h=h, fmethod = method)
}
# for (h in c(1,2,3,4)) {
#   for (method in c("ets","arima")){
#     print(paste("tourism", as.character(method)))
#     a <- hier("tourism", h=h, fmethod = method)
#   }
# }
#
}
71-24
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/batchHier.R')
batchHier()
parseHierResults()
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/parseHierResults.R')
parseHierResults()
#parse the results of hierarchical non-temporal reconciliation
#readt the mse, extract the proportion of favorable signs and the produces the boxplot
library(readr)
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/parseHierResults.R')
results <- read_csv("results/mseHierReconc.csv")
fmethods <- unique(results$fmethod)
dsets <- unique(results$dset)
horizons <- unique(results$h)
configs <- length(fmethods) * length(dsets) * length(horizons)
#we need first to instantiate the data frame with placeholder values, and then we fill the correct values
favorableProps <- data.frame(dset=rep(dsets[1],configs),
h=rep(horizons[1],configs),
fmethod=rep(fmethods[1],configs),
propBeatBase=rep(-1,configs),
propBeatBu=rep(-1,configs),
propBeatComb=rep(-1,configs),
propBeatCombWls=rep(-1,configs),
propBeatMint=rep(-1,configs),
stringsAsFactors = FALSE
)
counter <- 1
for (dset in dsets){
for (fmethod in fmethods){
for (h in horizons){
print(paste(fmethod,dset,h))
favorableProps$dset[counter] <- dset
favorableProps$fmethod[counter] <- fmethod
favorableProps$h[counter] <- h
idx = results$fmethod==fmethod & results$dset==dset & results$h==h
if (sum(idx)>0){
subresults <- results[idx,]
favorableProps$propBeatBase[counter] <- mean (subresults$mseBase>subresults$mseBayes)
favorableProps$propBeatBu[counter] <- mean (subresults$mseBu>subresults$mseBayes)
favorableProps$propBeatComb[counter] <- mean (subresults$mseComb>subresults$mseBayes)
favorableProps$propBeatCombWls[counter] <- mean (subresults$mseCombWls>subresults$mseBayes)
favorableProps$propBeatMint[counter] <- mean (subresults$mseCombMint>subresults$mseBayes)
#generate the bplot with ggplot2
library(ggplot2)
pdfname <- paste("results/GGPLOThier","_",dset,"_",fmethod,"_h",h,".pdf",sep = "")
denom <- subresults$mseBase
resLenght <- length(subresults$mseBase)
# relMse <- rbind(matrix(subresults$mseBu/denom), matrix(subresults$mseComb/denom), matrix(subresults$mseCombWls/denom),
# matrix(subresults$mseCombMint/denom), matrix(subresults$mseBayes/denom))
relMse <- rbind(matrix(subresults$mseBu/denom), matrix(subresults$mseCombWls/denom),
matrix(subresults$mseCombMint/denom), matrix(subresults$mseBayes/denom))
# label <-  factor(rbind(matrix(rep("Bu",resLenght)),matrix(rep("Comb",resLenght)),matrix(rep("CombWls",resLenght)),
# matrix(rep("Mint",resLenght)),matrix(rep("Bayes",resLenght))),
# levels = c("Bu","Comb","CombWls","Mint","Bayes"))
label <-  factor(rbind(matrix(rep("Bu",resLenght)),matrix(rep("CombWls",resLenght)),
matrix(rep("Mint",resLenght)),matrix(rep("Bayes",resLenght))),
levels = c("Bu","CombWls","Mint","Bayes"))
dataPlot <- as.data.frame(relMse)
dataPlot$label <- label
currentPlot <- ggplot(dataPlot, aes(x = label, y = log10(relMse))) + geom_boxplot()  +
stat_boxplot(geom = "errorbar", width = 0.5) +  #draw the whiskers
scale_x_discrete(name = "") +
scale_y_continuous(name = "Log10 (MSE / MSE base) ")
print(currentPlot)
ggsave(pdfname, width = 4, height = 3)
counter <- counter + 1
}
install.packages("subtotal")
subtotals
?subtotals
install.packages("crunch")
library(crunch)
#parse the results of hierarchical non-temporal reconciliation
#aggregating over different h, instead of treating them separately
#readt the mse, extract the proportion of favorable signs and the produces the boxplot
library(readr)
results <- read_csv("results/mseHierReconc.csv")
fmethods <- unique(results$fmethod)
dsets <- unique(results$dset)
# horizons <- unique(results$h)
configs <- length(fmethods) * length(dsets)
#we need first to instantiate the data frame with placeholder values, and then we fill the correct values
favorableProps <- data.frame(dset=rep(dsets[1],configs),
# h=rep(horizons[1],configs),
fmethod=rep(fmethods[1],configs),
propBeatBase=rep(-1,configs),
propBeatBu=rep(-1,configs),
propBeatComb=rep(-1,configs),
propBeatCombWls=rep(-1,configs),
propBeatMint=rep(-1,configs),
stringsAsFactors = FALSE
)
counter <- 1
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/parseHierResults_aggregatedH.R')
parseHierResults_aggregatedH()
#parse the results of hierarchical non-temporal reconciliation
#aggregating over different h, instead of treating them separately
#readt the mse, extract the proportion of favorable signs and the produces the boxplot
library(readr)
results <- read_csv("results/mseHierReconc.csv")
fmethods <- unique(results$fmethod)
dsets <- unique(results$dset)
# horizons <- unique(results$h)
configs <- length(fmethods) * length(dsets)
#we need first to instantiate the data frame with placeholder values, and then we fill the correct values
favorableProps <- data.frame(dset=rep(dsets[1],configs),
# h=rep(horizons[1],configs),
fmethod=rep(fmethods[1],configs),
propBeatBase=rep(-1,configs),
propBeatBu=rep(-1,configs),
propBeatComb=rep(-1,configs),
propBeatCombWls=rep(-1,configs),
propBeatMint=rep(-1,configs),
stringsAsFactors = FALSE
)
counter <- 1
dsets
#parse the results of hierarchical non-temporal reconciliation
#aggregating over different h, instead of treating them separately
#readt the mse, extract the proportion of favorable signs and the produces the boxplot
library(readr)
results <- read_csv("results/mseHierReconc.csv")
fmethods <- unique(results$fmethod)
dsets <- unique(results$dset)
# horizons <- unique(results$h)
configs <- length(fmethods) * length(dsets)
#we need first to instantiate the data frame with placeholder values, and then we fill the correct values
favorableProps <- data.frame(dset=rep(dsets[1],configs),
# h=rep(horizons[1],configs),
fmethod=rep(fmethods[1],configs),
propBeatBase=rep(-1,configs),
propBeatBu=rep(-1,configs),
propBeatComb=rep(-1,configs),
propBeatCombWls=rep(-1,configs),
propBeatMint=rep(-1,configs),
stringsAsFactors = FALSE
)
counter <- 1
for (dset in dsets){
for (fmethod in fmethods){
# for (h in horizons){
print(paste(fmethod,dset))
favorableProps$dset[counter] <- dset
favorableProps$fmethod[counter] <- fmethod
# favorableProps$h[counter] <- h
idx = results$fmethod==fmethod & results$dset==dset #& results$h==h
if (sum(idx)>0){
subresults <- results[idx,]
favorableProps$propBeatBase[counter] <- mean (subresults$mseBase>subresults$mseBayes)
favorableProps$propBeatBu[counter] <- mean (subresults$mseBu>subresults$mseBayes)
favorableProps$propBeatComb[counter] <- mean (subresults$mseComb>subresults$mseBayes)
favorableProps$propBeatCombWls[counter] <- mean (subresults$mseCombWls>subresults$mseBayes)
favorableProps$propBeatMint[counter] <- mean (subresults$mseCombMint>subresults$mseBayes)
#generate the bplot with ggplot2
library(ggplot2)
pdfname <- paste("results/GGPLOThier","_",dset,"_",fmethod,".pdf",sep = "")
denom <- subresults$mseBase
resLenght <- length(subresults$mseBase)
relMse <- rbind(matrix(subresults$mseBu/denom), matrix(subresults$mseCombWls/denom),
matrix(subresults$mseCombMint/denom), matrix(subresults$mseBayes/denom))
label <-  factor(rbind(matrix(rep("Bu",resLenght)),matrix(rep("CombWls",resLenght)),
matrix(rep("Mint",resLenght)),matrix(rep("Bayes",resLenght))),
levels = c("Bu","CombWls","Mint","Bayes"))
dataPlot <- as.data.frame(relMse)
dataPlot$label <- label
currentPlot <- ggplot(dataPlot, aes(x = label, y = log10(relMse))) + geom_boxplot()  +
stat_boxplot(geom = "errorbar", width = 0.5) +  #draw the whiskers
scale_x_discrete(name = "") +
scale_y_continuous(name = "Log10 (MSE / MSE base) ")
print(currentPlot)
ggsave(pdfname, width = 4, height = 3)
counter <- counter + 1
}
parseHierResults_aggregatedH()
favorableProps
parseHierResults_eachH()
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/parseHierResults_eachH.R')
parseHierResults_eachH()
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
dset="tourism"
h=1
fmethod="ets"
library(hts)
source("loadTourism.R")
if (is.character(dset) == FALSE) {
stop ("dset should be a string")
}
#The buReconcile function computes the bu prediction given the predictions (1 x tot time series) and the S matrix
#(tot time series X bottom time series)
#predsAllTs is a flag: is set to true, the input preds contains predictions for all the hierarchy
#and the function retrieves the bottom series; if set to false, this is not needed
#as preds only contains only bottom time series
buReconcile <- function (preds,S, predsAllTs = FALSE) {
bottomPreds <- preds
if (predsAllTs) {
#retrieves the bottom prediction from all predictions
upperIdx <- 1 : (nrow(S) - ncol(S))
bottomIdx <- setdiff (1:nrow(S), upperIdx)
bottomPreds <- preds [,bottomIdx]
}
buPreds <- preds
#nrow(S) is the total number of time series
for (i in 1:nrow(S)){
buPreds[i] <- S[i,] %*% bottomPreds
}
return (buPreds)
}
hierMse <- function (htsPred, htsActual, h) {
#receives two hts objects, containing  forecast and actual value.
#computes the mse for the whole hierarchy.
mse <- mean  ( (allts(htsPred)[h,] - allts(htsActual)[h,])^2 )
return (mse)
}
#extract the time from the data set to then split into train / test (test set contains 25 or 5 time points)
set.seed(seed = 0)
hierTs <- loadTourism()
testSize <- 45
#if h=1, the possible preds are the whole test size lenght;
#if h=2, the possible preds are the (test size lenght -1); etc.
possiblePreds <- testSize - h + 1
iTest <- 1
timeIdx             <- time(hierTs$bts[,1])
endTrain            <- length(timeIdx) - h - (iTest - 1)
train               <- window(hierTs, start = timeIdx[1], end = timeIdx[endTrain] )
test                <- window(hierTs, start =timeIdx[endTrain +1], end=timeIdx[endTrain + h])
#recompute predictions to be easily accessed by the Bayesian method
allTsTrain <- allts(train)
numTs <- ncol(allTsTrain)
alpha <- 0.2
sigma <- vector(length = numTs)
preds <- vector(length = numTs)
#compute, for each  ts, predictions and sigma (h-steps ahead)
for (i in 1:numTs){
if (fmethod=="ets"){
model <- ets(allTsTrain[,i])
tmp <- forecast(model, h=h, level=1-alpha)
# print(paste(as.character(i),"/",as.character(numTs)))
# print(model$components)
}
else if (fmethod=="arima"){
model <- auto.arima(allTsTrain[,i])
tmp <- forecast(model, h=h, level=1-alpha)
}
preds[i] <- tmp$mean[h]
sigma[i] <- abs ( (tmp$mean[h] - tmp$upper[h])  / (qnorm(alpha / 2)) )
}
S <- smatrix(train)
#Bayesian reconciliation
bottomIdx <- seq( nrow(S) - ncol(S) +1, nrow(S))
upperIdx <- setdiff(1:nrow(S),bottomIdx)
#prior mean and covariance of the bottom time series
priorMean <- preds[bottomIdx]
#prior mean and covariance of the upper time series
Y_vec <- preds[upperIdx]
Sigma_y <- matrix(nrow = length(upperIdx), ncol = length(upperIdx))
#prior covariance for the bottom time series
bottomVar <- sigma[bottomIdx]^2
priorCov <- diag(bottomVar)
bottomVar
priorCov
dim(priorCov)
dim(A)
#==updating
#A explains how to combin the bottom series in order to obtain the
# upper series
A <- t(S[upperIdx,])
correl <- priorCov %*% A %*%
solve (t(A) %*% priorCov %*% A + Sigma_y)
correl
priorCov
#prior covariance for the bottom time series
bottomVar <- sigma[bottomIdx]^2
priorCov <- diag(bottomVar)
#covariance for the upper time series
upperVar <- sigma[upperIdx]^2
Sigma_y <- diag(upperVar)
#==updating
#A explains how to combin the bottom series in order to obtain the
# upper series
A <- t(S[upperIdx,])
correl <- priorCov %*% A %*%
solve (t(A) %*% priorCov %*% A + Sigma_y)
correl
dim(correl)
