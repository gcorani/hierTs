favorableProps$medianMintBayesCorr[counter] <- median(subresults$mseCombMint / subresults$mseBayesCorr)
#generate the bplot with ggplot2
library(ggplot2)
pdfname <- paste("results/plot","_",dset,"_",fmethod,".pdf",sep = "")
denom <- subresults$mseBase
resLenght <- length(subresults$mseBase)
#old code, 3 models
# relMse <- rbind(matrix(subresults$mseCombMint/denom), matrix(subresults$mseBayes/denom), matrix(subresults$mseBayesCorr/denom))
# label <-  factor(rbind(matrix(rep("Mint",resLenght)),matrix(rep("Bayes",resLenght)),matrix(rep("Bayes (corr)",resLenght))),
# levels = c("Mint","Bayes","Bayes (corr)"))
#new code, 2 models (minT and Bayes corr)
relMse <- rbind(matrix(subresults$mseCombMint/denom), matrix(subresults$mseBayesCorr/denom))
label <-  factor(rbind(matrix(rep("Mint",resLenght)),matrix(rep("Bayes-corr",resLenght))),
levels = c("MinT","Bayes-corr"))
dataPlot <- as.data.frame(relMse)
dataPlot$label <- label
currentPlot <- ggplot(dataPlot, aes(x = label, y = log10(relMse))) + geom_boxplot()  +
stat_boxplot(geom = "errorbar", width = 0.5) +  #draw the whiskers
scale_x_discrete(name = "") +
scale_y_continuous(name = "Log (relative mse)")
scaling <- 1.8 #to avoid large outliers that make the boxplot unreadable
if (dset=="tourism"){
scaling<- 1.1
}
else if (fmethod=="ets"){
scaling<- 3
}
ylim1 = boxplot.stats(log(dataPlot$V1))$stats[c(1, 5)]
currentPlot = currentPlot + coord_cartesian(ylim = ylim1*scaling)  + geom_hline(yintercept = 0, color='darkblue', linetype="dashed")
print(currentPlot)
ggsave(pdfname, width = 4, height = 3)
counter <- counter + 1
}
print(currentPlot)
relMse
label
label <-  factor(rbind(matrix(rep("MinT",resLenght)),matrix(rep("Bayes-corr",resLenght))),
levels = c("MinT","Bayes-corr"))
label
for (dset in dsets){
for (fmethod in fmethods){
print(paste(fmethod,dset))
favorableProps$dset[counter] <- dset
favorableProps$fmethod[counter] <- fmethod
idx = results$fmethod==fmethod & results$dset==dset
if (sum(idx)>0){
subresults <- results[idx,]
favorableProps$propBeatBase[counter] <- mean (subresults$mseBase>subresults$mseBayes)
favorableProps$propBeatMint[counter] <- mean (subresults$mseCombMint>subresults$mseBayes)
favorableProps$medianBaseBayes[counter] <- median(subresults$mseBase / subresults$mseBayes)
favorableProps$medianMintBayes[counter] <- median(subresults$mseCombMint / subresults$mseBayes)
favorableProps$propCorrBeatBase[counter] <- mean (subresults$mseBase>subresults$mseBayesCorr)
favorableProps$propCorrBeatMint[counter] <- mean (subresults$mseCombMint>subresults$mseBayesCorr)
favorableProps$medianBaseBayesCorr[counter]  <- median(subresults$mseBase / subresults$mseBayesCorr)
favorableProps$medianMintBayesCorr[counter] <- median(subresults$mseCombMint / subresults$mseBayesCorr)
#generate the bplot with ggplot2
library(ggplot2)
pdfname <- paste("results/plot","_",dset,"_",fmethod,".pdf",sep = "")
denom <- subresults$mseBase
resLenght <- length(subresults$mseBase)
#old code, 3 models
# relMse <- rbind(matrix(subresults$mseCombMint/denom), matrix(subresults$mseBayes/denom), matrix(subresults$mseBayesCorr/denom))
# label <-  factor(rbind(matrix(rep("Mint",resLenght)),matrix(rep("Bayes",resLenght)),matrix(rep("Bayes (corr)",resLenght))),
# levels = c("Mint","Bayes","Bayes (corr)"))
#new code, 2 models (minT and Bayes corr)
relMse <- rbind(matrix(subresults$mseCombMint/denom), matrix(subresults$mseBayesCorr/denom))
label <-  factor(rbind(matrix(rep("MinT",resLenght)),matrix(rep("Bayes-corr",resLenght))),
levels = c("MinT","Bayes-corr"))
dataPlot <- as.data.frame(relMse)
dataPlot$label <- label
currentPlot <- ggplot(dataPlot, aes(x = label, y = log10(relMse))) + geom_boxplot()  +
stat_boxplot(geom = "errorbar", width = 0.5) +  #draw the whiskers
scale_x_discrete(name = "") +
scale_y_continuous(name = "Log (relative mse)")
scaling <- 1.8 #to avoid large outliers that make the boxplot unreadable
if (dset=="tourism"){
scaling<- 1.1
}
else if (fmethod=="ets"){
scaling<- 3
}
ylim1 = boxplot.stats(log(dataPlot$V1))$stats[c(1, 5)]
currentPlot = currentPlot + coord_cartesian(ylim = ylim1*scaling)  + geom_hline(yintercept = 0, color='darkblue', linetype="dashed")
print(currentPlot)
ggsave(pdfname, width = 4, height = 3)
counter <- counter + 1
}
#parse the results of hierarchical non-temporal reconciliation
#readt the mse, extract the proportion of favorable signs and the produces the boxplot
library(readr)
results <- read_csv(paste("results/mseHierReconc",dset,".csv",sep=""))
results <- unique(results) #because some experiements on the cluster are duplicated
fmethods <- unique(results$fmethod)
dsets <- unique(results$dset)
configs <- length(fmethods) * length(dsets)
#we need first to instantiate the data frame with placeholder values, and then we fill the correct values
favorableProps <- data.frame(dset=rep(dsets[1],configs),
fmethod=rep(fmethods[1],configs),
propBeatBase=rep(-1,configs),
propBeatMint=rep(-1,configs),
medianBaseBayes=rep(-1,configs),
medianMintBayes=rep(-1,configs),
propCorrBeatBase=rep(-1,configs),
propCorrBeatMint=rep(-1,configs),
medianBaseBayesCorr=rep(-1,configs),
medianMintBayesCorr=rep(-1,configs),
stringsAsFactors = FALSE
)
counter <- 1
for (dset in dsets){
for (fmethod in fmethods){
print(paste(fmethod,dset))
favorableProps$dset[counter] <- dset
favorableProps$fmethod[counter] <- fmethod
idx = results$fmethod==fmethod & results$dset==dset
if (sum(idx)>0){
subresults <- results[idx,]
favorableProps$propBeatBase[counter] <- mean (subresults$mseBase>subresults$mseBayes)
favorableProps$propBeatMint[counter] <- mean (subresults$mseCombMint>subresults$mseBayes)
favorableProps$medianBaseBayes[counter] <- median(subresults$mseBase / subresults$mseBayes)
favorableProps$medianMintBayes[counter] <- median(subresults$mseCombMint / subresults$mseBayes)
favorableProps$propCorrBeatBase[counter] <- mean (subresults$mseBase>subresults$mseBayesCorr)
favorableProps$propCorrBeatMint[counter] <- mean (subresults$mseCombMint>subresults$mseBayesCorr)
favorableProps$medianBaseBayesCorr[counter]  <- median(subresults$mseBase / subresults$mseBayesCorr)
favorableProps$medianMintBayesCorr[counter] <- median(subresults$mseCombMint / subresults$mseBayesCorr)
#generate the bplot with ggplot2
library(ggplot2)
pdfname <- paste("results/plot","_",dset,"_",fmethod,".pdf",sep = "")
denom <- subresults$mseBase
resLenght <- length(subresults$mseBase)
#old code, 3 models
# relMse <- rbind(matrix(subresults$mseCombMint/denom), matrix(subresults$mseBayes/denom), matrix(subresults$mseBayesCorr/denom))
# label <-  factor(rbind(matrix(rep("Mint",resLenght)),matrix(rep("Bayes",resLenght)),matrix(rep("Bayes (corr)",resLenght))),
# levels = c("Mint","Bayes","Bayes (corr)"))
#new code, 2 models (minT and Bayes corr)
relMse <- rbind(matrix(subresults$mseCombMint/denom), matrix(subresults$mseBayesCorr/denom))
label <-  factor(rbind(matrix(rep("MinT",resLenght)),matrix(rep("Bayes-corr",resLenght))),
levels = c("MinT","Bayes-corr"))
dataPlot <- as.data.frame(relMse)
dataPlot$label <- label
currentPlot <- ggplot(dataPlot, aes(x = label, y = log10(relMse))) + geom_boxplot()  +
stat_boxplot(geom = "errorbar", width = 0.5) +  #draw the whiskers
scale_x_discrete(name = "") +
scale_y_continuous(name = "Log (relative mse)")
scaling <- 1.8 #to avoid large outliers that make the boxplot unreadable
if (dset=="tourism"){
scaling<- 1.1
}
else if (fmethod=="ets"){
scaling<- 3
}
ylim1 = boxplot.stats(log(dataPlot$V1))$stats[c(1, 5)]
currentPlot = currentPlot + coord_cartesian(ylim = ylim1*scaling)  + geom_hline(yintercept = 0, color='darkblue', linetype="dashed")
print(currentPlot)
ggsave(pdfname, width = 4, height = 3)
counter <- counter + 1
}
parseHierResults_aggregatedH("infantgts")
source('~/switchDrive/paperReconc/hierarchicalTimeSeries/code/hierTs/parseHierResults_aggregatedH.R', echo=TRUE)
parseHierResults_aggregatedH("infantgts")
parseHierResults_aggregatedH("tourism")
source('~/switchDrive/paperReconc/hierarchicalTimeSeries/code/hierTs/parseHierResults_aggregatedH.R')
#we need first to instantiate the data frame with placeholder values, and then we fill the correct values
favorableProps <- data.frame(dset=rep(dsets[1],configs),
fmethod=rep(fmethods[1],configs),
propBeatBase=rep(-1,configs),
propBeatMint=rep(-1,configs),
pValPropBeatMint=rep(-1,configs),
medianBaseBayes=rep(-1,configs),
medianMintBayes=rep(-1,configs),
pValMedianMintBayes=rep(-1,configs),
propCorrBeatBase=rep(-1,configs),
propCorrBeatMint=rep(-1,configs),
pValPropCorrBeatMint=rep(-1,configs),
medianBaseBayesCorr=rep(-1,configs),
medianMintBayesCorr=rep(-1,configs),
pValMedianMintBayesCorr=rep(-1,configs),
stringsAsFactors = FALSE
)
source('~/switchDrive/paperReconc/hierarchicalTimeSeries/code/hierTs/parseHierResults_aggregatedH.R')
binom.test(sum(subresults$mseCombMint>subresults$mseBayes), length(subresults$mseBayes))
binom.test(sum(subresults$mseCombMint<subresults$mseBayes), length(subresults$mseBayes))
a<-binom.test(sum(subresults$mseCombMint<subresults$mseBayes), length(subresults$mseBayes))
a$p.value
a<-binom.test(sum(subresults$mseCombMint<subresults$mseBayes), length(subresults$mseBayes))$p.value
a
source('~/switchDrive/paperReconc/hierarchicalTimeSeries/code/hierTs/parseHierResults_aggregatedH.R')
counter<-1
favorableProps$dset[counter] <- dset
favorableProps$fmethod[counter] <- fmethod
idx = results$fmethod==fmethod & results$dset==dset
subresults <- results[idx,]
favorableProps$propBeatBase[counter] <- mean (subresults$mseBase>subresults$mseBayes)
favorableProps$propBeatMint[counter] <- mean (subresults$mseCombMint>subresults$mseBayes)
favorableProps$pValPropBeatMint[counter] <- binom.test(sum(subresults$mseCombMint<subresults$mseBayes), length(subresults$mseBayes))$p.value
favorableProps$medianBaseBayes[counter] <- median(subresults$mseBase / subresults$mseBayes)
favorableProps$medianMintBayes[counter] <- median(subresults$mseCombMint / subresults$mseBayes)
favorableProps$pValPropBeatMint[counter]
favorableProps$propCorrBeatBase[counter] <- mean (subresults$mseBase>subresults$mseBayesCorr)
favorableProps$propCorrBeatMint[counter] <- mean (subresults$mseCombMint>subresults$mseBayesCorr)
favorableProps$pValPropCorrBeatMint[counter] <- binom.test(sum(subresults$mseCombMint>subresults$mseBayesCorr), length(subresults$mseBayesCorr))$p.value
favorableProps$pValPropCorrBeatMint[counter]
?wilcox.test
wilcox.test(log(subresults$mseCombMint / subresults$mseBayes))
a<-wilcox.test(log(subresults$mseCombMint / subresults$mseBayes))$p.value
source('~/switchDrive/paperReconc/hierarchicalTimeSeries/code/hierTs/parseHierResults_aggregatedH.R')
parseHierResults_aggregatedH("infantgts")
source('~/switchDrive/paperReconc/hierarchicalTimeSeries/code/hierTs/parseHierResults_aggregatedH.R')
setwd("~/switchDrive/paperReconc/hierarchicalTimeSeries/code/hierTs")
a<-parseHierResults_aggregatedH("infantgts")
a
source('~/switchDrive/paperReconc/hierarchicalTimeSeries/code/hierTs/parseHierResults_aggregatedH.R', echo=TRUE)
a<-parseHierResults_aggregatedH("infantgts")
a
0.9828289 + 1.0171615
dset <- "infantgts"
#parse the results of hierarchical non-temporal reconciliation
#readt the mse, extract the proportion of favorable signs and the produces the boxplot
library(readr)
results <- read_csv(paste("results/mseHierReconc",dset,".csv",sep=""))
results <- unique(results) #because some experiements on the cluster are duplicated
fmethods <- unique(results$fmethod)
dsets <- unique(results$dset)
configs <- length(fmethods) * length(dsets)
#we need first to instantiate the data frame with placeholder values, and then we fill the correct values
favorableProps <- data.frame(dset=rep(dsets[1],configs),
fmethod=rep(fmethods[1],configs),
propBeatBase=rep(-1,configs),
propBeatMint=rep(-1,configs),
pValPropBeatMint=rep(-1,configs),
medianBaseBayes=rep(-1,configs),
medianMintBayes=rep(-1,configs),
pValMedianMintBayes=rep(-1,configs),
propCorrBeatBase=rep(-1,configs),
propCorrBeatMint=rep(-1,configs),
pValPropCorrBeatMint=rep(-1,configs),
medianBaseBayesCorr=rep(-1,configs),
medianMintBayesCorr=rep(-1,configs),
pValMedianMintBayesCorr=rep(-1,configs),
stringsAsFactors = FALSE
)
configs
for (dset in dsets){
for (fmethod in fmethods){
print(paste(fmethod,dset))
favorableProps$dset[counter] <- dset
favorableProps$fmethod[counter] <- fmethod
idx = results$fmethod==fmethod & results$dset==dset
if (sum(idx)>0){
subresults <- results[idx,]
favorableProps$propBeatBase[counter] <- mean (subresults$mseBase>subresults$mseBayes)
favorableProps$propBeatMint[counter] <- mean (subresults$mseCombMint>subresults$mseBayes)
favorableProps$pValPropBeatMint[counter] <- binom.test(sum(subresults$mseCombMint>subresults$mseBayes), length(subresults$mseBayes))$p.value
favorableProps$medianBaseBayes[counter] <- median(subresults$mseBase / subresults$mseBayes)
favorableProps$medianMintBayes[counter] <- median(subresults$mseCombMint / subresults$mseBayes)
favorableProps$pValMedianMintBayes <- wilcox.test(log(subresults$mseCombMint / subresults$mseBayes))$p.value
favorableProps$propCorrBeatBase[counter] <- mean (subresults$mseBase>subresults$mseBayesCorr)
favorableProps$propCorrBeatMint[counter] <- mean (subresults$mseCombMint>subresults$mseBayesCorr)
favorableProps$pValPropCorrBeatMint[counter] <- binom.test(sum(subresults$mseCombMint>subresults$mseBayesCorr), length(subresults$mseBayesCorr))$p.value
favorableProps$medianBaseBayesCorr[counter]  <- median(subresults$mseBase / subresults$mseBayesCorr)
favorableProps$medianMintBayesCorr[counter] <- median(subresults$mseCombMint / subresults$mseBayesCorr)
favorableProps$pValMedianMintBayesCorr <- wilcox.test(log(subresults$mseCombMint / subresults$mseBayesCorr))$p.value
#generate the bplot with ggplot2
library(ggplot2)
pdfname <- paste("results/plot","_",dset,"_",fmethod,".pdf",sep = "")
denom <- subresults$mseBase
resLenght <- length(subresults$mseBase)
#old code, 3 models
# relMse <- rbind(matrix(subresults$mseCombMint/denom), matrix(subresults$mseBayes/denom), matrix(subresults$mseBayesCorr/denom))
# label <-  factor(rbind(matrix(rep("Mint",resLenght)),matrix(rep("Bayes",resLenght)),matrix(rep("Bayes (corr)",resLenght))),
# levels = c("Mint","Bayes","Bayes (corr)"))
#new code, 2 models (minT and Bayes corr)
relMse <- rbind(matrix(subresults$mseCombMint/denom), matrix(subresults$mseBayesCorr/denom))
label <-  factor(rbind(matrix(rep("MinT",resLenght)),matrix(rep("Bayes-corr",resLenght))),
levels = c("MinT","Bayes-corr"))
dataPlot <- as.data.frame(relMse)
dataPlot$label <- label
currentPlot <- ggplot(dataPlot, aes(x = label, y = log10(relMse))) + geom_boxplot()  +
stat_boxplot(geom = "errorbar", width = 0.5) +  #draw the whiskers
scale_x_discrete(name = "") +
scale_y_continuous(name = "Log (relative mse)")
scaling <- 1.8 #to avoid large outliers that make the boxplot unreadable
if (dset=="tourism"){
scaling<- 1.1
}
else if (fmethod=="ets"){
scaling<- 3
}
ylim1 = boxplot.stats(log(dataPlot$V1))$stats[c(1, 5)]
currentPlot = currentPlot + coord_cartesian(ylim = ylim1*scaling)  + geom_hline(yintercept = 0, color='darkblue', linetype="dashed")
print(currentPlot)
ggsave(pdfname, width = 4, height = 3)
counter <- counter + 1
}
counter <- 1
for (dset in dsets){
for (fmethod in fmethods){
print(paste(fmethod,dset))
favorableProps$dset[counter] <- dset
favorableProps$fmethod[counter] <- fmethod
idx = results$fmethod==fmethod & results$dset==dset
if (sum(idx)>0){
subresults <- results[idx,]
favorableProps$propBeatBase[counter] <- mean (subresults$mseBase>subresults$mseBayes)
favorableProps$propBeatMint[counter] <- mean (subresults$mseCombMint>subresults$mseBayes)
favorableProps$pValPropBeatMint[counter] <- binom.test(sum(subresults$mseCombMint>subresults$mseBayes), length(subresults$mseBayes))$p.value
favorableProps$medianBaseBayes[counter] <- median(subresults$mseBase / subresults$mseBayes)
favorableProps$medianMintBayes[counter] <- median(subresults$mseCombMint / subresults$mseBayes)
favorableProps$pValMedianMintBayes <- wilcox.test(log(subresults$mseCombMint / subresults$mseBayes))$p.value
favorableProps$propCorrBeatBase[counter] <- mean (subresults$mseBase>subresults$mseBayesCorr)
favorableProps$propCorrBeatMint[counter] <- mean (subresults$mseCombMint>subresults$mseBayesCorr)
favorableProps$pValPropCorrBeatMint[counter] <- binom.test(sum(subresults$mseCombMint>subresults$mseBayesCorr), length(subresults$mseBayesCorr))$p.value
favorableProps$medianBaseBayesCorr[counter]  <- median(subresults$mseBase / subresults$mseBayesCorr)
favorableProps$medianMintBayesCorr[counter] <- median(subresults$mseCombMint / subresults$mseBayesCorr)
favorableProps$pValMedianMintBayesCorr <- wilcox.test(log(subresults$mseCombMint / subresults$mseBayesCorr))$p.value
#generate the bplot with ggplot2
library(ggplot2)
pdfname <- paste("results/plot","_",dset,"_",fmethod,".pdf",sep = "")
denom <- subresults$mseBase
resLenght <- length(subresults$mseBase)
#old code, 3 models
# relMse <- rbind(matrix(subresults$mseCombMint/denom), matrix(subresults$mseBayes/denom), matrix(subresults$mseBayesCorr/denom))
# label <-  factor(rbind(matrix(rep("Mint",resLenght)),matrix(rep("Bayes",resLenght)),matrix(rep("Bayes (corr)",resLenght))),
# levels = c("Mint","Bayes","Bayes (corr)"))
#new code, 2 models (minT and Bayes corr)
relMse <- rbind(matrix(subresults$mseCombMint/denom), matrix(subresults$mseBayesCorr/denom))
label <-  factor(rbind(matrix(rep("MinT",resLenght)),matrix(rep("Bayes-corr",resLenght))),
levels = c("MinT","Bayes-corr"))
dataPlot <- as.data.frame(relMse)
dataPlot$label <- label
currentPlot <- ggplot(dataPlot, aes(x = label, y = log10(relMse))) + geom_boxplot()  +
stat_boxplot(geom = "errorbar", width = 0.5) +  #draw the whiskers
scale_x_discrete(name = "") +
scale_y_continuous(name = "Log (relative mse)")
scaling <- 1.8 #to avoid large outliers that make the boxplot unreadable
if (dset=="tourism"){
scaling<- 1.1
}
else if (fmethod=="ets"){
scaling<- 3
}
ylim1 = boxplot.stats(log(dataPlot$V1))$stats[c(1, 5)]
currentPlot = currentPlot + coord_cartesian(ylim = ylim1*scaling)  + geom_hline(yintercept = 0, color='darkblue', linetype="dashed")
print(currentPlot)
ggsave(pdfname, width = 4, height = 3)
counter <- counter + 1
}
parseHierResults_aggregatedH("infantgts")
dst
dset
fmethod
subresults
subresults$fmethod
wilcox.test(log(subresults$mseCombMint/subresults$mseBayes))
summary(log(subresults$mseCombMint/subresults$mseBayes))
summary(log(subresults$mseCombMint/subresults$mseBayes))$p.value
wilcox.test(log(subresults$mseCombMint/subresults$mseBayes))$p.value
favorableProps
countr
counter
debugSource('~/switchDrive/paperReconc/hierarchicalTimeSeries/code/hierTs/parseHierResults_aggregatedH.R')
parseHierResults_aggregatedH("infantgts")
library(hts)
?infantgts
summary(infantgts)
dset="tourism"
library(hts)
library(huge)
source("loadTourism.R")
hierTs <- loadTourism()
summary(hierTs)
parseHierResults_aggregatedH("tourism")
binom.test(52.1428)
binom.test(52,1428)
binom.test(round(.52*1428),1428)
binom.test(round(.47*1428),1428)
#parse the results of hierarchical non-temporal reconciliation on synthetic dataa set
#readt the mse, extract the proportion of favorable signs and the produces the boxplot
library(readr)
results <- read_csv(paste("results/mseHierReconcsynthetic.csv"))
keys <- unique(cbind(results$fmethod, results$synth_n, results$synthCorrel, results$howManyBottom)) #because some experiements on the cluste?r are duplicated
configs = dim(keys)[1]
#init the lists of results
summaryEachConfig <- data.frame(
howManyBottom=rep(-1,configs),
numExperiments=rep(-1,configs),
sampleSize=rep(-1,configs),
fmethod=rep("ets",configs),
bottomCorrelation=rep(-1,configs),
propDiagBeatBase=rep(-1,configs),
propDiagBeatMint=rep(-1,configs),
propCorrBeatBase=rep(-1,configs),
propCorrBeatMint=rep(-1,configs),
medianBaseBayes=rep(-1,configs),
medianBaseBayesCorr=rep(-1,configs),
medianMintBayes=rep(-1,configs),
medianMintBayesCorr=rep(-1,configs),
stringsAsFactors = FALSE
)
for (i in 1:dim(keys)[1]){
key=keys[i,]
idx = ( results$fmethod == key[1] &
results$synth_n == key[2] &
results$synthCorrel == key[3] &
results$howManyBottom == key[4])
subResults <- results[idx,]
summaryEachConfig$fmethod[i] <- key[1]
summaryEachConfig$sampleSize[i] <- key[2]
summaryEachConfig$numExperiments[i] <- sum(idx)
summaryEachConfig$bottomCorrelation[i] <- key[3]
summaryEachConfig$howManyBottom[i] <- key[4]
summaryEachConfig$propDiagBeatBase[i] <- mean(subResults$mseBayes<subResults$mseBase)
summaryEachConfig$propCorrBeatBase[i] <- mean(subResults$mseBayesCorr<subResults$mseBase)
summaryEachConfig$propDiagBeatMint[i] <- mean(subResults$mseBayes<subResults$mseCombMint)
summaryEachConfig$propCorrBeatMint[i] <- mean(subResults$mseBayesCorr<subResults$mseCombMint)
summaryEachConfig$medianBaseBayes[i] <- median(subResults$mseBase/subResults$mseBayes)
summaryEachConfig$medianBaseBayesCorr[i] <- median(subResults$mseBase/subResults$mseBayesCorr)
summaryEachConfig$medianMintBayes[i] <- median(subResults$mseCombMint/subResults$mseBayes)
summaryEachConfig$medianMintBayesCorr[i] <- median(subResults$mseCombMint/subResults$mseBayesCorr)
}
View(summaryEachConfig)
options(digits=2)
filename = paste("results/summarySynthetic.csv")
write.table(summaryEachConfig,file=filename,sep=",",row.names = FALSE)
#parse the results of hierarchical non-temporal reconciliation on synthetic dataa set
#readt the mse, extract the proportion of favorable signs and the produces the boxplot
library(readr)
results <- read_csv(paste("results/mseHierReconcsynthetic.csv"))
keys <- unique(cbind(results$fmethod, results$synth_n, results$synthCorrel, results$howManyBottom)) #because some experiements on the cluste?r are duplicated
keys
i <- 8
key=keys[i,]
key
idx = ( results$fmethod == key[1] &
results$synth_n == key[2] &
results$synthCorrel == key[3] &
results$howManyBottom == key[4])
subResults <- results[idx,]
summaryEachConfig$fmethod[i] <- key[1]
summaryEachConfig$sampleSize[i] <- key[2]
summaryEachConfig$numExperiments[i] <- sum(idx)
summaryEachConfig$bottomCorrelation[i] <- key[3]
summaryEachConfig$howManyBottom[i] <- key[4]
summaryEachConfig$propDiagBeatMint[i] <- mean(subResults$mseBayes<subResults$mseCombMint)
summaryEachConfig$propDiagBeatMint[i]
median(subResults$mseCombMint/subResults$mseBayes)
boxplot(subResults$mseCombMint/subResults$mseBayes)
boxplot(log(subResults$mseCombMint/subResults$mseBayes))
summary(log(subResults$mseCombMint/subResults$mseBayes))
summary(log(subResults$mseCombMint))
summary(log(subResults$mseBayes))
dim(subResults$mseBayes))
dim(subResults$mseBayes)
length(subResults$mseBayes)
boxplot(cbind(subResults$mseBayes,subResults$mseCombMint))
boxplot(cbind(subResults$mseBayes,subResults$mseCombMint), outline=FALSE)
sum(subResults$mseBayes<subResults$mseCombMint)
binom.test(86,311)
boxplot(subResults$mseBayes-subResults$mseCombMint, outline=FALSE)
summary(subResults$mseBayes)
debugSource('~/switchDrive/paperReconc/hierarchicalTimeSeries/code/hierTs/hierRec.R', echo=TRUE)
hierRec("synthetic",fmethod = "arima", synth_n = 200, synthCorrel = -0.8)
allts(test)[h,]
allts(fcastCombMint)
mean((fcastCombMint-allts(test)[h,])^2)
print(paste("mseCombMint",mseCombMint,"mseBayesCorr",mseBayesCorr))
debugSource('~/switchDrive/paperReconc/hierarchicalTimeSeries/code/hierTs/hierRec.R', echo=TRUE)
hierRec("synthetic",fmethod = "arima", synth_n = 200, synthCorrel = -0.8, seed = 1)
mseBayes
mseBayesCorr
mseCombMint
seed
mseBase
allts(test)[h,]
bayesRecon(correlation=FALSE)
preds
allts(fcastCombMint)[h,]
bayesRecon(correlation=TRUE)
numTs
model1 <- auto.arima(allTsTrain[,1])
model2 <- auto.arima(allTsTrain[,2])
model3 <- auto.arima(allTsTrain[,3])
residuals1 <- model1$x - model1$fitted
residuals2 <- model2$x - model2$fitted
residuals3 <- model3$x - model3$fitted
model1
model2
model3
mean(model3$x)
mean(model1$x)
mean(model2$x)
preds
cor(residuals1,residuals2)
cor(residuals1,residuals3)
cor(residuals2,residuals3)
sqrt(.4)
.2/sqrt(.4)
1.8/sqrt(3.6)
hierRec("synthetic",fmethod = "arima", synth_n = 200, synthCorrel = 0.8, seed = 1)
model1 <- auto.arima(allTsTrain[,1])
hierRec("synthetic",fmethod = "arima", synth_n = 200, synthCorrel = 0.8, seed = 1)
mseBayes
mseCombMint
model1 <- auto.arima(allTsTrain[,1])
model2 <- auto.arima(allTsTrain[,2])
model3 <- auto.arima(allTsTrain[,3])
residuals1 <- model1$x - model1$fitted
residuals2 <- model2$x - model2$fitted
residuals3 <- model3$x - model3$fitted
cor(residuals2,residuals3)
cor(residuals1,residuals3)
cor(residuals1,residuals2)
