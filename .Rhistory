correl <- priorCov %*% A %*%
solve (t(A) %*% priorCov %*% A + Sigma_y)
correl
dim(correl)
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/parseHierResults_aggregatedH.R')
parseHierResults_aggregatedH()
library(fpp2)
autoplot(eggs)
ggAcf(eggs)
autoplot(usdeaths)
ggAcf(usdeaths)
autoplot(usdeaths)
ggAcf(usdeaths)
autoplot(eggs)
ggAcf(eggs)
?ggAcf
ggAcf(eggs)
ggAcf(usdeaths)
library(fpp2)
ggAcf(usdeaths)
ggAcf(eggs)
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
dset="tourism"
h=1
fmethod="ets"
library(hts)
source("loadTourism.R")
#The buReconcile function computes the bu prediction given the predictions (1 x tot time series) and the S matrix
#(tot time series X bottom time series)
#predsAllTs is a flag: is set to true, the input preds contains predictions for all the hierarchy
#and the function retrieves the bottom series; if set to false, this is not needed
#as preds only contains only bottom time series
buReconcile <- function (preds,S, predsAllTs = FALSE) {
bottomPreds <- preds
if (predsAllTs) {
#retrieves the bottom prediction from all predictions
upperIdx <- 1 : (nrow(S) - ncol(S))
bottomIdx <- setdiff (1:nrow(S), upperIdx)
bottomPreds <- preds [,bottomIdx]
}
buPreds <- preds
#nrow(S) is the total number of time series
for (i in 1:nrow(S)){
buPreds[i] <- S[i,] %*% bottomPreds
}
return (buPreds)
}
hierMse <- function (htsPred, htsActual, h) {
#receives two hts objects, containing  forecast and actual value.
#computes the mse for the whole hierarchy.
mse <- mean  ( (allts(htsPred)[h,] - allts(htsActual)[h,])^2 )
return (mse)
}
#extract the time from the data set to then split into train / test (test set contains 25 or 5 time points)
set.seed(seed = 0)
hierTs <- loadTourism()
testSize <- 45
#if h=1, the possible preds are the whole test size lenght;
#if h=2, the possible preds are the (test size lenght -1); etc.
possiblePreds <- testSize - h + 1
iTest<-6
timeIdx             <- time(hierTs$bts[,1])
endTrain            <- length(timeIdx) - h - (iTest - 1)
train               <- window(hierTs, start = timeIdx[1], end = timeIdx[endTrain] )
test                <- window(hierTs, start =timeIdx[endTrain +1], end=timeIdx[endTrain + h])
fcastBu             <- forecast(train, h = h, method = "bu", fmethod = fmethod)
iTest <- 2
timeIdx             <- time(hierTs$bts[,1])
endTrain            <- length(timeIdx) - h - (iTest - 1)
train               <- window(hierTs, start = timeIdx[1], end = timeIdx[endTrain] )
test                <- window(hierTs, start =timeIdx[endTrain +1], end=timeIdx[endTrain + h])
fcastBu             <- forecast(train, h = h, method = "bu", fmethod = fmethod)
mseBu        <- hierMse(fcastBu, test, h )
mseBu
#recompute predictions to be easily accessed by the Bayesian method
allTsTrain <- allts(train)
numTs <- ncol(allTsTrain)
alpha <- 0.2
sigma <- vector(length = numTs)
preds <- vector(length = numTs)
#compute, for each  ts, predictions and sigma (h-steps ahead)
for (i in 1:numTs){
if (fmethod=="ets"){
model <- ets(allTsTrain[,i])
tmp <- forecast(model, h=h, level=1-alpha)
# print(paste(as.character(i),"/",as.character(numTs)))
# print(model$components)
}
else if (fmethod=="arima"){
model <- auto.arima(allTsTrain[,i])
tmp <- forecast(model, h=h, level=1-alpha)
}
preds[i] <- tmp$mean[h]
sigma[i] <- abs ( (tmp$mean[h] - tmp$upper[h])  / (qnorm(alpha / 2)) )
}
mseBase =  mean  ( (allts(test)[h,] - preds)^2 )
mseBase
S <- smatrix(train)
#Bayesian reconciliation
bottomIdx <- seq( nrow(S) - ncol(S) +1, nrow(S))
upperIdx <- setdiff(1:nrow(S),bottomIdx)
#prior mean and covariance of the bottom time series
priorMean <- preds[bottomIdx]
#prior mean and covariance of the upper time series
Y_vec <- preds[upperIdx]
Sigma_y <- matrix(nrow = length(upperIdx), ncol = length(upperIdx))
#prior covariance for the bottom time series
bottomVar <- sigma[bottomIdx]^2
priorCov <- diag(bottomVar)
#covariance for the upper time series
upperVar <- sigma[upperIdx]^2
Sigma_y <- diag(upperVar)
myPreds <- buReconcile(priorMean, S, predsAllTs = FALSE)
mean  ( (allts(test)[h,] - myPreds)^2 )
#==updating
#A explains how to combin the bottom series in order to obtain the
# upper series
A <- t(S[upperIdx,])
correl <- priorCov %*% A %*%
solve (t(A) %*% priorCov %*% A + Sigma_y)
postMean <- priorMean + correl  %*%
(Y_vec - t(A) %*% priorMean)
bayesPreds <- buReconcile(postMean, S, predsAllTs = FALSE)
mseBayes =  mean  ( (allts(test)[h,] - bayesPreds)^2 )
mseBase
mseBayes
scatter.smooth(bayesPreds, myPreds)
cbind(bayesPreds, myPreds)
mean((bayesPreds - myPreds)/myPreds)
deltaMae = abs  ( (allts(test)[h,] - bayesPreds)) - abs  ( (allts(test)[h,] - myPreds))
cbind(bayesPreds, myPreds, deltaMae)
a<-cbind(bayesPreds, myPreds, allts(test)[h,], deltaMae)
View(a)
mean(deltaMae>0)
mean(deltaMae<0)
mean(deltaMae)
boxplot(deltaMae)
summary(deltaMae)
deltaMae = abs  ( (allts(test)[h,] - bayesPreds)) - abs  ( (allts(test)[h,] - preds))
a<-cbind(bayesPreds, preds, allts(test)[h,], deltaMae)
View(a)
summary(deltaMae)
mean(deltaMae^2)
mean  ( (allts(test)[h,] - preds)^2 )
mean(deltaMae>0)
mean(deltaMae<0)
boxplot(deltaMae)
boxplot(deltaMae, outline = FALSE)
abline(0,0)
mean(a["bayesPreds"])
mean(a[,"bayesPreds"])
mean((a[,"bayesPreds"]-a[,"V3"])^2)
a[,"V3"]
colnames(a)
a<-as.data.frame(a)
a
colnames(a)
mean((a[,"bayesPreds"]-a[,"V3"])^2)
mean((a[,"preds"]-a[,"V3"])^2)
mean(deltaMae^2)
(deltaMae^2)
sum(deltaMae)
summary(hierTs)
allts(test)[h,]
sum( (allts(test)[h,2:77] - bayesPreds[2:77]))
sum( (allts(test)[h,2:77] - preds[2:77]))
sum( (allts(test)[h,1] - preds[1]))
sum( (allts(test)[h,1] - bayesPreds[1]))
scatter.smooth ( (allts(test)[h,2:77] , bayesPreds[2:77]))
plot ( (allts(test)[h,2:77] , bayesPreds[2:77]))
plot ( allts(test)[h,2:77] , bayesPreds[2:77])
scatter.smooth ( allts(test)[h,2:77] , bayesPreds[2:77])
mean(abs ( allts(test)[h,2:77] , bayesPreds[2:77]))
mean(abs ( allts(test)[h,2:77] - bayesPreds[2:77]))
mean(abs ( allts(test)[h,2:77] - preds[2:77]))
sum(preds[2:77])
sum(bayesPreds[2:77])
preds[1]
bayesPreds[1])
bayesPreds[1]
preds[1:77]
sigma[1:77]
Y_vec
Sigma_y
1612^2
h
sigma
sigma[1]
1612.261^2
Sigma_y[1,1]
diag(Sigma_y)
sum(diag(Sigma_y)[2:77])
fcastCombMint       <- forecast(train, h = h, method = "comb", weights="mint", fmethod=fmethod)
mean  ( (allts(test)[h,] - fcastCombMint)^2 )
mean  ( (allts(test)[h,] - allts(fcastCombMint))^2 )
a
colnames(a)<-c("bayesPreds","basePreds","actual","deltaMae")
View(a)
allts(fcastCombMint)
a$mintPreds<-allts(fcastCombMint)
a$deltaMae
colnames(a)<-c("bayesPreds","basePreds","actual","deltaMaeBase")
a
View(a)
a$mintPreds = allts(fcastCombMint)
dim(allts(fcastCombMint))
a$mintPreds = t(allts(fcastCombMint))
a
a$deltaMaeMin = abs(a$bayesPreds-a$actual) - abs(a$mintPreds-a$actual)
View(a)
colnames(a)<-c("bayesPreds","basePreds","actual","deltaMaeBase","mintPreds","deltaMaeMint")
a
View(a)
mean(a$deltaMaeMint>0)
summary(a$deltaMaeMint)
boxplot(a$deltaMaeMint)
median(a$deltaMaeMint)
mean(a$deltaMaeMint)
boxplot(a$deltaMaeBase)
boxplot(a$deltaMaeBase, outline = FALSE)
boxplot(a$deltaMaeMint)
boxplot(a$deltaMaeMint, outline=FALSE)
eig (t(A) %*% priorCov %*% A + Sigma_y)
eigen (t(A) %*% priorCov %*% A + Sigma_y)
eigen (t(A) %*% priorCov %*% A + Sigma_y, only.values = TRUE)
sum(abs(a$bayesPreds[2:77]-a$actual[2:77]))
sum(abs(a$basePreds[2:77]-a$actual[2:77]))
sum(abs(a$buPreds[2:77]-a$actual[2:77]))
sum(abs(a$mintPreds[2:77]-a$actual[2:77]))
#parse the results of hierarchical non-temporal reconciliation
#aggregating over different h, instead of treating them separately
#readt the mse, extract the proportion of favorable signs and the produces the boxplot
library(readr)
results <- read_csv("results/mseHierReconc.csv")
fmethods <- unique(results$fmethod)
dsets <- unique(results$dset)
# horizons <- unique(results$h)
configs <- length(fmethods) * length(dsets)
#we need first to instantiate the data frame with placeholder values, and then we fill the correct values
favorableProps <- data.frame(dset=rep(dsets[1],configs),
# h=rep(horizons[1],configs),
fmethod=rep(fmethods[1],configs),
propBeatBase=rep(-1,configs),
propBeatBu=rep(-1,configs),
propBeatComb=rep(-1,configs),
propBeatCombWls=rep(-1,configs),
propBeatMint=rep(-1,configs),
stringsAsFactors = FALSE
)
dset<-"tourism"
fmethod<-"ets"
# for (h in horizons){
print(paste(fmethod,dset))
favorableProps$dset[counter] <- dset
favorableProps$fmethod[counter] <- fmethod
counter<-1
# favorableProps$h[counter] <- h
idx = results$fmethod==fmethod & results$dset==dset #& results$h==h
subresults <- results[idx,]
mean (subresults$mseBase<subresults$mseCombMint)
mean (subresults$mseBase<subresults$mseBayes)
mean (subresults$mseBase<subresults$mseBu)
mean (subresults$mseBu<subresults$mseCombMint)
summary(hierTs)
hierTs
library(fpp2)
?ggseasonplot
?ggsubseriesplot
2*log(.5^2+3.625^2)+10
2*log(1^2+4.5^2)+6
2*log(.5^2+3.625^2)+10
?holt
y<-c(6,10)
2 * log (1^2+4.5^2) + 2*3
2 * log (0.5^2+3.625^2) + 2*5
qnorm(0.5)
qnorm(0.75)
qnorm(0.25)
alphaCalibration <- 0.5
quantile <- qnorm(1- (alphaCalibration/2) )
quantile
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
library(hts)
hier(infantgts)
hier("infantgts")
checkCalibration()
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
checkCalibration(preds, sigma, test)
hier("infantgts")
pnorm(0.76)
pnorm(0.67)
actual
ii
preds[ii]
stdQuant * sigmas[ii]
upper
lower
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
preds[ii]
upper <- preds[ii] + stdQuant * sigmas[ii]
lower <- preds[ii] - stdQuant * sigmas[ii]
upper
lower
sigmas[ii]
stdQuant
0.76 * 777
0.76 * 77
preds[ii]
upper
lower
stdQuant * sigmas[ii]
sigmas[ii]
stdQuant
included <- (actual[ii] > lower) &  (actual[ii] < upper)
included
currentAlpha <- 0.5
stdQuant <- qnorm(1- (currentAlpha/2) )
included <- vector(length = length(preds))
actual <- allts(htsActual)[h,]
for (ii in seq_along(preds)){
upper <- preds[ii] + stdQuant * sigmas[ii]
lower <- preds[ii] - stdQuant * sigmas[ii]
included <- (actual[ii] > lower) &  (actual[ii] < upper)
}
hier("infantgts")
included
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
for (ii in seq_along(preds)){
upper <- preds[ii] + stdQuant * sigmas[ii]
lower <- preds[ii] - stdQuant * sigmas[ii]
included[ii] <- (actual[ii] > lower) &  (actual[ii] < upper)
}
included
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier("infantgts")
included[ii]
included
mean(included)
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/batchHier.R')
batchHier()
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier("infantgts")
coverage <- 0.5
qnorm(1- (coverage/2) )
coverage <- 0.8
qnorm(1- (coverage/2) )
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier("infantgts")
preds[1]
sigma[1]
qnorm(.1)
1222-1.28*77
coverage
coverage<-0.8
stdQuant <- qnorm((1-coverage)/2)
included <- vector(length = length(preds))
actual <- allts(htsActual)[h,]
preds[ii] + stdQuant * sigmas[ii]
ii <- 1
upper <- preds[ii] + stdQuant * sigmas[ii]
upper
lower <- preds[ii] - stdQuant * sigmas[ii]
lower
stdQuant <- abs(qnorm((1-coverage)/2))
included <- vector(length = length(preds))
actual <- allts(htsActual)[h,]
upper <- preds[ii] + stdQuant * sigmas[ii]
lower <- preds[ii] - stdQuant * sigmas[ii]
upper
lower
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier("infantgts")
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/batchHier.R')
batchHier()
parseHierResults_eachH <- function (){
#parse the results of hierarchical non-temporal reconciliation
#readt the mse, extract the proportion of favorable signs and the produces the boxplot
library(readr)
results <- read_csv("results/mseHierReconc.csv")
fmethods <- unique(results$fmethod)
dsets <- unique(results$dset)
horizons <- unique(results$h)
configs <- length(fmethods) * length(dsets) * length(horizons)
#the 7 fields are fmethod, dset, prop against each method
# header <- c("dset","fmethod","h","propBeatBase","propBeatBu","propBeatComb",
# "propBeatCombWls","propBeatMint")
# favorableProps <- matrix(nrow = configs, ncol = length(header))
#we need first to instantiate the data frame with placeholder values, and then we fill the correct values
favorableProps <- data.frame(dset=rep(dsets[1],configs),
h=rep(horizons[1],configs),
fmethod=rep(fmethods[1],configs),
propBeatBase=rep(-1,configs),
propBeatBu=rep(-1,configs),
propBeatComb=rep(-1,configs),
propBeatCombWls=rep(-1,configs),
propBeatMint=rep(-1,configs),
stringsAsFactors = FALSE
)
counter <- 1
for (dset in dsets){
for (fmethod in fmethods){
for (h in horizons){
print(paste(fmethod,dset,h))
favorableProps$dset[counter] <- dset
favorableProps$fmethod[counter] <- fmethod
favorableProps$h[counter] <- h
idx = results$fmethod==fmethod & results$dset==dset & results$h==h
if (sum(idx)>0){
subresults <- results[idx,]
favorableProps$propBeatBase[counter] <- mean (subresults$mseBase>subresults$mseBayes)
# favorableProps$propBeatBu[counter] <- mean (subresults$mseBu>subresults$mseBayes)
# favorableProps$propBeatComb[counter] <- mean (subresults$mseComb>subresults$mseBayes)
# favorableProps$propBeatCombWls[counter] <- mean (subresults$mseCombWls>subresults$mseBayes)
favorableProps$propBeatMint[counter] <- mean (subresults$mseCombMint>subresults$mseBayes)
#generate the bplot with ggplot2
library(ggplot2)
pdfname <- paste("results/GGPLOThier","_",dset,"_",fmethod,"_h",h,".pdf",sep = "")
denom <- subresults$mseBase
resLenght <- length(subresults$mseBase)
# relMse <- rbind(matrix(subresults$mseBu/denom), matrix(subresults$mseCombWls/denom),
# matrix(subresults$mseCombMint/denom), matrix(subresults$mseBayes/denom))
relMse <- rbind(
# matrix(subresults$mseBu/denom), matrix(subresults$mseCombWls/denom),
matrix(subresults$mseCombMint/denom), matrix(subresults$mseBayes/denom))
# label <-  factor(rbind(matrix(rep("Bu",resLenght)),matrix(rep("CombWls",resLenght)),
#                        matrix(rep("Mint",resLenght)),matrix(rep("Bayes",resLenght))),
#                  levels = c("Bu","CombWls","Mint","Bayes"))
label <-  factor(rbind(matrix(rep("Mint",resLenght)),matrix(rep("Bayes",resLenght))),
levels = c("Mint","Bayes"))
dataPlot <- as.data.frame(relMse)
dataPlot$label <- label
currentPlot <- ggplot(dataPlot, aes(x = label, y = log10(relMse))) + geom_boxplot()  +
stat_boxplot(geom = "errorbar", width = 0.5) +  #draw the whiskers
scale_x_discrete(name = "") +
scale_y_continuous(name = "Log10 (MSE / MSE base) ")
print(currentPlot)
ggsave(pdfname, width = 4, height = 3)
counter <- counter + 1
}
write.table(favorableProps,file="results/hierFavorablePropsEachH.csv",sep=",",row.names = FALSE)
return (favorableProps)
}
parseHierResults_eachH()
#parse the results of hierarchical non-temporal reconciliation
#readt the mse, extract the proportion of favorable signs and the produces the boxplot
library(readr)
results <- read_csv("results/mseHierReconc.csv")
fmethods <- unique(results$fmethod)
dsets <- unique(results$dset)
horizons <- unique(results$h)
configs <- length(fmethods) * length(dsets) * length(horizons)
#we need first to instantiate the data frame with placeholder values, and then we fill the correct values
favorableProps <- data.frame(dset=rep(dsets[1],configs),
h=rep(horizons[1],configs),
fmethod=rep(fmethods[1],configs),
propBeatBase=rep(-1,configs),
# propBeatBu=rep(-1,configs),
# propBeatComb=rep(-1,configs),
# propBeatCombWls=rep(-1,configs),
propBeatMint=rep(-1,configs),
stringsAsFactors = FALSE
)
favorableProps
counter <- 1
for (dset in dsets){
for (fmethod in fmethods){
for (h in horizons){
print(paste(fmethod,dset,h))
favorableProps$dset[counter] <- dset
favorableProps$fmethod[counter] <- fmethod
favorableProps$h[counter] <- h
idx = results$fmethod==fmethod & results$dset==dset & results$h==h
if (sum(idx)>0){
subresults <- results[idx,]
favorableProps$propBeatBase[counter] <- mean (subresults$mseBase>subresults$mseBayes)
# favorableProps$propBeatBu[counter] <- mean (subresults$mseBu>subresults$mseBayes)
# favorableProps$propBeatComb[counter] <- mean (subresults$mseComb>subresults$mseBayes)
# favorableProps$propBeatCombWls[counter] <- mean (subresults$mseCombWls>subresults$mseBayes)
favorableProps$propBeatMint[counter] <- mean (subresults$mseCombMint>subresults$mseBayes)
#generate the bplot with ggplot2
library(ggplot2)
pdfname <- paste("results/GGPLOThier","_",dset,"_",fmethod,"_h",h,".pdf",sep = "")
denom <- subresults$mseBase
resLenght <- length(subresults$mseBase)
# relMse <- rbind(matrix(subresults$mseBu/denom), matrix(subresults$mseCombWls/denom),
# matrix(subresults$mseCombMint/denom), matrix(subresults$mseBayes/denom))
relMse <- rbind(
# matrix(subresults$mseBu/denom), matrix(subresults$mseCombWls/denom),
matrix(subresults$mseCombMint/denom), matrix(subresults$mseBayes/denom))
# label <-  factor(rbind(matrix(rep("Bu",resLenght)),matrix(rep("CombWls",resLenght)),
#                        matrix(rep("Mint",resLenght)),matrix(rep("Bayes",resLenght))),
#                  levels = c("Bu","CombWls","Mint","Bayes"))
label <-  factor(rbind(matrix(rep("Mint",resLenght)),matrix(rep("Bayes",resLenght))),
levels = c("Mint","Bayes"))
dataPlot <- as.data.frame(relMse)
dataPlot$label <- label
currentPlot <- ggplot(dataPlot, aes(x = label, y = log10(relMse))) + geom_boxplot()  +
stat_boxplot(geom = "errorbar", width = 0.5) +  #draw the whiskers
scale_x_discrete(name = "") +
scale_y_continuous(name = "Log10 (MSE / MSE base) ")
print(currentPlot)
ggsave(pdfname, width = 4, height = 3)
counter <- counter + 1
}
favorableProps
write.table(favorableProps,file="results/hierFavorablePropsEachH.csv",sep=",",row.names = FALSE)
options(digits=2)
write.table(favorableProps,file="results/hierFavorablePropsEachH.csv",sep=",",row.names = FALSE)
options(digits=2)
write.table(favorableProps,file="results/hierFavorablePropsEachH.csv",sep=",",row.names = FALSE)
options(digits=2)
write.table(favorableProps,file="results/hierFavorablePropsEachH.csv",sep=",",row.names = FALSE)
