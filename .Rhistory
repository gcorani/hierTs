}
totTs <- nrow(smatrix(hierTs))
maeBu <- matrix(nrow = testSize, ncol = totTs)
maeComb <- matrix(nrow = testSize, ncol = totTs)
maeCombWls <- matrix(nrow = testSize, ncol = totTs)
maeCombMint <- matrix(nrow = testSize, ncol = totTs)
maeBayes <- matrix(nrow = testSize, ncol = totTs)
for (iTest in 1:testSize){
timeIdx <- time(hierTs$bts[,1])
endTrain <- length(timeIdx) - iTest
train <- window(hierTs, start = timeIdx[1], end = timeIdx[endTrain] )
test <- window(hierTs, start =timeIdx[endTrain +1], end=timeIdx[endTrain + h])
fcastBu <- forecast(train, h = h, method = "bu")
fcastComb <- forecast(train, h = h, method = "comb", weights="ols")
fcastCombWls <- forecast(train, h = h, method = "comb", weights="wls")
fcastCombMint <- forecast(train, h = h, method = "comb", weights="mint")
maeBu[iTest,] <- accuracy(fcastBu, test)["MAE",]
maeComb[iTest,] <- accuracy(fcastComb, test)["MAE",]
maeCombWls[iTest,] <- accuracy(fcastCombWls, test)["MAE",]
maeCombMint[iTest,] <- accuracy(fcastCombMint, test)["MAE",]
allTsTrain <- allts(train)
numTs <- ncol(allTsTrain)
alpha <- 0.2
sigma <- vector(length = numTs)
preds <- matrix(nrow = h, ncol = numTs)
#now we compute predictions and their sigma for each trainign ts
for (i in 1:numTs){
model <- ets(ts(allTsTrain[,i]))
tmp <- forecast(model, h=1, level=1-alpha)
preds[h,i] <- tmp$mean[1]
#we  need the [1] to access the numerical information within a ts objects
sigma[i] <- abs ( (tmp$mean[1] - tmp$upper[1])  / (qnorm(alpha / 2)) )
}
S <- smatrix(train)
#debug code to check the bu implementation is correct
# buPreds <- buReconcile(preds, S, predsAllTs=TRUE)
# maeBu_gc = abs (allts(test) - buPreds)
# #unit test: is our bu consistent with hyndmand?
# consistent = matrix(maeBu_gc) == maeBu
# if (mean(consistent) < 1){
#   error("bu implementation not consistent")
# }
#Bayesian reconciliation
#p is the number of the bottom time series
bottomIdx <- seq( nrow(S) - ncol(S) +1, nrow(S))
upperIdx <- setdiff(1:nrow(S),bottomIdx)
p <- length(bottomIdx)
priorMean <- preds[bottomIdx]
priorCov <- matrix (nrow = p, ncol = p)
for (i in 1:p) {
priorCov[i,i] <- sigma[i]^2
}
priorCov[is.na(priorCov)] <- 0
#prior covariance is now instantiated
#now we start the updating with the forecast of each upper time series
for (i in 1:length(upperIdx)){
#get the matrix A of the linear map
#A states which are the time series to be summed
#in order to obtain the i-th upper time series
A <- S[i,]
mu_y <- preds[i]
var_y <- sigma[i]^2
correl <- priorCov %*% A %*%
solve (t(A) %*% priorCov %*% A + var_y)
priorMean <- priorMean +
correl  %*%
(mu_y - t(A) %*% priorMean)
priorCov <- priorCov - correl  %*% t(A) %*% priorCov
}
bayesPreds <- buReconcile(priorMean, S, predsAllTs = FALSE)
#now you need to reconstruct the bu predictions
maeBayes[iTest,] = abs (allts(test) - bayesPreds)
}
library(hts)
#computes the bu prediction given the predictions (1 x tot time series) and the S matrix
#(tot time series X bottom time series)
#predsAllTs is a flag: is set to true, the input preds contains predictions for all the hierarchy
#and the function retrieves the bottom series; if set to false, this is not needed
#as preds only contains only bottom time series
buReconcile <- function (preds,S, predsAllTs = FALSE) {
bottomPreds <- preds
if (predsAllTs) {
#retrive the bottom prediction from all predictions
upperIdx <- 1 : (nrow(S) - ncol(S))
bottomIdx <- setdiff (1:nrow(S), upperIdx)
bottomPreds <- preds [,bottomIdx]
}
buPreds <- preds
#nrow(S) is the total number of time series
for (i in 1:nrow(S)){
buPreds[i] <- S[i,] %*% bottomPreds
}
return (buPreds)
}
#for simplicity we run only 1-step ahead predictions
h=1
#extract the time from the data set to then split into train / test (test set contains 25 or 5 time points)
testSize <- 25
if (length(hierTs$bts[,1]) < 25){
testSize <- 5
}
totTs <- nrow(smatrix(hierTs))
maeBu <- matrix(nrow = testSize, ncol = totTs)
maeComb <- matrix(nrow = testSize, ncol = totTs)
maeCombWls <- matrix(nrow = testSize, ncol = totTs)
maeCombMint <- matrix(nrow = testSize, ncol = totTs)
maeBayes <- matrix(nrow = testSize, ncol = totTs)
iTest <- 1
timeIdx <- time(hierTs$bts[,1])
endTrain <- length(timeIdx) - iTest
train <- window(hierTs, start = timeIdx[1], end = timeIdx[endTrain] )
test <- window(hierTs, start =timeIdx[endTrain +1], end=timeIdx[endTrain + h])
fcastBu <- forecast(train, h = h, method = "bu")
fcastComb <- forecast(train, h = h, method = "comb", weights="ols")
fcastCombWls <- forecast(train, h = h, method = "comb", weights="wls")
fcastCombMint <- forecast(train, h = h, method = "comb", weights="mint")
maeBu[iTest,] <- accuracy(fcastBu, test)["MAE",]
accuracy(fcastBu, test)
a$percBetterBu
a$percBetterComb
a$percBetterCombWls
a$percBetterCombMint
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/example.R')
b <- example(infantgts)
b
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/example.R')
b <- example(infantgts)
b
b <- example(infantgts)
allts(test)
bayesPreds
(allts(test) - bayesPreds)^2
sqrt(allts(test) - bayesPreds)^2
sqrt((allts(test) - bayesPreds)^2)
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/example.R')
b <- example(infantgts)
b
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/example.R')
b <- example(infantgts)
b == a
a
a$maeBu == b$maeBu
a$maeBayes == b$maeBayes
a$maeCombMint == b$maeCombMint
a$maeBayes
class(a$maeBayes)
length(a$maeBayes)
25*17
a$maeBu
dim(a$maeBu)
25*27
a$maeBayes
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/example.R')
wilcox.test(a$maeBu,a$maeComb)
wilcox.test(a$maeBu,a$maeCombWls)
wilcox.test(a$maeBu,a$maeCombMint)
wilcox.test(a$maeBu,a$maeCombMint, alternative = "greater")
wilcox.test(a$maeBu,a$maeCombMint, alternative = "less")
wilcox.test(a$maeBu,a$maeCombWls, alternative = "less")
wilcox.test(a$maeBu,a$maeCombWls, alternative = "greater")
wilcox.test(a$maeBu,a$maeCombWls)
wilcox.test(a$maeBu,a$maeCombWls, alternative = "greater")
wilcox.test(a$maeBu,a$maeCombWls, alternative = "less")
mean(a$maeBu > a$maeCombWls)
wilcox.test(a$maeBu,a$maeBayes)
wilcox.test(a$maeComb,a$maeBayes)
wilcox.test(a$maeCombWls,a$maeBayes)
wilcox.test(a$maeCombMint,a$maeBayes)
boxplot(a$maeBu,a$maeBayes, a$maeCombWls)
boxplot(as.numeric(a$maeBu),as.numeric(a$maeBayes), as.numeric(a$maeCombWls))
boxplot(as.numeric(a$maeBu),as.numeric(a$maeBayes), as.numeric(a$maeCombWls), outline = FALSE)
infantgts
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/example.R')
b <- example(htseg1)
c <- example(htseg2)
b
c
b
a
resultsHtseg1 <- b
resultsHtseg2 <- c
resultsHtseg2 <- example(htseg2)
resultsHtseg1 <- example(htseg1)
resultsInfant <- example(infantgts)
?infantgts
resultsInfant <- example(infantgts)
example(infantgts)
?infant
?hts
infantgts
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/example.R')
example(infantgts)
res <- example(infantgts)
resultsInfant <- res
resultsInfant
save.image("~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/results.Rdata")
?hts
??hts
library(forecast)
?baggedETS
?hts
??hts
#given the hierTs data set,
library(hts)
library(tidyverse)
#computes the bu prediction given the predictions (1 x tot time series) and the S matrix
#(tot time series X bottom time series)
#predsAllTs is a flag: is set to true, the input preds contains predictions for all the hierarchy
#and the function retrieves the bottom series; if set to false, this is not needed
#as preds only contains only bottom time series
buReconcile <- function (preds,S, predsAllTs = FALSE) {
bottomPreds <- preds
if (predsAllTs) {
#retrive the bottom prediction from all predictions
upperIdx <- 1 : (nrow(S) - ncol(S))
bottomIdx <- setdiff (1:nrow(S), upperIdx)
bottomPreds <- preds [,bottomIdx]
}
buPreds <- preds
#nrow(S) is the total number of time series
for (i in 1:nrow(S)){
buPreds[i] <- S[i,] %*% bottomPreds
}
return (buPreds)
}
hierMae <- function (htsPred, htsActual) {
#receives two hts objects, containing  forecast and actual value.
#computes the mae for the relevant forecast horizon only
#Sets correctly the columns names
maeHts <- abs (allts(htsPred) - allts(htsActual))[h,]
maeHts <- data.frame(maeHts)
colnames(maeHts) <- colnames(allts(htsPred))
return (maeHts)
}
#extract the time from the data set to then split into train / test (test set contains 25 or 5 time points)
testSize <- 25
hierTs <- htseg2
h=2
#extract the time from the data set to then split into train / test (test set contains 25 or 5 time points)
testSize <- 25
if (length(hierTs$bts[,1]) < 25){
testSize <- 5
}
#if h=1, the possible preds are the whole test size lenght;
#if h=2, the possible preds are the (test size lenght -1); etc.
possiblePreds <- testSize - h + 1
totTs <- nrow(smatrix(hierTs))
maeBu <- matrix(nrow = possiblePreds, ncol = totTs)
maeComb <- matrix(nrow = possiblePreds, ncol = totTs)
maeCombWls <- matrix(nrow = possiblePreds, ncol = totTs)
maeCombMint <- matrix(nrow = possiblePreds, ncol = totTs)
maeBayes <- matrix(nrow = possiblePreds, ncol = totTs)
iTest <- 1
timeIdx <- time(hierTs$bts[,1])
endTrain <- length(timeIdx) - h - (iTest - 1)
train <- window(hierTs, start = timeIdx[1], end = timeIdx[endTrain] )
test <- window(hierTs, start =timeIdx[endTrain +1], end=timeIdx[endTrain + h])
fcastBu <- forecast (train, h = h, method = "bu")
fcastComb <- forecast (train, h = h, method = "comb", weights="ols")
fcastCombWls <- forecast (train, h = h, method = "comb", weights="wls")
fcastCombMint <- forecast (train, h = h, method = "comb", weights="mint")
htsPred <- fcastBu
htsActual <- test
#receives two hts objects, containing  forecast and actual value.
#computes the mae for the relevant forecast horizon only
#Sets correctly the columns names
maeHts <- abs (allts(htsPred) - allts(htsActual))[h,]
#receives two hts objects, containing  forecast and actual value.
#computes the mae for the relevant forecast horizon only
#Sets correctly the columns names
maeHts <- abs (allts(htsPred) - allts(htsActual))[h,]
#receives two hts objects, containing  forecast and actual value.
#computes the mae for the relevant forecast horizon only
#Sets correctly the columns names
maeHts <- abs (as.tibble(allts(htsPred)) - as.tibble(allts(htsActual))[h,]
maeHts <- abs (as.tibble(allts(htsPred))) - as.tibble(allts(htsActual)) [h,]
(as.tibble(allts(htsPred)))
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hierMae <- function (htsPred, htsActual) {
#receives two hts objects, containing  forecast and actual value.
#computes the mae for the relevant forecast horizon only
#Sets correctly the columns names currently not possible
maeHts <- abs (allts(htsPred) - allts(htsActual))[h,]
maeHts <- data.frame(maeHts)
# colnames(maeHts) <- colnames(allts(htsPred))
return (maeHts)
}
hierMae <- function (htsPred, htsActual) {
#receives two hts objects, containing  forecast and actual value.
#computes the mae for the relevant forecast horizon only
#Sets correctly the columns names currently not possible
maeHts <- abs (allts(htsPred) - allts(htsActual))[h,]
maeHts <- data.frame(maeHts)
# colnames(maeHts) <- colnames(allts(htsPred))
return (maeHts)
}
maeBu[iTest,] <- hierMae(fcastBu, test )
maeBu[iTest,]
maeBu
hierMae(fcastBu, test )
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hierMae <- function (htsPred, htsActual) {
#receives two hts objects, containing  forecast and actual value.
#computes the mae for the relevant forecast horizon only
#Sets correctly the columns names currently not possible
maeHts <- abs (allts(htsPred) - allts(htsActual))[h,]
# colnames(maeHts) <- colnames(allts(htsPred))
return (maeHts)
}
maeBu[iTest,] <- hierMae(fcastBu, test )
timeIdx <- time(hierTs$bts[,1])
endTrain <- length(timeIdx) - h - (iTest - 1)
train <- window(hierTs, start = timeIdx[1], end = timeIdx[endTrain] )
test <- window(hierTs, start =timeIdx[endTrain +1], end=timeIdx[endTrain + h])
fcastBu <- forecast (train, h = h, method = "bu")
fcastComb <- forecast (train, h = h, method = "comb", weights="ols")
fcastCombWls <- forecast (train, h = h, method = "comb", weights="wls")
fcastCombMint <- forecast (train, h = h, method = "comb", weights="mint")
hierMae(fcastBu, test )
class(hierMae(fcastBu, test ))
dim(hierMae(fcastBu, test ))
maeBu[iTest,]
maeBu
maeBu <- matrix(nrow = possiblePreds, ncol = totTs)
maeComb <- matrix(nrow = possiblePreds, ncol = totTs)
maeCombWls <- matrix(nrow = possiblePreds, ncol = totTs)
maeCombMint <- matrix(nrow = possiblePreds, ncol = totTs)
maeBayes <- matrix(nrow = possiblePreds, ncol = totTs)
maeBu[iTest,]
maeBu[iTest,] <- hierMae(fcastBu, test )
maeBu[iTest,]
maeBu
colnames(maeBu)
colnames(maeBu) <- colnames(allts(test))
maeBu
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
allTsTrain <- allts(train)
numTs <- ncol(allTsTrain)
alpha <- 0.2
sigma <- vector(length = numTs)
preds <- matrix(nrow = h, ncol = numTs)
i <- 1
model <- ets(ts(allTsTrain[,i]))
tmp <- forecast(model, h=1, level=1-alpha)
tmp
h
tmp <- forecast(model, h=h, level=1-alpha)
tmp
abs ( (tmp$mean[1] - tmp$upper[1])  / (qnorm(alpha / 2)) )
abs ( (tmp$mean[2] - tmp$upper[2])  / (qnorm(alpha / 2)) )
model
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
i
model <- ets(ts(allTsTrain[,i]))
tmp <- forecast(model, h=h, level=1-alpha)
preds <- matrix(nrow = possiblePreds, ncol = numTs)
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
tmp <- forecast(model, h=h, level=1-alpha)
tmp
tmp$mean
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
#compute, for each  ts, predictions and sigma (h-steps ahead)
for (i in 1:numTs){
model <- ets(ts(allTsTrain[,i]))
tmp <- forecast(model, h=h, level=1-alpha)
preds[h,i] <- tmp$mean[h]
#we  need the [1] to access the numerical information within a ts objects
sigma[i] <- abs ( (tmp$mean[h] - tmp$upper[h])  / (qnorm(alpha / 2)) )
}
sigma
preds
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
model <- ets(ts(allTsTrain[,i]))
tmp <- forecast(model, h=h, level=1-alpha)
preds[i] <- tmp$mean[h]
#we  need the [1] to access the numerical information within a ts objects
sigma[i] <- abs ( (tmp$mean[h] - tmp$upper[h])  / (qnorm(alpha / 2)) )
#compute, for each  ts, predictions and sigma (h-steps ahead)
for (i in 1:numTs){
model <- ets(ts(allTsTrain[,i]))
tmp <- forecast(model, h=h, level=1-alpha)
preds[i] <- tmp$mean[h]
#we  need the [1] to access the numerical information within a ts objects
sigma[i] <- abs ( (tmp$mean[h] - tmp$upper[h])  / (qnorm(alpha / 2)) )
}
S <- smatrix(train)
#Bayesian reconciliation
#p is the number of the bottom time series
bottomIdx <- seq( nrow(S) - ncol(S) +1, nrow(S))
upperIdx <- setdiff(1:nrow(S),bottomIdx)
p <- length(bottomIdx)
priorMean <- preds[bottomIdx]
priorCov <- matrix (nrow = p, ncol = p)
for (i in 1:p) {
priorCov[i,i] <- sigma[i]^2
}
priorCov[is.na(priorCov)] <- 0
#now we start the updating with the forecast of each upper time series
for (i in 1:length(upperIdx)){
#get the matrix A of the linear map
#A states which are the time series to be summed
#in order to obtain the i-th upper time series
A <- S[i,]
mu_y <- preds[i]
var_y <- sigma[i]^2
correl <- priorCov %*% A %*%
solve (t(A) %*% priorCov %*% A + var_y)
priorMean <- priorMean +
correl  %*%
(mu_y - t(A) %*% priorMean)
priorCov <- priorCov - correl  %*% t(A) %*% priorCov
}
bayesPreds <- buReconcile(priorMean, S, predsAllTs = FALSE)
abs (allts(test) - bayesPreds)
bayesPreds
allts(test)
bottomIdx
#Bayesian reconciliation
#p is the number of the bottom time series
bottomIdx <- seq( nrow(S) - ncol(S) +1, nrow(S))
upperIdx <- setdiff(1:nrow(S),bottomIdx)
p <- length(bottomIdx)
priorMean <- preds[bottomIdx]
priorCov <- matrix (nrow = p, ncol = p)
priorMean
priorCov
for (i in 1:p) {
priorCov[i,i] <- sigma[i]^2
}
priorCov[is.na(priorCov)] <- 0
bayesPreds <- buReconcile(priorMean, S, predsAllTs = FALSE)
bayesPreds
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
abs (allts(test)[h,] - bayesPreds)
maeBayes[iTest,] = abs (allts(test)[h,] - bayesPreds)
function (htseg1, h=1)
hier (htseg1, h=1)
setwd("~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs")
load("~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/results.Rdata")
resultsHtseg1
a <- hier (htseg1, h=2)
a <- hier (htseg1, h=1)
b <- hier (htseg1, h=2)
c <- hier (htseg1, h=3)
a$maeComb
b$maeComb
c$maeComb
d <- hier (htseg1, h=4)
e <- hier (htseg1, h=5)
d
e
htseg1
a
b
c
d
a <- hier (htseg2, h=1)
a
View(resultsHtseg2)
b <- hier (htseg2, h=2)
c <- hier (htseg2, h=3)
b
c <- hier (htseg2, h=3)
c
c <- hier (htseg2, h=4)
resultsHtseg1_h2 <- hier(htseg1,2)
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
resultsHtseg1_h2 <- hier(htseg1,2)
resultsHtseg1_h3 <- hier(htseg1,3)
resultsHtseg1 == hier(htseg1,1)
a<- hier(htseg1,1)
resultsHtseg1 == a
a
resultsHtseg1
resultsHtseg1[1] == a[1]
resultsHtseg1[[1]] == a[[1]]
resultsHtseg1[[5]] == a[[5]]
resultsHtseg1[[5]] == a[[6]]
resultsHtseg1[[6]] == a[[6]]
resultsHtseg2_h2 <- hier(htseg2,2)
resultsHtseg2[[5]] == hier(htseg2,1)[[5]]
resultsHtseg2_h3 <- hier(htseg2,3)
resultsHtseg2_h3
resultsInfant[[5]] == hier(infantgts, h=1)
resultsInfant[[5]] == hier(infantgts, h=1)[[5]]
resultsInfant
resultsInfant_h2 == hier(infantgts, h=2)
resultsInfant_h2 <- hier(infantgts, h=2)
resultsInfant_h2
View(resultsInfant_h2)
resultsInfant_h3 <- hier(infantgts, h=3)
View(resultsInfant_h3)
resultsInfant_h4 <- hier(infantgts, h=4)
View(resultsInfant_h4)
save.image("~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/results.RData")
?thief
install.packages(thief)
install.packages('thief', dependencies = TRUE)
?thief
??thief
library(hts)
?forecast.hts
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
"a"=="a"
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
a <- hier(htseg1)
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
a <- hier(htseg1)
load("~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/results.Rdata")
a[[5]]==resultsHtseg1[[5]]
a[[6]]==resultsHtseg1[[6]]
a[[7]]==resultsHtseg1[[7]]
