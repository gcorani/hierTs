configs
#we need first to instantiate the data frame with placeholder values, and then we fill the correct values
favorableProps <- data.frame(dset=rep(dsets[1],configs),
h=rep(horizons[1],configs),
fmethod=rep(fmethods[1],configs),
propBeatBase=rep(-1,configs),
# propBeatBu=rep(-1,configs),
# propBeatComb=rep(-1,configs),
# propBeatCombWls=rep(-1,configs),
propBeatMint=rep(-1,configs),
medianBaseBayes,
medianBaseMint,
stringsAsFactors = FALSE
)
#we need first to instantiate the data frame with placeholder values, and then we fill the correct values
favorableProps <- data.frame(dset=rep(dsets[1],configs),
h=rep(horizons[1],configs),
fmethod=rep(fmethods[1],configs),
propBeatBase=rep(-1,configs),
# propBeatBu=rep(-1,configs),
# propBeatComb=rep(-1,configs),
# propBeatCombWls=rep(-1,configs),
propBeatMint=rep(-1,configs),
medianBaseBayes=rep(-1,configs),
medianBaseMint=rep(-1,configs),
stringsAsFactors = FALSE
)
counter <- 1
for (dset in dsets){
for (fmethod in fmethods){
for (h in horizons){
print(paste(fmethod,dset,h))
favorableProps$dset[counter] <- dset
favorableProps$fmethod[counter] <- fmethod
favorableProps$h[counter] <- h
idx = results$fmethod==fmethod & results$dset==dset & results$h==h
if (sum(idx)>0){
subresults <- results[idx,]
favorableProps$propBeatBase[counter] <- mean (subresults$mseBase>subresults$mseBayes)
# favorableProps$propBeatBu[counter] <- mean (subresults$mseBu>subresults$mseBayes)
# favorableProps$propBeatComb[counter] <- mean (subresults$mseComb>subresults$mseBayes)
# favorableProps$propBeatCombWls[counter] <- mean (subresults$mseCombWls>subresults$mseBayes)
favorableProps$propBeatMint[counter] <- mean (subresults$mseCombMint>subresults$mseBayes)
medianBaseBayes <- median(subresults$mseBase / subresults$mseBayes)
medianBaseMint <- median(subresults$mseCombMint / subresults$mseBayes)
#generate the bplot with ggplot2
library(ggplot2)
pdfname <- paste("results/GGPLOThier","_",dset,"_",fmethod,"_h",h,".pdf",sep = "")
denom <- subresults$mseBase
resLenght <- length(subresults$mseBase)
# relMse <- rbind(matrix(subresults$mseBu/denom), matrix(subresults$mseCombWls/denom),
# matrix(subresults$mseCombMint/denom), matrix(subresults$mseBayes/denom))
relMse <- rbind(
# matrix(subresults$mseBu/denom), matrix(subresults$mseCombWls/denom),
matrix(subresults$mseCombMint/denom), matrix(subresults$mseBayes/denom))
# label <-  factor(rbind(matrix(rep("Bu",resLenght)),matrix(rep("CombWls",resLenght)),
#                        matrix(rep("Mint",resLenght)),matrix(rep("Bayes",resLenght))),
#                  levels = c("Bu","CombWls","Mint","Bayes"))
label <-  factor(rbind(matrix(rep("Mint",resLenght)),matrix(rep("Bayes",resLenght))),
levels = c("Mint","Bayes"))
dataPlot <- as.data.frame(relMse)
dataPlot$label <- label
currentPlot <- ggplot(dataPlot, aes(x = label, y = log10(relMse))) + geom_boxplot()  +
stat_boxplot(geom = "errorbar", width = 0.5) +  #draw the whiskers
scale_x_discrete(name = "") +
scale_y_continuous(name = "Log10 (MSE / MSE base) ")
#do not generate any longer the plot
# print(currentPlot)
# ggsave(pdfname, width = 4, height = 3)
counter <- counter + 1
}
options(digits=2)
write.table(favorableProps,file="results/hierFavorablePropsEachH.csv",sep=",",row.names = FALSE)
counter <- 1
for (dset in dsets){
for (fmethod in fmethods){
for (h in horizons){
print(paste(fmethod,dset,h))
favorableProps$dset[counter] <- dset
favorableProps$fmethod[counter] <- fmethod
favorableProps$h[counter] <- h
idx = results$fmethod==fmethod & results$dset==dset & results$h==h
if (sum(idx)>0){
subresults <- results[idx,]
favorableProps$propBeatBase[counter] <- mean (subresults$mseBase>subresults$mseBayes)
# favorableProps$propBeatBu[counter] <- mean (subresults$mseBu>subresults$mseBayes)
# favorableProps$propBeatComb[counter] <- mean (subresults$mseComb>subresults$mseBayes)
# favorableProps$propBeatCombWls[counter] <- mean (subresults$mseCombWls>subresults$mseBayes)
favorableProps$propBeatMint[counter] <- mean (subresults$mseCombMint>subresults$mseBayes)
medianBaseBayes[counter] <- median(subresults$mseBase / subresults$mseBayes)
medianBaseMint[counter] <- median(subresults$mseCombMint / subresults$mseBayes)
#generate the bplot with ggplot2
library(ggplot2)
pdfname <- paste("results/GGPLOThier","_",dset,"_",fmethod,"_h",h,".pdf",sep = "")
denom <- subresults$mseBase
resLenght <- length(subresults$mseBase)
# relMse <- rbind(matrix(subresults$mseBu/denom), matrix(subresults$mseCombWls/denom),
# matrix(subresults$mseCombMint/denom), matrix(subresults$mseBayes/denom))
relMse <- rbind(
# matrix(subresults$mseBu/denom), matrix(subresults$mseCombWls/denom),
matrix(subresults$mseCombMint/denom), matrix(subresults$mseBayes/denom))
# label <-  factor(rbind(matrix(rep("Bu",resLenght)),matrix(rep("CombWls",resLenght)),
#                        matrix(rep("Mint",resLenght)),matrix(rep("Bayes",resLenght))),
#                  levels = c("Bu","CombWls","Mint","Bayes"))
label <-  factor(rbind(matrix(rep("Mint",resLenght)),matrix(rep("Bayes",resLenght))),
levels = c("Mint","Bayes"))
dataPlot <- as.data.frame(relMse)
dataPlot$label <- label
currentPlot <- ggplot(dataPlot, aes(x = label, y = log10(relMse))) + geom_boxplot()  +
stat_boxplot(geom = "errorbar", width = 0.5) +  #draw the whiskers
scale_x_discrete(name = "") +
scale_y_continuous(name = "Log10 (MSE / MSE base) ")
#do not generate any longer the plot
# print(currentPlot)
# ggsave(pdfname, width = 4, height = 3)
counter <- counter + 1
}
options(digits=2)
write.table(favorableProps,file="results/hierFavorablePropsEachH.csv",sep=",",row.names = FALSE)
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/parseHierResults_eachH.R')
parseHierResults_eachH("infantgts")
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/parseHierResults_eachH.R')
parseHierResults_eachH("infantgts")
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/parseHierResults_eachH.R')
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/parseHierResults.R')
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/parseHierResults_aggregatedH.R')
filename=paste("results/hierFavorablePropsAggregatedH",dset,".csv",sep="")
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/parseHierResults_aggregatedH.R')
parseHierResults_aggregatedH("infantgts")
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/parseHierResults_aggregatedH.R')
parseHierResults_aggregatedH("infantgts")
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/parseHierResults_aggregatedH.R')
parseHierResults_aggregatedH("infantgts")
library(fpp2)
library(hts)
library(thief)
source("hier.R")
fmethod="ets"
perdiodType="monthyl"
perdiodType="monthly"
library(fpp2)
library(hts)
library(thief)
source("hier.R")
#computes mae for temporal hierarchies
#both actual and forecast are temporal hierarchies
#it  averages the  different time series having the same frequency
getHierMae <- function (actual, forecast) {
hierMae <- vector(length = length(forecast))
for (i in seq_along(forecast)) {
hierMae[i] <- mean( abs (forecast[[i]]$mean - actual[[i]]) )
}
return (hierMae)
}
globalMse <- function (actual, forecast) {
mse <- 0
for (i in seq_along(forecast)) {
mse <- mse + sum ( (forecast[[i]]$mean - actual[[i]])^2 )
}
return (mse)
}
#builds the A matrix, which indicates  which bottom time series sum up to each upper time series.
buildMatrix <- function() {
A <- matrix(data = 0, nrow = length(upperIdx), ncol = length(bottomIdx))
maxFreq <- frequency(trainHier[[1]])
counter <- 1
for (ii in (2:length(trainHier))){
currentFreq <- frequency(trainHier[[ii]])
aggregatedTs <- currentFreq
howManyBottomToSum <- maxFreq / currentFreq
offset <- 1
for (jj in (1:aggregatedTs)) {
A[counter, offset : (offset + howManyBottomToSum - 1)] <- 1
offset <- offset + howManyBottomToSum
counter <- counter + 1
}
return (t(A))
}
#coverage of the PI is 0.8
alpha <- 0.2
#default test set for the M3 is 18 months for the monthly (tp be adapted) and 8 quarters for the quarterly.
#for the moment force the test to be as long as exactly one period
#we should implement a mechanism for doing repeated predictions
train <- tsObj$x
trainHier <- tsaggregates(train)
#default test set for the M3 is 18 months for the monthly (tp be adapted) and 8 quarters for the quarterly.
#for the moment force the test to be as long as exactly one period
#we should implement a mechanism for doing repeated predictions
train <- tsObj$x
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/batchM3.R')
library(Mcomp)
source("thier.R")
if (type=="monthly"){
M3.selected <- subset(M3,12)
}
type="monthly"
M3.selected <- subset(M3,12)
tsObj<-M3.selected[[1]]
#computes mae for temporal hierarchies
#both actual and forecast are temporal hierarchies
#it  averages the  different time series having the same frequency
getHierMae <- function (actual, forecast) {
hierMae <- vector(length = length(forecast))
for (i in seq_along(forecast)) {
hierMae[i] <- mean( abs (forecast[[i]]$mean - actual[[i]]) )
}
return (hierMae)
}
globalMse <- function (actual, forecast) {
mse <- 0
for (i in seq_along(forecast)) {
mse <- mse + sum ( (forecast[[i]]$mean - actual[[i]])^2 )
}
return (mse)
}
#builds the A matrix, which indicates  which bottom time series sum up to each upper time series.
buildMatrix <- function() {
A <- matrix(data = 0, nrow = length(upperIdx), ncol = length(bottomIdx))
maxFreq <- frequency(trainHier[[1]])
counter <- 1
for (ii in (2:length(trainHier))){
currentFreq <- frequency(trainHier[[ii]])
aggregatedTs <- currentFreq
howManyBottomToSum <- maxFreq / currentFreq
offset <- 1
for (jj in (1:aggregatedTs)) {
A[counter, offset : (offset + howManyBottomToSum - 1)] <- 1
offset <- offset + howManyBottomToSum
counter <- counter + 1
}
return (t(A))
}
#coverage of the PI is 0.8
alpha <- 0.2
#default test set for the M3 is 18 months for the monthly (tp be adapted) and 8 quarters for the quarterly.
#for the moment force the test to be as long as exactly one period
#we should implement a mechanism for doing repeated predictions
train <- tsObj$x
trainHier <- tsaggregates(train)
timeIdx <- time(tsObj$xx)
test <- window(tsObj$xx, end=timeIdx[frequency(tsObj$xx)])
testHier <- tsaggregates(test)
# Compute forecasts one full season ahead
fc <- list()
i<-1
#how many test observations are available
h=length(testHier[[i]])
if (fmethod == "ets") {
fc[[i]] <- forecast(ets(trainHier[[i]]), h=h, level = (1-alpha), additive.only = TRUE)
}
# Reconcile forecasts using thief
thiefReconc <- reconcilethief(fc, comb = "struc")
fc[[1]]
# Reconcile forecasts using thief
thiefReconc <- reconcilethief(fc, comb = "struc")
trainHier[[1]]
frequency(trainHier[[1]])
buReconc <- reconcilethief(fc, comb = "bu")
# Compute forecasts one full season ahead
fc <- list()
# Compute forecasts one full season ahead
fc <- list()
for(i in seq_along(trainHier)){
#how many test observations are available
h=length(testHier[[i]])
if (fmethod == "ets") {
fc[[i]] <- forecast(ets(trainHier[[i]]), h=h, level = (1-alpha), additive.only = TRUE)
}
else if (fmethod == "arima") {
fc[[i]] <- forecast(auto.arima(trainHier[[i]]), h=h, , level = (1-alpha))
}
# Reconcile forecasts using thief
thiefReconc <- reconcilethief(fc, comb = "struc")
buReconc <- reconcilethief(fc, comb = "bu")
#Reconcile using the Bayesian approach
#how many predictions we manage within the hierarchy
numTs <- 0
for (i in seq_along(trainHier) ){
numTs <- numTs + frequency(trainHier[[i]])
}
#recover sigma and mean of each prediction
sigma <- vector(length = numTs)
preds <- vector(length = numTs)
offset <- 1
#fill the predictions
for (i in seq_along(fc)) {
currentLenght <- length(fc[[i]]$mean)
currentPreds <- fc[[i]]$mean
preds[offset: (offset + currentLenght - 1 )] <- currentPreds
offset <- offset + currentLenght
}
#fill the sigma
offset <- 0
for (i in seq_along(fc)) {
currentLenght <- length(fc[[i]]$mean)
#the sigma is different for each prediction, even if they are at the same level
for (j in 1:currentLenght) {
sigma[j + offset] <- abs ( (fc[[i]]$mean[j] - fc[[i]]$upper[j])  / (qnorm(alpha / 2)) )
}
offset <- offset + currentLenght
}
preds
sigma
testHier
testHier[[1]]
testHier[[2]]
testHier[[3]]
testHier[[4]]
vector(0,length = 5)
vector(rep(0,5))
vector(data=rep(0,5))
as.vector(rep(0,5))
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/parseHierResults_aggregatedH.R')
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/parseHierResults_eachH.R')
parseHierResults_eachH("infantgts")
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/parseHierResults_eachH.R')
parseHierResults_aggregatedH("infantgts")
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/parseHierResults_aggregatedH.R')
parseHierResults_aggregatedH("infantgts")
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/parseHierResults_aggregatedH.R')
parseHierResults_aggregatedH("infantgts")
parseHierResults_eachH("infantgts")
parseHierResults_aggregatedH("tourism")
parseHierResults_eachH("tourism")
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/parseHierResults_eachH.R')
parseHierResults_eachH("infantgts")
parseHierResults_eachH("tourism")
library(Mcomp)
source("thier.R")
type
type<-"monthyl"
type<-"monthly"
M3.selected <- subset(M3,12)
fmethod="ets"
periodType=type
M3.selected[[i]]
tsObj<-M3.selected[[1]]
library(fpp2)
library(hts)
library(thief)
source("hier.R")
#computes mae for temporal hierarchies
#both actual and forecast are temporal hierarchies
#it  averages the  different time series having the same frequency
getHierMae <- function (actual, forecast) {
hierMae <- vector(length = length(forecast))
for (i in seq_along(forecast)) {
hierMae[i] <- mean( abs (forecast[[i]]$mean - actual[[i]]) )
}
return (hierMae)
}
globalMse <- function (actual, forecast) {
mse <- 0
for (i in seq_along(forecast)) {
mse <- mse + sum ( (forecast[[i]]$mean - actual[[i]])^2 )
}
return (mse)
}
#builds the A matrix, which indicates  which bottom time series sum up to each upper time series.
buildMatrix <- function() {
A <- matrix(data = 0, nrow = length(upperIdx), ncol = length(bottomIdx))
maxFreq <- frequency(trainHier[[1]])
counter <- 1
for (ii in (2:length(trainHier))){
currentFreq <- frequency(trainHier[[ii]])
aggregatedTs <- currentFreq
howManyBottomToSum <- maxFreq / currentFreq
offset <- 1
for (jj in (1:aggregatedTs)) {
A[counter, offset : (offset + howManyBottomToSum - 1)] <- 1
offset <- offset + howManyBottomToSum
counter <- counter + 1
}
return (t(A))
}
#coverage of the PI is 0.8
alpha <- 0.2
#default test set for the M3 is 18 months for the monthly (tp be adapted) and 8 quarters for the quarterly.
#for the moment force the test to be as long as exactly one period
#we should implement a mechanism for doing repeated predictions
train <- tsObj$x
trainHier <- tsaggregates(train)
timeIdx <- time(tsObj$xx)
test <- window(tsObj$xx, end=timeIdx[frequency(tsObj$xx)])
testHier <- tsaggregates(test)
# Compute forecasts one full season ahead
fc <- list()
for(i in seq_along(trainHier)){
#how many test observations are available
h=length(testHier[[i]])
if (fmethod == "ets") {
fc[[i]] <- forecast(ets(trainHier[[i]]), h=h, level = (1-alpha), additive.only = TRUE)
}
else if (fmethod == "arima") {
fc[[i]] <- forecast(auto.arima(trainHier[[i]]), h=h, , level = (1-alpha))
}
# Reconcile forecasts using thief
thiefReconc <- reconcilethief(fc, comb = "struc")
buReconc <- reconcilethief(fc, comb = "bu")
c
fc
#Reconcile using the Bayesian approach
#how many predictions we manage within the hierarchy
numTs <- 0
for (i in seq_along(trainHier) ){
numTs <- numTs + frequency(trainHier[[i]])
}
#recover sigma and mean of each prediction
sigma <- vector(length = numTs)
preds <- vector(length = numTs)
offset <- 1
#fill the predictions
for (i in seq_along(fc)) {
currentLenght <- length(fc[[i]]$mean)
currentPreds <- fc[[i]]$mean
preds[offset: (offset + currentLenght - 1 )] <- currentPreds
offset <- offset + currentLenght
}
#fill the sigma
offset <- 0
for (i in seq_along(fc)) {
currentLenght <- length(fc[[i]]$mean)
#the sigma is different for each prediction, even if they are at the same level
for (j in 1:currentLenght) {
sigma[j + offset] <- abs ( (fc[[i]]$mean[j] - fc[[i]]$upper[j])  / (qnorm(alpha / 2)) )
}
offset <- offset + currentLenght
}
#the time series in the first element of the list are the bottom ones.
priorMean <- fc[[1]]$mean
preds
sigma
testHier
testHier[[1]]
testHier[[2]]
fc
class(fc)
hierTes
testHier
getHierMae(testHier,fc)
a <- getHierMae(testHier,fc)
hierMae <- vector(length = length(forecast))
i<-1
forecast[[i]]$mean
coverage=0.8
stdQuant <- abs(qnorm((1-coverage)/2))
actual <- testHier
forecast <- fc
fc
ii <- 1
upper <- forecast[ii] + stdQuant * sigmas[ii]
sigmas<-sigma
upper <- forecast[ii] + stdQuant * sigmas[ii]
forecast[ii]
class(forecast[ii])
class(forecast[1])
forecast[1]
forecast[[1]]
class(forecast[[1]])
forecast[[1]]$upper
length(sigmas)
length(forecast[[1]])
# Compute forecasts one full season ahead
fc <- list()
for(i in seq_along(trainHier)){
#how many test observations are available
h=length(testHier[[i]])
if (fmethod == "ets") {
# fc[[i]] <- forecast(ets(trainHier[[i]]), h=h, level = (1-alpha), additive.only = TRUE)
fc[[i]] <- forecast(ets(trainHier[[i]]), h=h, level = c(0.5,0.8), additive.only = TRUE)
}
else if (fmethod == "arima") {
fc[[i]] <- forecast(auto.arima(trainHier[[i]]), h=h, , level = (1-alpha))
}
fc[[i]]
fc[[i]]$mean
fc[[i]]$upper
fc[[i]]$upper["50%"]
fc[[i]]$upper[,"50%"]
a<-fc[[i]]$upper[,"50%"]
a
as.numeric(<-fc[[i]]$upper[,"50%"]
as.numeric(fc[[i]]$upper[,"50%"])
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
type="monthly"
fmethod="ets"
library(readr)
filename <- paste("results/temporalHier","_",type,"_",fmethod,".csv",sep = "")
results <- read_csv(filename)
if (type=="weekly"){
warning("the AE experiment is only over 13 time series")
freqs <- c("_Weekly","_2-Weekly","_4-Weekly","_Quarterly","_Biannual","_Annual")
}
if (type=="monthly"){
freqs <- c("_Monthly","_2-Monthly","_4-Monthly","_Biannual","_Annual")
}
else if (type=="quarterly"){
freqs <- c("Quarterly","_Biannual","_Annual")
}
names <- colnames(results)
baseMethods <- c("Bu","Thief")
myMethod <-"Bayes"
comparisons <- length(freqs) * length (baseMethods)
improvIndicator <- matrix(0, ncol = comparisons, nrow = nrow(results))
improvNames <- vector(length = comparisons)
favorableSign <- vector(length = comparisons)
pValueSign <- vector(length = comparisons)
meanImprovement <- vector(length = comparisons)
isMseImproved  <- vector(length = comparisons)
mseImprovement  <- vector(length = comparisons)
counter <- 1
baseMethods
