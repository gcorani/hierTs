for (i in seq_along(forecast)) {
hierMae[i] <- mean( abs (forecast[[i]]$mean - actual[[i]]) )
}
return (tHierMae)
}
#coverage of the PI is 0.8
alpha <- 0.2
#both lines temporary
ts <- usdeaths
tsName <- "pippo"
#predict one full season ahead (12 months or 4 quarters etc)
timeIdx <- time(ts)
endTrain <- length(timeIdx) - frequency(ts)
train <- window(ts, start = timeIdx[1], end = timeIdx[endTrain] )
test <- window(ts, start =timeIdx[endTrain +1])
trainTs <- tsaggregates(train)
testTs <- tsaggregates(test)
# Compute forecasts one full season ahead
fc <- list()
for(i in seq_along(trainTs)){
if (fmethod == "ets") {
fc[[i]] <- forecast(ets(trainTs[[i]]), h=frequency(trainTs[[i]]), level = (1-alpha))
}
else if (fmethod == "arima") {
fc[[i]] <- forecast(auto.arima(aggts[[i]]), h=2*frequency(aggts[[i]]))
}
fmethod<-"ets"
for(i in seq_along(trainTs)){
if (fmethod == "ets") {
fc[[i]] <- forecast(ets(trainTs[[i]]), h=frequency(trainTs[[i]]), level = (1-alpha))
}
else if (fmethod == "arima") {
fc[[i]] <- forecast(auto.arima(aggts[[i]]), h=2*frequency(aggts[[i]]))
}
# Reconcile forecasts using thief
thiefReconc <- reconcilethief(fc, comb = "struc")
buReconc <- reconcilethief(fc, comb = "bu")
#Reconcile using the Bayesian approach
#how many predictions we manage within the hierarchy
numTs <- 0
for (i in seq_along(trainTs) ){
numTs <- numTs + frequency(trainTs[[i]])
}
#recover sigma and mean of each prediction
sigma <- vector(length = numTs)
preds <- vector(length = numTs)
offset <- 1
#fill the predictions
for (i in seq_along(fc)) {
currentLenght <- length(fc[[i]]$mean)
currentPreds <- fc[[i]]$mean
preds[offset: (offset + currentLenght - 1 )] <- currentPreds
offset <- offset + currentLenght
}
currentPreds
pred
preds
#fill the sigma TO BE DEBUGGED
offset <- 0
for (i in seq_along(fc)) {
currentLenght <- length(fc[[i]]$mean)
#the sigma is different for each prediction, even if they are at the same level
for (j in seq_along(fc[[1]])){
sigma[j + offset] <- abs ( (fc[[i]]$mean[j] - fc[[i]]$upper[j])  / (qnorm(alpha / 2)) )
}
offset <- offset + length(time(fc[[i]]$mean))
}
sigma
#fill the sigma TO BE DEBUGGED
offset <- 0
i <- 1
currentLenght <- length(fc[[i]]$mean)
fc[[1]]
(fc[[1]]$mean - fc[[1]]$upper)/1.28
#the sigma is different for each prediction, even if they are at the same level
for (j in seq_along(fc[[1]])){
sigma[j + offset] <- abs ( (fc[[i]]$mean[j] - fc[[i]]$upper[j])  / (qnorm(alpha / 2)) )
}
simga
sigms
sigma
fc[[1]]
length(fc[[1]])
length(fc[[1]]$mean)
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
#recover sigma and mean of each prediction
sigma <- vector(length = numTs)
#fill the sigma TO BE DEBUGGED
offset <- 0
i <- 1
currentLenght <- length(fc[[i]]$mean)
#the sigma is different for each prediction, even if they are at the same level
for (j in 1:currentLenght) {
sigma[j + offset] <- abs ( (fc[[i]]$mean[j] - fc[[i]]$upper[j])  / (qnorm(alpha / 2)) )
}
sigma
for (i in seq_along(fc)) {
currentLenght <- length(fc[[i]]$mean)
#the sigma is different for each prediction, even if they are at the same level
for (j in 1:currentLenght) {
sigma[j + offset] <- abs ( (fc[[i]]$mean[j] - fc[[i]]$upper[j])  / (qnorm(alpha / 2)) )
}
offset <- offset + currentLenght
}
sigma
fc[[2]]
(fc[[2]]$mean-fc[[2]]$upper)/1.28
(fc[[5]]$mean-fc[[5]]$upper)/1.28
(fc[[6]]$mean-fc[[6]]$upper)/1.28
fc[[5]]
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
thier()
reconcilethief()
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
freq <- unlist(lapply(fc,frequency))
freq
fc
lapply(fc,frequency))
lapply(fc,frequency)
lapply(trainTs,frequency)
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
#setup the S matrix (code from combine.R of thief package)
freq <- unlist(lapply(trainTs,frequency))
freq
m <- max(freq)
m
?rev
nsum <- rev(rep(m/freq, freq))
nsum
unsum <- unique(nsum)
grps <- matrix(0, nrow=length(unsum)-1, ncol=m)
grps
for(i in 1:(length(unsum)-1))
{
mi <- m/unsum[i]
grps[i,] <- rep(1:mi, rep(unsum[i],mi))
}
grps
?MinT
freq
fc[[1]]
fc[[2]]
fc[[3]]
fc[[4]]
fc[[5]]
fc[[6]]
grps
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
# Set up matrix of forecasts in right structure
nc <- length(fc[[1]])/m
fmat <- matrix(0, nrow=0, ncol=nc)
for(i in rev(seq_along(fc)))
fmat
fmat <- matrix(0, nrow=0, ncol=nc)
for(i in rev(seq_along(fc)))
i <- 1
# Set up matrix of forecasts in right structure
nc <- length(fc[[1]])/m
fmat <- matrix(0, nrow=0, ncol=nc)
for(i in rev(seq_along(fc)))
i
matrix(fc[[i]], ncol=nc)
class(fc)
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
#CODE FROM THIED
forecasts <- list()
for(i in seq_along(fc))
for(i in seq_along(fc)){
forecasts[[i]] <- fc[[i]]$mean
}
#CODE FROM THIED
forecasts <- list()
for(i in seq_along(fc)){
forecasts[[i]] <- fc[[i]]$mean
}
# Set up matrix of forecasts in right structure
nc <- length(fc[[1]])/m
fmat <- matrix(0, nrow=0, ncol=nc)
for(i in rev(seq_along(fc)))
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
# Set up matrix of forecasts in right structure
nc <- length(fc[[1]])/m
fmat <- matrix(0, nrow=0, ncol=nc)
for(i in rev(seq_along(fc)))
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
# Set up matrix of forecasts in right structure
nc <- length(fc[[1]])/m
fmat <- matrix(0, nrow=0, ncol=nc)
for(i in rev(seq_along(fc))){
fmat <- rbind(fmat, matrix(forecasts[[i]], ncol=nc))
}
forecasts[[i]]
nc
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
library(fpp2)
library(hts)
library(thief)
source("hier.R")
#computes mae for temporal hierarchies
#both actual and forecast are temporal hierarchies
tHierMae <- function (actual, forecast){
hierMae <- vector(length = length(forecast))
for (i in seq_along(forecast)) {
hierMae[i] <- mean( abs (forecast[[i]]$mean - actual[[i]]) )
}
return (tHierMae)
}
#coverage of the PI is 0.8
alpha <- 0.2
#both lines temporary
ts <- usdeaths
tsName <- "pippo"
#predict one full season ahead (12 months or 4 quarters etc)
timeIdx <- time(ts)
endTrain <- length(timeIdx) - frequency(ts)
train <- window(ts, start = timeIdx[1], end = timeIdx[endTrain] )
test <- window(ts, start =timeIdx[endTrain +1])
trainTs <- tsaggregates(train)
testTs <- tsaggregates(test)
# Compute forecasts one full season ahead
fc <- list()
for(i in seq_along(trainTs)){
if (fmethod == "ets") {
fc[[i]] <- forecast(ets(trainTs[[i]]), h=frequency(trainTs[[i]]), level = (1-alpha))
}
else if (fmethod == "arima") {
fc[[i]] <- forecast(auto.arima(aggts[[i]]), h=2*frequency(aggts[[i]]))
}
fmethod <- "ets"
for(i in seq_along(trainTs)){
if (fmethod == "ets") {
fc[[i]] <- forecast(ets(trainTs[[i]]), h=frequency(trainTs[[i]]), level = (1-alpha))
}
else if (fmethod == "arima") {
fc[[i]] <- forecast(auto.arima(aggts[[i]]), h=2*frequency(aggts[[i]]))
}
# Reconcile forecasts using thief
thiefReconc <- reconcilethief(fc, comb = "struc")
buReconc <- reconcilethief(fc, comb = "bu")
#Reconcile using the Bayesian approach
#how many predictions we manage within the hierarchy
numTs <- 0
for (i in seq_along(trainTs) ){
numTs <- numTs + frequency(trainTs[[i]])
}
#recover sigma and mean of each prediction
sigma <- vector(length = numTs)
preds <- vector(length = numTs)
offset <- 1
#fill the predictions
for (i in seq_along(fc)) {
currentLenght <- length(fc[[i]]$mean)
currentPreds <- fc[[i]]$mean
preds[offset: (offset + currentLenght - 1 )] <- currentPreds
offset <- offset + currentLenght
}
#fill the sigma TO BE DEBUGGED
offset <- 0
for (i in seq_along(fc)) {
currentLenght <- length(fc[[i]]$mean)
#the sigma is different for each prediction, even if they are at the same level
for (j in 1:currentLenght) {
sigma[j + offset] <- abs ( (fc[[i]]$mean[j] - fc[[i]]$upper[j])  / (qnorm(alpha / 2)) )
}
offset <- offset + currentLenght
}
#setup the S matrix (code from combine.R of thief package)
freq <- unlist(lapply(trainTs,frequency))
m <- max(freq)
nsum <- rev(rep(m/freq, freq))
unsum <- unique(nsum)
grps <- matrix(0, nrow=length(unsum)-1, ncol=m)
for(i in 1:(length(unsum)-1))
grps
for(i in 1:(length(unsum)-1))
i <- 1
m/unsum[i]
grps[i,] <- rep(1:mi, rep(unsum[i],mi))
mi <- m/unsum[i]
grps[i,] <- rep(1:mi, rep(unsum[i],mi))
length(unsum)-1
i <- 2
mi <- m/unsum[i]
grps[i,] <- rep(1:mi, rep(unsum[i],mi))
grps
i<-3
mi <- m/unsum[i]
grps[i,] <- rep(1:mi, rep(unsum[i],mi))
i<-4
mi <- m/unsum[i]
grps[i,] <- rep(1:mi, rep(unsum[i],mi))
i <- 5
mi <- m/unsum[i]
grps[i,] <- rep(1:mi, rep(unsum[i],mi))
mi
grps
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
fc[[1]]
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
#the time series in the first element of the list are the bottom ones.
priorMean <- fc[[1]]$mean
#prior covariance for the bottom time series
bottomIdx <- 1:length(fc[[1]]$mean)
bottomVar <- sigma[bottomIdx]^2
priorCov <- diag(bottomVar)
priorCov
sigma^2
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
upperIdx <- setdiff(1:numTs,bottomIdx)
upperIdx
grps
trainTs[[1]]
class(trainTs[[1]])
class(trainTs[[2]])
frequency(trainTs[[2]])
frequency(trainTs[[3]])
frequency(trainTs[[4]])
frequency(trainTs[[5]])
upperIdx
fc[[1]]
fc[[2]]
fc[[3]]
fc[[]]
fc[[2]]
frequency(fc[[2]])
fc[[2]]
trainTs[[1]]
trainTs[[2]]
fc[[2]]
frequency(trainTs[[2]])
maxFreq <- frequency(trainTs[[1]])
maxFreq
for (seq_along(1:aggregatedTs))
aggregatedTs<-5
for (seq_along(1:aggregatedTs)) print("a")
for (seq_along(aggregatedTs)) print("a")
for (seq_along(1:aggregatedTs)) print("a")
for A <- matrix(nrow = length(upperIdx), ncol = length(bottomIdx))(seq_along(1:aggregatedTs)) print("a")
A <- matrix(nrow = length(upperIdx), ncol = length(bottomIdx))
A
?matrix
A <- matrix(nrow = length(upperIdx), ncol = length(bottomIdx), data=0)
A
A <- matrix(data = 0, nrow = length(upperIdx), ncol = length(bottomIdx))
maxFreq <- frequency(trainTs[[1]])
counter <- 1
for (ii in (2:length(trainTs))){
currentFreq <- frequency(trainTs[[ii]])
aggregatedTs <- maxFreq / currentFreq
offset <- 1
for (jj in (1:aggregatedTs)) {
A[counter, offset : (offset + currentFreq - 1)] <- 1
offset <- offset + currentFreq
counter <- counter + 1
}
currentFreq
currentFreq <- frequency(trainTs[[ii]])
aggregatedTs <- maxFreq / currentFreq
aggregatedTs
maxFreq
currentFreq
ii <- 2
currentFreq <- frequency(trainTs[[ii]])
aggregatedTs <- maxFreq / currentFreq
offset <- 1
for (jj in (1:aggregatedTs)) {
A[counter, offset : (offset + currentFreq - 1)] <- 1
offset <- offset + currentFreq
counter <- counter + 1
}
jj <- 1
A[counter, offset : (offset + currentFreq - 1)] <- 1
offset : (offset + currentFreq - 1)
counter
counter <- 1
A[counter, offset : (offset + currentFreq - 1)] <- 1
offset <- offset + currentFreq
counter <- counter + 1
A[counter, offset : (offset + currentFreq - 1)] <- 1
offset <- offset + currentFreq
counter <- counter + 1
A
A <- matrix(data = 0, nrow = length(upperIdx), ncol = length(bottomIdx))
maxFreq <- frequency(trainTs[[1]])
counter <- 1
ii <- 1
currentFreq <- frequency(trainTs[[ii]])
aggregatedTs <- maxFreq / currentFreq
offset <- 1
jj <- 1
A[counter, offset : (offset + currentFreq - 1)] <- 1
offset <- offset + currentFreq
counter <- counter + 1
A[counter, offset : (offset + currentFreq - 1)] <- 1
offset <- offset + currentFreq
offsert
offset
currentFreq
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
thier()
A
aggregatedTs
maxFreq
currentFreq
aggregatedTs
ii
trainTs[[6]]
length(upperIfx)
length(upperIdx)
maxFreq
#builds the A matrix, which indicates  which bottom time series sum up to each upper time series.
buildMatrix <- function() {
A <- matrix(data = 0, nrow = length(upperIdx), ncol = length(bottomIdx))
maxFreq <- frequency(trainTs[[1]])
counter <- 1
for (ii in (2:length(trainTs))){
currentFreq <- frequency(trainTs[[ii]])
aggregatedTs <- currentFreq
howManyBottomToSum <- maxFreq / currentFreq
offset <- 1
for (jj in (1:aggregatedTs)) {
A[counter, offset : (offset + howManyBottomToSum - 1)] <- 1
offset <- offset + howManyBottomToSum
counter <- counter + 1
}
#builds the A matrix, which indicates  which bottom time series sum up to each upper time series.
buildMatrix <- function() {
A <- matrix(data = 0, nrow = length(upperIdx), ncol = length(bottomIdx))
maxFreq <- frequency(trainTs[[1]])
counter <- 1
for (ii in (2:length(trainTs))){
currentFreq <- frequency(trainTs[[ii]])
aggregatedTs <- currentFreq
howManyBottomToSum <- maxFreq / currentFreq
offset <- 1
for (jj in (1:aggregatedTs)) {
A[counter, offset : (offset + howManyBottomToSum - 1)] <- 1
offset <- offset + howManyBottomToSum
counter <- counter + 1
}
thier()
buildMatrix()
thier()
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
thier()
A
counter
A
offset : (offset + howManyBottomToSum - 1)
A[counter, offset : (offset + howManyBottomToSum - 1)] <- 1
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
thier()
A
thier()
A
thier()
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
thier()
A
fc[[2]]
sum(priorMean)
testTs[[6]]
testTs[[6]]- sum(priorMean)
thier()
dim(priorCov)
dim(A)
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
thier()
sum(postMean)
sum(priorMean)
trainTs[[6]]
testTs[[6]]
thiefReconc
buReconc[[6]]
fc
bayesFc[[1]]
fc[[1]]
fc[[1]]$mean <- postMean
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
bayesFc <- fc
bayesFc[[1]]$mean <- postMean
bayesFc[[1]]$mean
fc[[1]]$mean
postMean
priorMean
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
#pay attention: we only overwrite the point forecast for the bottom time series,
#without managing the covariance
bayesFc <- fc
bayesFc[[1]]$mean <- postMean
bayesReconc <- reconcilethief(bayesFc, comb = "bu")
tHierMae(testTs, thiefReconc)
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
thier()
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
a <- thier
a
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
a <- thier
a <- thier()
n
a
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
a <- thier()
n
a <- thier()
a
install.packages("Mcomp")
library("Mcomp", lib.loc="/Library/Frameworks/R.framework/Versions/3.5/Resources/library")
?Mcomp
