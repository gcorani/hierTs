locale = locale(grouping_mark = "'"))
View(Sheet_2_Table_1)
tmp
tmp <- Sheet_2_Table_1
rank(tmp)
?friedman.test
a <- friedman.test(tmp)
rank(tmp[1,])
tmp[1,]
rank(tmp[1,])
rank(as.numeric(tmp[1,]))
rank(as.numeric(tmp[2,]))
sampleRank <- matrix(ncol=ncol(tmp),nrow=nrow(tmp))
for (i in 1:nrow(tmp)) sampleRank[i,]<-rank(tmp[i,])
for (i in 1:nrow(tmp)) sampleRank[i,]<-rank(as.numeric(tmp[i,]))
tmp
sampleRank
rowMeans(sampleRank)
colMeans(sampleRank)
tmp <- tmp[-1,]
for (i in 1:nrow(tmp)) sampleRank[i,]<-rank(as.numeric(tmp[i,]))
sampleRank
sampleRank <- matrix(ncol=ncol(tmp),nrow=nrow(tmp))
for (i in 1:nrow(tmp)) sampleRank[i,]<-rank(as.numeric(tmp[i,]))
sampleRank
tmp
tmp <- tmp[,-1]
tmp
for (i in 1:nrow(tmp)) sampleRank[i,]<-rank(as.numeric(tmp[i,]))
sampleRank <- matrix(ncol=ncol(tmp),nrow=nrow(tmp))
for (i in 1:nrow(tmp)) sampleRank[i,]<-rank(as.numeric(tmp[i,]))
sampleRank
rowMeans(sampleRank)
colMeans(sampleRank)
library(hts)
source("loadTourism.R")
# library(tidyverse)
tourism <- read.csv("TourismData_v3.csv",
na = "empty")
tourism
View(tourism)
#the first two columns contain the time
tourism <- tourism[,-1:-2]
class(toursim)
class(tourism)
#we known that it start in Jan 1998
y=ts(tourism, frequency = 12, start = c(1998,1))
class(tourism)
class(y)
y
View(y)
time(y)
hierTourism <- hts(y=y, bnames = colnames(tourism),
characters = c(3,3))
summary(hierTourism)
library(hts)
source("loadTourism.R")
dset="htseg1"
h=1
fmethod="ets"
library(hts)
source("loadTourism.R")
if (is.character(dset) == FALSE) {
stop ("dset should be a string")
}
#for tsCV
fets <- function(x, h) {
forecast(ets(x), h = h)
}
farima <- function(x, h) {
forecast(auto.arima(x), h=h)
}
bottomPreds <- preds
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
?forecast
?hts::forecast.gts
iTest <- 1
timeIdx             <- time(hierTs$bts[,1])
hierTs <- htseg1
testSize <- 25
if (length(hierTs$bts[,1]) < 25){
testSize <- 5
}
#if h=1, the possible preds are the whole test size lenght;
#if h=2, the possible preds are the (test size lenght -1); etc.
possiblePreds <- testSize - h + 1
totTs       <- nrow(smatrix(hierTs))
maeBase     <- matrix(nrow = possiblePreds, ncol = totTs)
maeBu       <- matrix(nrow = possiblePreds, ncol = totTs)
maeComb     <- matrix(nrow = possiblePreds, ncol = totTs)
maeCombWls  <- matrix(nrow = possiblePreds, ncol = totTs)
maeCombMint <- matrix(nrow = possiblePreds, ncol = totTs)
maeBayes    <- matrix(nrow = possiblePreds, ncol = totTs)
#These vectors will contain the global mse, summed over all the time series of the hierarchy
mseBase     <- vector(length   = possiblePreds)
mseBu       <- vector(length   = possiblePreds)
mseComb     <- vector(length   = possiblePreds)
mseCombWls  <- vector(length   = possiblePreds)
mseCombMint <- vector(length   = possiblePreds)
mseBayes    <- vector(length   = possiblePreds)
elapsedBase     <- vector(length   = possiblePreds)
elapsedBu     <- vector(length   = possiblePreds)
elapsedComb     <- vector(length   = possiblePreds)
elapsedCombMint  <- vector(length   = possiblePreds)
elapsedBayes    <- vector(length   = possiblePreds)
iTest <-1
timeIdx             <- time(hierTs$bts[,1])
endTrain            <- length(timeIdx) - h - (iTest - 1)
train               <- window(hierTs, start = timeIdx[1], end = timeIdx[endTrain] )
test                <- window(hierTs, start =timeIdx[endTrain +1], end=timeIdx[endTrain + h])
endTrain
ptm <- proc.time()
fcastBu             <- forecast(train, h = h, method = "bu", fmethod = fmethod)
View(fcastBu)
h
summary(htseg1)
elapsedComb[iTest] <- (proc.time() - ptm)["elapsed"]
fcastComb           <- forecast(train, h = h, method = "comb", weights="ols", fmethod=fmethod)
fcastComb
fcastComb[[1]]
fcastComb[[2]]
fcastComb[[3]]
fcastComb[[4]]
fcastComb[[5]]
fcastBu
test
?allts
fcastBu[[1]]
fcastBu[[2]]
#recompute predictions to be easily accessed by the Bayesian method
allTsTrain <- allts(train)
numTs <- ncol(allTsTrain)
alpha <- 0.2
sigma <- vector(length = numTs)
preds <- vector(length = numTs)
i <- 1
#recompute predictions to be easily accessed by the Bayesian method
allTsTrain <- allts(train)
numTs <- ncol(allTsTrain)
alpha <- 0.2
sigma <- vector(length = numTs)
preds <- vector(length = numTs)
print(paste(as.character(i),"/",as.character(numTs)))
model <- ets(ts(allTsTrain[,i]))
View(model)
tmp <- forecast(model, h=h, level=1-alpha)
tmp
tmp$mean
tmp$upper
sigma[i] <- abs ( (tmp$mean[h] - tmp$upper[h])  / (qnorm(alpha / 2)) )
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
source("hier.R")
for (h in c(1,2,3,4)) {
for (method in c("ets","arima")){
print(paste("infantgts ", as.character(method), "h=", as.character(h)))
a <- hier("infantgts", h=h, fmethod = method)
}
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
source("hier.R")
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
for (h in c(1,2,3,4)) {
for (method in c("ets","arima")){
print(paste("infantgts ", as.character(method), "h=", as.character(h)))
a <- hier("infantgts", h=h, fmethod = method)
}
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/parseM3results.R')
parseM3Results()
favorableSign
View(results)
friedman.test
#prepares the AEdemand dataset and launches the temporal reconciliation experiment
#the fmethod is forced to be arima as the expsmoothing does not support such long seasonality
library(thief)
library(fpp2)
source("thier.R")
#prepares the AEdemand dataset and launches the temporal reconciliation experiment
#the fmethod is forced to be arima as the expsmoothing does not support such long seasonality
library(thief)
library(fpp2)
source("thier.R")
fmethod="arima"
i <- 1
i <- 3
freq <- frequency(AEdemand[,i])
n <- length(AEdemand[,i])
endTrain <- time(AEdemand[,i])[n - freq]
print(paste("AEdemand: ",colnames(AEdemand)[i]))
freq <- frequency(AEdemand[,i])
n <- length(AEdemand[,i])
endTrain <- time(AEdemand[,i])[n - freq]
startTest <- time(AEdemand[,i])[n - freq +1]
train <- window(AEdemand[,i], end=endTrain)
test <- window(AEdemand[,i], start=startTest)
tsObj<- list()
tsObj$x <- train
tsObj$xx <- test
tsObj$sn <- colnames(AEdemand)[i]
thier (tsObj, fmethod=fmethod, periodType="weekly")
auto.arima(trainHier[[i]])
a <- auto.arima(trainHier[[i]])
a
trainHier[[1]]
class(trainHier[[1]])
frequency(trainHier[[1]])
frequency(trainHier[[2]])
b <- auto.arima(trainHier[[i]])
b
36*6
fc[[1]]
autoplot(fc[[1]])
autoplot(fc[[2]])
frequency(trainHier[[2]])
i
autoplot(fc[[i]])
autoplot(fc[[3]])
auto.arima(trainHier[[i]]), h=h, , level = (1-alpha))
auto.arima(trainHier[[3]])
frequency(trainHier[[3]])
fc[[2]]
a <- auto.arima(trainHier[[2]])
a
autoplot(forecast(auto.arima(trainHier[[i]]), h=104, , level = (1-alpha)))
autoplot(forecast(auto.arima(trainHier[[1]]), h=104, , level = (1-alpha)))
tmp <- (forecast(auto.arima(trainHier[[1]]), h=104, , level = (1-alpha)))
tmp
checkresiduals(auto.arima(trainHier[[i]]))
auto.arima(trainHier[[1]]))
auto.arima(trainHier[[1]])
b <- auto.arima(trainHier[[2]])
b
auto.arima(trainHier[[3]])
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/parseM3results.R')
parseM3Results()
View(results)
a <- cbind(results$mseBu/results$mseBase,results$mseThief/results$mseBase, results$mseBayes/results$mseBase)
boxplot(a)
boxplot(a, outline= FALSE)
boxplot(log(a), outline= FALSE)
boxplot(a, outline= FALSE)
boxplot(log(a), outline= FALSE)
boxplot(a, outline= FALSE)
boxplot(log(a))
boxplot(log10(a))
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/parseM3results.R')
parseM3Results()
parseM3Results(type="monthly", fmethod="arima")
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/parseM3results.R')
parseM3Results(type="monthly", fmethod="arima")
parseM3Results(type="monthly", fmethod="ets")
parseM3Results(type="quarterly", fmethod="ets")
parseM3Results(type="quarterly", fmethod="arima")
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/parseM3results.R')
type="weekly"
fmethod="arima"
library(readr)
filename <- paste("results/temporalHier","_",type,"_",fmethod,".csv",sep = "")
results <- read_csv(filename)
if (type=="weekly"){
warning("the AE experiment is only over 13 time series")
freqs <- c("_Weekly","_2-Weekly","_4-Weekly","_Quarterly","_Biannual","_Annual")
}
names <- colnames(results)
baseMethods <- c("Bu","Thief")
myMethod <-"Bayes"
comparisons <- length(freqs) * length (baseMethods)
improvIndicator <- matrix(0, ncol = comparisons, nrow = nrow(results))
improvNames <- vector(length = comparisons)
favorableSign <- vector(length = comparisons)
pValueSign <- vector(length = comparisons)
meanImprovement <- vector(length = comparisons)
isMseImproved  <- vector(length = comparisons)
mseImprovement  <- vector(length = comparisons)
counter <- 1
for (method in baseMethods) {
for (freq in freqs){
improvNames[counter] <- paste(method,freq)
colBase <- intersect(grep(method,names) , grep(freq,names))
colMy <- intersect(grep(myMethod,names) , grep(freq,names))
favorableSign[counter] <- mean (results[,colBase] > results[,colMy] )
#computing the improvIndicator
#unfortunaltely, this yields a single-columns *data frame* which we then have to cast as a vector
currentImprovement <- ( results[,colBase] - results[,colMy] ) / ((results[,colBase]  + results[,colMy]) /2 )
#casting as vector
currentImprovement <- currentImprovement[,1]
improvIndicator[,counter] <- currentImprovement
meanImprovement[counter] <- mean (currentImprovement)
counter <- counter + 1
}
improvIndicator <- as.data.frame(improvIndicator)
colnames(improvIndicator) <- improvNames
meanImprovement <-  as.data.frame(t(meanImprovement))
colnames(meanImprovement) <- improvNames
favorableSign <- as.data.frame(t(favorableSign))
colnames(favorableSign) <- improvNames
#generate the bplot
pdfname <- paste("results/temporalHier","_",type,"_",fmethod,".pdf",sep = "")
pdf(pdfname)
denom <- results$mseBase
a <-  cbind(results$mseBu/denom,
results$mseThief/denom, results$mseBayes/denom)
boxplot(log10(a),names=c("bu","thief","bayes"), outline=TRUE, ylab="Relative MSE (log10)")
dev.off()
#      ylab="mse(Bayes)", xlim = c(0,1e+9), ylim= c(0,1e+9))
# }
# else if (type=="quarterly"){
#   plot(results$mseThief,results$mseBayes, xlab = "mse (thief)",
#        ylab="mse(Bayes)", xlim = c(0,1e+8), ylim= c(0,1e+8))
# }
# abline(0,1)
# dev.off()
#
#test comparing thief and bayes
wilcoxPval <- wilcox.test(a[,2],a[,3],paired = TRUE, alternative = "greater")
ttestPval <-  t.test(a[,2],a[,3],paired = TRUE, alternative = "greater")
return (list("favorableSign" = favorableSign, "meanImprovement" = meanImprovement,
"wilcoxPval" = wilcoxPval, "ttestPval"=ttestPval, "improvIndicator"=improvIndicator ) )
a <- parseM3Results ()
favorableSign
mean(results$mseBase<results$mseBayes)
mean(results$mseBase>results$mseBayes)
mean(results$mseBu>results$mseBayes)
mean(results$mseThief>results$mseBayes)
parseM3Results(fmethod = "arima")
mean(results$mseThief>results$mseBayes)
mean(results$mseBu>results$mseBayes)
mean(results$mseBase>results$mseBayes)
parseM3Results(type="quarterly",fmethod = "arima")
mean(results$mseBase>results$mseBayes)
mean(results$mseBu>results$mseBayes)
mean(results$mseThief>results$mseBayes)
parseM3Results(type="quarterly",fmethod = "ets")
mean(results$mseBu>results$mseBayes)
mean(results$mseThief>results$mseBayes)
mean(results$mseBase>results$mseBayes)
parseM3Results(type="weekly",fmethod = "arima")
mean(results$mseBase>results$mseBayes)
mean(results$mseBu>results$mseBayes)
mean(results$mseThief>results$mseBayes)
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier()
hier(dset="htseg2")
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier(dset="htseg2")
mseBase
mseBayes
possiblePreds
hier(dset="htseg2")
mseBu
mean(mseBayes<mseBase)
mean(mseBayes<mseBu)
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier(dset="htseg2")
mean  ( (allts(test)[h,] - preds)^2 )
mseBase
xiu(0.3,1)
source('~/Documents/xiu.R')
xiu(0.3,1)
xiu(0.1,1)
xiu(1,1)
xiu(1,0.5)
hier("htseg1")
mean(mseBayes<mseBase)
mean(mseBayes<mseBu)
mean(mseBayes<mseComb),
mean(mseBayes<mseComb)
mean(mseBayes<mseCombWls)
mean(mseBayes<mseCombMint)
mean(mseBase)
mean(mseBu)
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier("htseg1")
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier("htseg1")
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier("htseg1")
dataFrame
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
vector(3, length = 10)
vector(data=3, length = 10)
?vector
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
data.frame(seq(1:5))
a<-data.frame(seq(1:5))
a
b <- seq(1:5)
a<-data.frame(b)
a
a$c <= 2
a
?rep
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier("htseg1")
View(dataFrame)
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier("htseg1")
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier("htseg1")
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
library(readr)
mseHierReconc <- read_csv("mseHierReconc.csv")
View(mseHierReconc)
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier("htseg1")
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/batchHier.R')
batchHier()
#parse the results of hierarchical non-temporal reconciliation
#readt the mse, extract the proportion of favorable signs and the produces the boxplot
library(readr)
results <- read_csv("results/mseHierReconc.csv")
#parse the results of hierarchical non-temporal reconciliation
#readt the mse, extract the proportion of favorable signs and the produces the boxplot
library(readr)
data <- read_csv("results/mseHierReconc.csv")
#parse the results of hierarchical non-temporal reconciliation
#readt the mse, extract the proportion of favorable signs and the produces the boxplot
library(readr)
results <- read_csv("results/mseHierReconc.csv")
fmethods <- unique(data$fmethod)
dsets <- unique(dset$fmethod)
fmethods <- unique(results$fmethod)
results <- read_csv("results/mseHierReconc.csv")
fmethods <- unique(results$fmethod)
dsets <- unique(results$fmethod)
configs <- length(fmethods) * length(dsets)
dsets <- unique(results$dset)
configs <- length(fmethods) * length(dsets)
#the 7 fields are fmethod, dset, prop against each method
favorableProps <- matrix(nrow = configs, ncol = 7)
colnames(favorableProps) <- c("dset","fmethod","propBeatBase","propBeatBu","propBeatComb",
"propBeatCombWls","propBeatMint")
View(favorableProps)
counter <- 1
for (dset in dsets){
for (fmethod in fmethods){
favorableProps[counter,"dset"] <- dset
favorableProps[counter,"fmethod"] <- fmethod
favorableProps[counter,"propBeatBase"] <- mean (results$mseBase>results$mseBayes)
favorableProps[counter,"propBeatBu"] <- mean (results$mseBu>results$mseBayes)
favorableProps[counter,"propComb"] <- mean (results$mseComb>results$mseBayes)
favorableProps[counter,"propCombWls"] <- mean (results$mseCombWls>results$mseBayes)
favorableProps[counter,"propCombMint"] <- mean (results$mseCombMint>results$mseBayes)
#generate the bplot
pdfname <- paste("results/hier","_",dset,"_",fmethod,".pdf",sep = "")
pdf(pdfname)
denom <- results$mseBase
a <-  cbind(results$mseBu/denom,
results$mseThief/denom, results$mseBayes/denom)
boxplot(log10(a),names=c("bu","thief","bayes"), outline=TRUE, ylab="Relative MSE (log10)")
dev.off()
#
counter <- counter + 1
}
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/parseHierResults.R')
parseHierResults()
mean (results$mseBu>results$mseBayes)
favorableProps[counter,"propBeatBu"]
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/parseHierResults.R')
parseHierResults()
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/parseHierResults.R')
parseHierResults()
View(favorableProps)
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/parseHierResults.R')
#generate the bplot
pdfname <- paste("results/hier","_",dset,"_",fmethod,".pdf",sep = "")
pdf(pdfname)
denom <- results$mseBase
a <-  cbind(results$mseBu/denom, results$mseComb/denom, results$mseCombWls/denom,
results$mseCombMint/denom,, results$mseBayes/denom)
boxplot(log10(a),names=c("bu","comb","combWLS","mint","Bayes"), outline=TRUE, ylab="Relative MSE (log10)")
a <-  cbind(results$mseBu/denom, results$mseComb/denom, results$mseCombWls/denom,
results$mseCombMint/denom,, results$mseBayes/denom)
cbind(results$mseBu/denom, results$mseComb/denom, results$mseCombWls/denom,
results$mseCombMint/denom,, results$mseBayes/denom)
a <-  cbind(results$mseBu/denom, results$mseComb/denom, results$mseCombWls/denom, results$mseCombMint/denom,, results$mseBayes/denom)
denom <- results$mseBase
a <-  cbind(results$mseBu/denom, results$mseComb/denom, results$mseCombWls/denom, results$mseCombMint/denom,, results$mseBayes/denom)
denom
results$mseBu/denom
results$mseComb/denom
results$mseCombWls/denom
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/parseHierResults.R')
a <-  cbind(results$mseBu/denom, results$mseComb/denom, results$mseCombWls/denom, results$mseCombMint/denom, results$mseBayes/denom)
boxplot(log10(a),names=c("bu","comb","combWLS","mint","Bayes"), outline=TRUE, ylab="Relative MSE (log10)")
dev.off()
#
counter <- counter + 1
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/parseHierResults.R')
parseHierResults()
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/parseHierResults.R')
parseHierResults()
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/parseHierResults.R')
parseHierResults()
subresults
dim(a)
parseHierResults()
idx
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/parseHierResults.R')
parseHierResults()
idx
sum(idx)
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/parseHierResults.R')
parseHierResults()
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/parseHierResults.R')
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/parseHierResults.R')
#parse the results of hierarchical non-temporal reconciliation
#readt the mse, extract the proportion of favorable signs and the produces the boxplot
library(readr)
results <- read_csv("results/mseHierReconc.csv")
#
#ggpplot2 attempt
library(ggplot2)
