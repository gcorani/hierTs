AEdemand[,1]
window(AEdemand[,1], end=200)
library(fpp2)
tsObj <- AEdemand
library(fpp2)
library(hts)
library(thief)
source("hier.R")
#computes mae for temporal hierarchies
#both actual and forecast are temporal hierarchies
tHierMae <- function (actual, forecast) {
hierMae <- vector(length = length(forecast))
for (i in seq_along(forecast)) {
hierMae[i] <- mean( abs (forecast[[i]]$mean - actual[[i]]) )
}
return (hierMae)
}
#builds the A matrix, which indicates  which bottom time series sum up to each upper time series.
buildMatrix <- function() {
A <- matrix(data = 0, nrow = length(upperIdx), ncol = length(bottomIdx))
maxFreq <- frequency(trainHier[[1]])
counter <- 1
for (ii in (2:length(trainHier))){
currentFreq <- frequency(trainHier[[ii]])
aggregatedTs <- currentFreq
howManyBottomToSum <- maxFreq / currentFreq
offset <- 1
for (jj in (1:aggregatedTs)) {
A[counter, offset : (offset + howManyBottomToSum - 1)] <- 1
offset <- offset + howManyBottomToSum
counter <- counter + 1
}
return (t(A))
}
#coverage of the PI is 0.8
alpha <- 0.2
train <- tsObj$x
tsObj
?AEdemand
AEdemand[,1]
View(AEdemand[,1])
AEdemand[,1]
AEdemand[,12]
AEdemand[,13]
autoplot(AEdemand, xlab="Year", ylab="Demand ('000)") +
ggtitle("Accident & Emergency Demand in the UK")
AEdemand[,1]
autoplot(AEdemand[,1])
class(AEdemand[,1])
AEdemand[,1]
?AEdemand
total <- AEdemand[,12]
totalagg <- tsaggregates(total)
plot(totalagg, main="Total Emergency Admissions")
base <- list()
for(i in 1:5)
base[[i]] <- forecast(auto.arima(totalagg[[i]]))
base[[6]] <-  forecast(auto.arima(totalagg[[6]]), h=2)
reconciled <- reconcilethief(base)
main <- paste(names(totalagg)," (k=",
52/unlist(lapply(reconciled,frequency)),")",sep="")
par(mfrow=c(2,3))
for(i in 6:1)
{
ylim <- range(base[[i]]$mean, base[[i]]$x, reconciled[[i]]$mean)
plot(base[[i]], main=main[i], fcol='white',
plot.conf=FALSE, ylim=ylim, xlim=c(2010.5,2017.5))
polygon(c(2015.45, 2020, 2020, 2015.45),
c(0, 0, 1e5, 1e5), col='grey', border=FALSE)
lines(base[[i]]$mean, col='red', lty=2)
lines(reconciled[[i]]$mean, col='blue')
}
base[i]
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
library(fpp2)
library(hts)
library(thief)
source("hier.R")
#computes mae for temporal hierarchies
#both actual and forecast are temporal hierarchies
tHierMae <- function (actual, forecast) {
hierMae <- vector(length = length(forecast))
for (i in seq_along(forecast)) {
hierMae[i] <- mean( abs (forecast[[i]]$mean - actual[[i]]) )
}
return (hierMae)
}
#builds the A matrix, which indicates  which bottom time series sum up to each upper time series.
buildMatrix <- function() {
A <- matrix(data = 0, nrow = length(upperIdx), ncol = length(bottomIdx))
maxFreq <- frequency(trainHier[[1]])
counter <- 1
for (ii in (2:length(trainHier))){
currentFreq <- frequency(trainHier[[ii]])
aggregatedTs <- currentFreq
howManyBottomToSum <- maxFreq / currentFreq
offset <- 1
for (jj in (1:aggregatedTs)) {
A[counter, offset : (offset + howManyBottomToSum - 1)] <- 1
offset <- offset + howManyBottomToSum
counter <- counter + 1
}
return (t(A))
}
#coverage of the PI is 0.8
alpha <- 0.2
train <- tsObj$x
#we need to force the test to be as long as exactly one period
timeIdx <- time(tsObj$xx)
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
AEdemand
class
class(AEdemand)
colnames(AEdemand)
for (i in seq_along(AEdemand)) {
print("AEdemand: ",colnames(AEdemand)[i])
#
# trainTs <-
# tsObj$x <-
}
for (i in seq_along(AEdemand)) {
print("AEdemand: ",colnames(AEdemand)[i])
#
# trainTs <-
# tsObj$x <-
}
for (i in 1:length(AEdemand)) {
print("AEdemand: ",colnames(AEdemand)[i])
#
# trainTs <-
# tsObj$x <-
}
for (i in 1:length(AEdemand)) {
print("AEdemand: ",colnames(AEdemand)[i])
#
# trainTs <-
# tsObj$x <-
}
for (i in 1:length(AEdemand)) {
print("AEdemand: ",colnames(AEdemand)[i])
#
# trainTs <-
# tsObj$x <-
}
for (i in 1:length(AEdemand)) {
print("AEdemand: ",colnames(AEdemand)[i])
#
# trainTs <-
# tsObj$x <-
}
colnames(AEdemand)[1]
colnames(AEdemand)[2]
i<-1
print(paste("AEdemand: ",colnames(AEdemand)[i]))
for (i in 1:length(AEdemand)) {
print(paste("AEdemand: ",colnames(AEdemand)[i]))
#
# trainTs <-
# tsObj$x <-
}
for (i in (1:length(AEdemand))) {
print(paste("AEdemand: ",colnames(AEdemand)[i]))
#
# trainTs <-
# tsObj$x <-
}
print(paste("AEdemand: ",colnames(AEdemand)[1]))
print(paste("AEdemand: ",colnames(AEdemand)[2]))
print(paste("AEdemand: ",colnames(AEdemand)[3]))
length(AEdemand)
dim(AEdemand)
for (i in (1:dim(AEdemand)[1])) {
print(paste("AEdemand: ",colnames(AEdemand)[i]))
#
# trainTs <-
# tsObj$x <-
}
batchAE <- function(){
#prepares the AEdemand dataset and launches the temporal reconciliation experiment
library(thief)
source("thier.R")
for (i in (1:dim(AEdemand)[1])) {
print(paste("AEdemand: ",colnames(AEdemand)[i]))
#
# trainTs <-
# tsObj$x <-
}
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/batchAE.R')
for (i in (1:dim(AEdemand)[1])) {
print(paste("AEdemand: ",colnames(AEdemand)[i]))
#
# trainTs <-
# tsObj$x <-
}
dim(AEdemand)[1]
1:dim(AEdemand)[1]
for (i in (1:dim(AEdemand)[2])) {
print(paste("AEdemand: ",colnames(AEdemand)[i]))
#
# trainTs <-
# tsObj$x <-
}
for (i in (1:dim(AEdemand)[2])) {
print(paste("AEdemand: ",colnames(AEdemand)[i]))
}
AEdemand[1]
AEdemand[1,]
AEdemand[,1]
class(AEdemand[,1])
frequency(AEdemand[,1])
?subset
104-5
104-52
length(AEdemand[,1])
i <- 1
print(paste("AEdemand: ",colnames(AEdemand)[i]))
freq <- frequency(AEdemand[,i])
n <- length(AEdemand[,1])
train <- subset(AEdemand[i], start=1, end=length(AEdemand[,1])-freq)
subset(AEdemand[i], start=1, end=(length(AEdemand[,1])-freq))
library(fpp2)
source("thier.R")
?subset
i <- 1
train <- subset(AEdemand[i], start=1, end=(length(AEdemand[,1])-freq))
print(paste("AEdemand: ",colnames(AEdemand)[i]))
freq <- frequency(AEdemand[,i])
n <- length(AEdemand[,1])
(length(AEdemand[,1])-freq
)
end=(length(AEdemand[,1])-freq)
subset(AEdemand[i], start=1, end=188)
head(AEdemand[i],188)
AEdemand[i]
AEdemand[,1]
head(AEdemand[,1],188)
?hts
?hts-`hts-package`
?hts
MinT
?MinT
hier(dset="htseg1")
weights
covariance
alg
y
tmp.resid
res
tspx
?tsp
cnames
?lowerD
lowerD(res)
dim(lowerD(res))
res
dim(res)
tar()
tar
shrink
shrink.estim
h
nodes
gmat
smat
methods::as(w.1, "sparseMatrix")
#prepares the AEdemand dataset and launches the temporal reconciliation experiment
library(thief)
#prepares the AEdemand dataset and launches the temporal reconciliation experiment
library(thief)
library(fpp2)
source("thier.R")
i <- 1
print(paste("AEdemand: ",colnames(AEdemand)[i]))
freq <- frequency(AEdemand[,i])
n <- length(AEdemand[,1])
train <- head(AEdemand[i], length(AEdemand[,1])-freq)
?tail
test <- subset(AEdemand[i], n=length(AEdemand[,1])-freq+1)
test <- subset(AEdemand[i], length(AEdemand[,1])-freq+1)
test <- tail(AEdemand[i], length(AEdemand[,1])-freq+1)
train
train <- head(AEdemand[,i], length(AEdemand[,1])-freq)
test <- tail(AEdemand[,i], length(AEdemand[,1])-freq+1)
autoplot(train)
autoplot(test)
time(train)
time(test)
train <- head(AEdemand[,i], endTrain)
endTrain <- length(AEdemand[,i]) - freq
train <- head(AEdemand[,i], endTrain)
test <- tail(AEdemand[,i], length(AEdemand[,i])-endTrain+1)
time(train)
tail(train,5)
test <- tail(AEdemand[,i], length(AEdemand[,i])-endTrain+1)
head(test,5)
i
?subset
subset(AEdemand[,i], start = time(AEdemand[,i]), stop = time(AEdemand[,i+5]))
subset(AEdemand[,i], start = time(AEdemand[,i]), end =  = time(AEdemand[,i+5]))
subset(AEdemand[,i], start = time(AEdemand[,i]), end = time(AEdemand[,i+5]))
subset(AEdemand[,i], start = time(AEdemand[10,i]), end = time(AEdemand[15,i]))
subset(AEdemand[,i], start = time(AEdemand[10,i]), end = time(AEdemand[11,i]))
subset(AEdemand[,i], start = time(AEdemand[10,i]), end = time(AEdemand[12,i]))
time(AEdemand[12,i])
time(AEdemand[10,i])
time(AEdemand[i])
time(AEdemand[i,])
time(AEdemand[,i])
endTrain <- time(AEdemand[,i])[n-freq]
endTrain
endTrain <- time(AEdemand[,i])[n - freq]
startTest <- time(AEdemand[,i])[n - freq +1]
train <- subset(AEdemand[,i], end=endTrain)
test <- subset(AEdemand[,i], start=startTest)
tail(time(train),5)
head(time(test),5)
frequency(AEdemand[,1])
#prepares the AEdemand dataset and launches the temporal reconciliation experiment
library(thief)
library(fpp2)
source("thier.R")
i <=- 1
i <- 1
print(paste("AEdemand: ",colnames(AEdemand)[i]))
freq <- frequency(AEdemand[,i])
n <- length(AEdemand[,1])
endTrain <- time(AEdemand[,i])[n - freq]
startTest <- time(AEdemand[,i])[n - freq +1]
train <- subset(AEdemand[,i], end=endTrain)
test <- subset(AEdemand[,i], start=startTest)
autoplot(time(train))
autoplot(time(train)) + autolayer(time(test))
tsObj$x <- train
tsObj$xx <- test
tsObj$sn <- colnames(AEdemand)[i]
class(train)
class(test)
class(tsObj$xx\)
class(tsObj$xx)
class(tsObj$x)
thier (tsObj, fmethod=fmethod, periodType="weekly")
forecast(auto.arima(trainHier[[i]]), h=h, , level = (1-alpha))
fmethod<-"arima"
thier (tsObj, fmethod=fmethod, periodType="weekly")
fc[[1]]
fc[[2]]
fc[[3]]
fc[[4]]
fc[[5]]
fc[[6]]
reconcilethief(fc, comb = "struc")
reconcilethief(fc, comb = "bu")
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
fc[[1]]
fc[[2]]
fc[[3]]
fc[[13]]
fc[[12]]
fc[[11]]
fc[[6]]
tsObj
tsObj$xx
tsObj$x
#prepares the AEdemand dataset and launches the temporal reconciliation experiment
#the fmethod is forced to be arima as the expsmoothing does not support such long seasonality
library(thief)
library(fpp2)
source("thier.R")
i<-1
print(paste("AEdemand: ",colnames(AEdemand)[i]))
freq <- frequency(AEdemand[,i])
n <- length(AEdemand[,i])
freq
n
endTrain <- time(AEdemand[,i])[n - freq]
startTest <- time(AEdemand[,i])[n - freq +1]
train <- subset(AEdemand[,i], end=endTrain)
test <- subset(AEdemand[,i], start=startTest)
train
subset(AEdemand[,i], end=endTrain)
window(AEdemand[,i], end=endTrain)
train <- window(AEdemand[,i], end=endTrain)
test <- window(AEdemand[,i], start=startTest)
tsObj$x <- train
tsObj$xx <- test
tsObj$x
tsObj$xx
tsObj$xx <- test
tsObj$sn <- colnames(AEdemand)[i]
thier (tsObj, fmethod=fmethod, periodType="weekly")
batchAE()
dim(AEdemand)[2]
for (i in (1:dim(AEdemand)[2])) {
print(paste("AEdemand: ",colnames(AEdemand)[i]))
freq <- frequency(AEdemand[,i])
n <- length(AEdemand[,i])
endTrain <- time(AEdemand[,i])[n - freq]
startTest <- time(AEdemand[,i])[n - freq +1]
train <- window(AEdemand[,i], end=endTrain)
test <- window(AEdemand[,i], start=startTest)
tsObj$x <- train
tsObj$xx <- test
tsObj$sn <- colnames(AEdemand)[i]
thier (tsObj, fmethod=fmethod, periodType="weekly")
}
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/batchAE.R')
batchAE()
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/parseM3results.R')
parseM3Results("weekly","arima")
filename
names
a <- parseM3Results("weekly","arima")
View(a)
?reconcilethief
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/batchAE.R')
View(a)
AEdemand[,1]
class(AEdemand[,1])
length(AEdemand[,1])
52*240
240/52
a <- parseM3Results("weekly","arima")
View(a)
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier(htseg1)
hier("htseg1")
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier("htseg1")
dataFrame <- data.frame(matrix(data=unlist(myList)[idx],nrow = 1, ncol = length(idx)))
#save to file the results
#fields to be dumped
idx <- 1:12
dataFrame <- data.frame(matrix(data=unlist(myList)[idx],nrow = 1, ncol = length(idx)))
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier("htseg1")
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier("htseg1")
View(dataFrame)
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier("htseg1")
bayesPreds
test
test[h,]
test
test[[1]]
test[[2]]
test[[3]]
test[[4]]
test[[1]]
bayesPreds
allts(test)[h,]
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier("htseg1")
length(idx)
myList[1:17]
c((length(idx)+1):(length(idx)+4), 1:length(idx))
dim(dataFrame)
View(dataFrame)
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier("htseg1")
View(dataFrame)
hier("htseg1")
hier("htseg1",h=2)
hier("htseg1",h=3)
hier("htseg2",h=1)
hier("htseg2",h=2)
hier("htseg2",h=3)
hier("infantgts",h=1)
hier("infantgts",h=2)
hier("infantgts",h=3)
hier("tourism",h=1)
hier htseg1 1 "ets"
hier ("htseg1", 1, "ets")
?auto.arima
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/batchM3.R')
batchM3("quarterly")
batchM3(type="quarterly")
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/thier.R')
batchM3(type="quarterly")
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/batchM3.R')
batchM3(type="quarterly")
fmethod
type
trainHier
trainHier[[1]]
trainHier[[2]]
trainHier[[3]]
library(Mcomp)
source("thier.R")
type
type="quarterly"
M3.selected <- subset(M3,4)
M3.selected[[1]]
a<-M3.selected[[1]]
View(a)
for (i in 1:length(M3.selected)){tmp[i]<-length(M3.selected[[i]]$xx)}
tmp<-vector(length = length(M3.selected))
for (i in 1:length(M3.selected)){tmp[i]<-length(M3.selected[[i]]$xx)}
tmp
read_csv("TourismData_v3.csv",
na = "empty")
a <- read_csv("TourismData_v3.csv",
na = "empty")
b <- read.csv("TourismData_v3.csv",
na = "empty")
tourism <- b
#the first two columns contain the time
tourism <- tourism[,-1:-2]
hierTourism <- hts(y=tourism, bnames = colnames(tourism),
characters = c(3,3))
hierTourism
