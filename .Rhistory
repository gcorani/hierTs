priorDiagCov <- diag(bottomVar)
plot(diag(priorDiagCov),diag(priorCov))
diag(priorCov)
summary(diag(priorCov))
summary(diag(priorDiagCov))
dim(residuals)
var(residuals[,1])
priorCov[1,1]
priorDiagCov[1,1]
sum(residuals[,1]^2)
mean(residuals[,1]^2)
var(residuals)
dim(var(residuals))
a<-var(residuals)
a[1,1]
a<-cov(residuals)
a[1,1]
bottomIdx
upperIdx
sigma[1]
preds[1]
sd(residuals[,1])
sd(residuals[1,])
i<-1
model <- ets(allTsTrain[,i])
tmp <- forecast(model, h=h, level=1-alpha)
residuals[,i] <- model$residuals
preds[i] <- tmp$mean[h]
tmp
preds[i] <- tmp$mean[h]
sigma[i] <- abs ( (tmp$mean[h] - tmp$upper[h])  / (qnorm(alpha / 2)) )
preds
preds[1]
sigma[1]
model$residuals
sd(model$residuals)
i
model <- ets(allTsTrain[,i])
tmp <- forecast(model, h=h, level=1-alpha)
residuals[,i] <- model$residuals
model
autoplot(model)
autoplot(model$fitted)
summary(model$fitted)
summary(model$x)
summary(model$residuals)
model$x - model$residuals
model$x - model$fitted
model$fit
model$sigma2
model$residuals
summary(model$x - model$fitted)
var(model$x - model$fitted)
model
tmp
25173.16 * 1.28 * 1.06
sigma[1]
sd(model$x - model$fitted)
#compute, for each  ts, predictions and sigma (h-steps ahead)
for (i in 1:numTs){
if (fmethod=="ets"){
model <- ets(allTsTrain[,i])
}
else if (fmethod=="arima"){
model <- auto.arima(allTsTrain[,i])
}
tmp <- forecast(model, h=h, level=1-alpha)
residuals[,i] <- model$x - model$fitted #we cannot store model$residuals due to models with multiplicative errors
preds[i] <- tmp$mean[h]
sigma[i] <- abs ( (tmp$mean[h] - tmp$upper[h])  / (qnorm(alpha / 2)) )
}
mseBase =  mean  ( (allts(test)[h,] - preds)^2 )
calibration50 <- checkCalibration(preds, sigma, test, coverage = 0.5)
calibration80 <- checkCalibration(preds, sigma, test, coverage = 0.8)
S <- smatrix(train)
#Bayesian reconciliation
bottomIdx <- seq( nrow(S) - ncol(S) +1, nrow(S))
upperIdx <- setdiff(1:nrow(S),bottomIdx)
#prior mean and covariance of the bottom time series
priorMean <- preds[bottomIdx]
#prior mean and covariance of the upper time series
Y_vec <- preds[upperIdx]
Sigma_y <- matrix(nrow = length(upperIdx), ncol = length(upperIdx))
#prior covariance for the bottom time series
bottomVar <- sigma[bottomIdx]^2
priorCov <- diag(bottomVar)
if (correlation){
#the covariances are the covariances of the time series
#the variances are the variances of the forecasts, hence the variances of the residuals
#old version: covariance of the time series
# priorCov <- cov(allTsTrain)[bottomIdx,bottomIdx]
#current version: covariance of the forecasts
priorCov <- cov(residuals)[bottomIdx,bottomIdx]
# diag(priorCov) <- bottomVar
}
priorCov[1,1]
diag(bottomVar)[1,1]
cov(residuals)[1,1]
sd(residuals[1,])
dim(residuals[1,])
length(residuals[1,])
sd(residuals[,1])
sigma[1]
var(residuals[,1])
sigma[bottomIdx[1]]^2
sigma[1]^2
priorDiag <- diag(bottomVar)
priorDiagCov <- diag(bottomVar)
priorDiagCov[1,1]
sd(residuals[,1])
var(residuals[,1])
#the covariances are the covariances of the time series
#the variances are the variances of the forecasts, hence the variances of the residuals
#old version: covariance of the time series
# priorCov <- cov(allTsTrain)[bottomIdx,bottomIdx]
#current version: covariance of the forecasts
priorCov <- cov(residuals)[bottomIdx,bottomIdx]
priorCov[1,1]
#the covariances are the covariances of the time series
#the variances are the variances of the forecasts, hence the variances of the residuals
#old version: covariance of the time series
# priorCov <- cov(allTsTrain)[bottomIdx,bottomIdx]
#current version: covariance of the forecasts
var(residuals)[1,1]
cov(residuals)[1,1]
priorCov <- diag(bottomVar)
#the covariances are the covariances of the time series
#the variances are the variances of the forecasts, hence the variances of the residuals
#old version: covariance of the time series
# priorCov <- cov(allTsTrain)[bottomIdx,bottomIdx]
#current version: covariance of the forecasts
priorCov <- cov(residuals)[bottomIdx,bottomIdx]
priorDiagCov <- diag(bottomVar)
as.numeric(priorDiagCov)
diag(priorDiagCov)
#the covariances are the covariances of the time series
#the variances are the variances of the forecasts, hence the variances of the residuals
#old version: covariance of the time series
# priorCov <- cov(allTsTrain)[bottomIdx,bottomIdx]
#current version: covariance of the forecasts
priorCov <- cov(residuals)[bottomIdx,bottomIdx]
cor(diag(priorCov),diag(priorDiagCov))
fmethod<-"arima"
fmethod
#compute, for each  ts, predictions and sigma (h-steps ahead)
for (i in 1:numTs){
if (fmethod=="ets"){
model <- ets(allTsTrain[,i])
}
else if (fmethod=="arima"){
model <- auto.arima(allTsTrain[,i])
}
tmp <- forecast(model, h=h, level=1-alpha)
residuals[,i] <- model$x - model$fitted #we cannot store model$residuals due to models with multiplicative errors
preds[i] <- tmp$mean[h]
sigma[i] <- abs ( (tmp$mean[h] - tmp$upper[h])  / (qnorm(alpha / 2)) )
}
?auto.arima
mseBase =  mean  ( (allts(test)[h,] - preds)^2 )
calibration50 <- checkCalibration(preds, sigma, test, coverage = 0.5)
calibration80 <- checkCalibration(preds, sigma, test, coverage = 0.8)
?ets
calibration50 <- checkCalibration(preds, sigma, test, coverage = 0.5)
calibration80 <- checkCalibration(preds, sigma, test, coverage = 0.8)
S <- smatrix(train)
#Bayesian reconciliation
bottomIdx <- seq( nrow(S) - ncol(S) +1, nrow(S))
upperIdx <- setdiff(1:nrow(S),bottomIdx)
#prior mean and covariance of the bottom time series
priorMean <- preds[bottomIdx]
#prior mean and covariance of the upper time series
Y_vec <- preds[upperIdx]
Sigma_y <- matrix(nrow = length(upperIdx), ncol = length(upperIdx))
#prior covariance for the bottom time series
bottomVar <- sigma[bottomIdx]^2
priorCov <- diag(bottomVar)
#covariance for the upper time series
upperVar <- sigma[upperIdx]^2
Sigma_y <- diag(upperVar)
mseBase =  mean  ( (allts(test)[h,] - preds)^2 )
mseBase
#covariance for the upper time series
upperVar <- sigma[upperIdx]^2
Sigma_y <- diag(upperVar)
#==updating
#A explains how to combin the bottom series in order to obtain the
# upper series
A <- t(S[upperIdx,])
M <- ncol ( t(A) %*% priorCov %*% A + Sigma_y )
correl <- priorCov %*% A %*%
solve (t(A) %*% priorCov %*% A + Sigma_y + 1e-6*diag(M))
postMean <- priorMean + correl  %*%
(Y_vec - t(A) %*% priorMean)
bayesPreds <- buReconcile(postMean, S, predsAllTs = FALSE)
mseBayes =  mean  ( (allts(test)[h,] - bayesPreds)^2 )
mseBayes
priorDiagCov <- diag(bottomVar)
#the covariances are the covariances of the time series
#the variances are the variances of the forecasts, hence the variances of the residuals
#old version: covariance of the time series
# priorCov <- cov(allTsTrain)[bottomIdx,bottomIdx]
#current version: covariance of the forecasts
priorCov <- cov(residuals)[bottomIdx,bottomIdx]
priorCov[1,1]
priorDiagCov[1,1]
i<-1
model <- ets(allTsTrain[,i], additive.only = TRUE)
model <- auto.arima(allTsTrain[,i])
residuals[,i] <- model$x - model$fitted #we cannot store model$residuals due to models with multiplicative errors
var(model$x - model$fitted)
abs ( (tmp$mean[h] - tmp$upper[h])  / (qnorm(alpha / 2)) )
tmp <- forecast(model, h=h, level=1-alpha)
residuals[,i] <- model$x - model$fitted #we cannot store model$residuals due to models with multiplicative errors
preds[i] <- tmp$mean[h]
sigma[i] <- abs ( (tmp$mean[h] - tmp$upper[h])  / (qnorm(alpha / 2)) )
h
tmp <- forecast(model, h=h, level=1-alpha)
abs ( (tmp$mean[h] - tmp$upper[h])  / (qnorm(alpha / 2)) )
sqrt(mean(model$residuals^2))
model$sigma2
sigma[1]
sigma[1]^2
var(model$residuals)
mean(model$residuals^2)
sqrt(mean(model$residuals^2))
sqrt(model$sigma2)
priorDiagCov[1,1]
#prior covariance for the bottom time series
bottomVar <- sigma[bottomIdx]^2
priorCov <- diag(bottomVar)
priorDiagCov <- diag(bottomVar)
#the covariances are the covariances of the time series
#the variances are the variances of the forecasts, hence the variances of the residuals
#old version: covariance of the time series
# priorCov <- cov(allTsTrain)[bottomIdx,bottomIdx]
#current version: covariance of the forecasts
priorCov <- cov(residuals)[bottomIdx,bottomIdx]
diag(priorCov)
diag(priorCov)[1:10]
diag(priorDiagCov)[1:10]
#the covariances are the covariances of the time series
#the variances are the variances of the forecasts, hence the variances of the residuals
#old version: covariance of the time series
# priorCov <- cov(allTsTrain)[bottomIdx,bottomIdx]
#current version: covariance of the forecasts
priorCov <- cov(residuals)[bottomIdx,bottomIdx]
#covariance for the upper time series
upperVar <- sigma[upperIdx]^2
Sigma_y <- diag(upperVar)
if (correlation){
#get variance and covariance of the residuals
Sigma_y <- cov(residuals)[upperIdx,upperIdx]
# diag(Sigma_y) <- upperVar
}
#==updating
#A explains how to combin the bottom series in order to obtain the
# upper series
A <- t(S[upperIdx,])
M <- ncol ( t(A) %*% priorCov %*% A + Sigma_y )
correl <- priorCov %*% A %*%
solve (t(A) %*% priorCov %*% A + Sigma_y + 1e-6*diag(M))
#covariance for the upper time series
upperVar <- sigma[upperIdx]^2
Sigma_y <- diag(upperVar)
if (correlation){
#get variance and covariance of the residuals
Sigma_y <- cov(residuals)[upperIdx,upperIdx]
# diag(Sigma_y) <- upperVar
}
#==updating
#A explains how to combin the bottom series in order to obtain the
# upper series
A <- t(S[upperIdx,])
M <- ncol ( t(A) %*% priorCov %*% A + Sigma_y )
correl <- priorCov %*% A %*%
solve (t(A) %*% priorCov %*% A + Sigma_y + 1e-6*diag(M))
postMean <- priorMean + correl  %*%
(Y_vec - t(A) %*% priorMean)
bayesPreds <- buReconcile(postMean, S, predsAllTs = FALSE)
mseBayes =  mean  ( (allts(test)[h,] - bayesPreds)^2 )
mseBayes
library(huge)
?huge.select
L = huge.generator(d = 20, graph="hub")
class(L$data)
priorDiagCov
dim(priorDiagCov)
dim(priorCov)
#the covariances are the covariances of the time series
#the variances are the variances of the forecasts, hence the variances of the residuals
#old version: covariance of the time series
# priorCov <- cov(allTsTrain)[bottomIdx,bottomIdx]
#current version: covariance of the forecasts
bottomResiduals <- residuals[,bottomIdx]
priorCov == cov (bottomResiduals)
#the covariances are the covariances of the time series
#the variances are the variances of the forecasts, hence the variances of the residuals
#old version: covariance of the time series
# priorCov <- cov(allTsTrain)[bottomIdx,bottomIdx]
#current version: covariance of the forecasts
bottomResiduals <- residuals[,bottomIdx]
priorCov <- cov(bottomResiduals)
out.glasso <- huge(bottomResiduals, method = "glasso")
out.select <- huge.select(out.glasso)
plot(out.select)
out.select <- huge.select(out.glasso, criterion = "ric")
plot(out.select)
out.select <- huge.select(out.glasso, criterion = "ric")
?huge.select
out.select
out.select$opt.lambda
out.select <- huge.select(out.glasso, criterion = "ebic")
class(out.select)
out.select$refit
out.select$opt.icov
length(bottomIdx)
out.glasso
?huge
out.glasso <- huge(bottomResiduals, method = "glasso", cov.output = TRUE)
out.select <- huge.select(out.glasso, criterion = "ebic")
?huge.select
out.select$opt.index
out.select <- huge.select(out.glasso, criterion = "stars")
out.select$method
View(out.select)
out.select[[7]]
out.select$icov
out.select$cov
class(out.select$cov)
length(out.select$cov)
out.select$loglik
out.select$opt.index
out.select$opt.lambda
out.select$opt.cov
out.select$opt.cov == out.select$cov[[7]]
priorCov <- out.select$opt.cov
mseBase
mseBayes
correlation=FALSE
#prior covariance for the bottom time series
bottomVar <- sigma[bottomIdx]^2
priorCov <- diag(bottomVar)
if (correlation){
#the covariances are the covariances of the time series
#the variances are the variances of the forecasts, hence the variances of the residuals
#old version: covariance of the time series
# priorCov <- cov(allTsTrain)[bottomIdx,bottomIdx]
#current version: covariance of the forecasts
bottomResiduals <- residuals[,bottomIdx]
priorCov <- cov(bottomResiduals)
out.glasso <- huge(bottomResiduals, method = "glasso", cov.output = TRUE)
out.select <- huge.select(out.glasso, criterion = "stars")
priorCov <- out.select$opt.cov
}
#covariance for the upper time series
upperVar <- sigma[upperIdx]^2
Sigma_y <- diag(upperVar)
if (correlation){
#get variance and covariance of the residuals
Sigma_y <- cov(residuals)[upperIdx,upperIdx]
}
#==updating
#A explains how to combin the bottom series in order to obtain the
# upper series
A <- t(S[upperIdx,])
M <- ncol ( t(A) %*% priorCov %*% A + Sigma_y )
correl <- priorCov %*% A %*%
solve (t(A) %*% priorCov %*% A + Sigma_y + 1e-6*diag(M))
postMean <- priorMean + correl  %*%
(Y_vec - t(A) %*% priorMean)
bayesPreds <- buReconcile(postMean, S, predsAllTs = FALSE)
mseBayes =  mean  ( (allts(test)[h,] - bayesPreds)^2 )
mseBayes
#the covariances are the covariances of the time series
#the variances are the variances of the forecasts, hence the variances of the residuals
bottomResiduals <- residuals[,bottomIdx]
out.glasso <- huge(bottomResiduals, method = "glasso", cov.output = TRUE)
out.select <- huge.select(out.glasso, criterion = "stars")
priorCov <- out.select$opt.cov
#covariance for the upper time series
upperVar <- sigma[upperIdx]^2
Sigma_y <- diag(upperVar)
#==updating
#A explains how to combin the bottom series in order to obtain the
# upper series
A <- t(S[upperIdx,])
M <- ncol ( t(A) %*% priorCov %*% A + Sigma_y )
correl <- priorCov %*% A %*%
solve (t(A) %*% priorCov %*% A + Sigma_y + 1e-6*diag(M))
postMean <- priorMean + correl  %*%
(Y_vec - t(A) %*% priorMean)
bayesPreds <- buReconcile(postMean, S, predsAllTs = FALSE)
mseBayes =  mean  ( (allts(test)[h,] - bayesPreds)^2 )
mseBayes
#get variance and covariance of the residuals
upperResiduals <- residuals[,upperIdx]
#get variance and covariance of the residuals
upperResiduals <- residuals[,upperIdx]
cov(residuals)[upperIdx,upperIdx] == cov(upperResiduals)
Sigma_y <- cov(upperResiduals)
out.glasso <- huge(upperResiduals, method = "glasso", cov.output = TRUE)
#get variance and covariance of the residuals
upperResiduals <- residuals[,upperIdx]
out.glasso <- huge(upperResiduals, method = "glasso", cov.output = TRUE)
out.select <- huge.select(out.glasso, criterion = "stars")
Sigma_y <- out.select$opt.cov
#==updating
#A explains how to combin the bottom series in order to obtain the
# upper series
A <- t(S[upperIdx,])
M <- ncol ( t(A) %*% priorCov %*% A + Sigma_y )
correl <- priorCov %*% A %*%
solve (t(A) %*% priorCov %*% A + Sigma_y + 1e-6*diag(M))
postMean <- priorMean + correl  %*%
(Y_vec - t(A) %*% priorMean)
bayesPreds <- buReconcile(postMean, S, predsAllTs = FALSE)
mseBayes =  mean  ( (allts(test)[h,] - bayesPreds)^2 )
mseBayes
hierRec(dset="infantgts", correlation = FALSE)
parseHierResults_aggregatedH("infantgts")
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/parseHierResults_aggregatedH.R')
parseHierResults_aggregatedH("infantgts")
hierRec(dset="infantgts", correlation = FALSE, fmethod = "arima")
parseHierResults_aggregatedH("infantgts")
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/parseHierResults_aggregatedH.R')
parseHierResults_aggregatedH("infantgts")
infantgts
hierRec(dset="infantgts", correlation = TRUE, fmethod = "arima")
parseHierResults_aggregatedH("infantgts")
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hierRec.R')
parseHierResults_aggregatedH("infantgts")
hierRec(dset="infantgts", correlation = TRUE, fmethod = "arima")
M
correl
bayesPreds
mseBayes
mseBase
mseCombMint
dataFrame
tmp <- read.delim("~/switchDrive/hierTs/hierarchicalTimeSeries/code/tmp.csv", header=FALSE)
View(tmp)
tmp
tmp <- read.delim("~/switchDrive/hierTs/hierarchicalTimeSeries/code/tmp.csv")
View(tmp)
mean(tmp$mseBayes<tmp$mseBayesNoCorr)
tmp$BayesNoCorr
mean(tmp$mseBayes<tmp$BayesNoCorr)
median(tmp$mseBayes/tmp$BayesNoCorr)
boxplot(tmp$mseBayes/tmp$BayesNoCorr)
mean(tmp$mseBayes<tmp$mseBase)
mean(tmp$BayesNoCorr < tmp$mseBase)
mean(tmp$mseBayes < tmp$mseBase)
mean(tmp$mseBayes < tmp$mseCombMint)
mean(tmp$BayesNoCorr < tmp$mseCombMint)
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hierRec.R')
hierRec(dset="infantgts",correlation="TRUE")
tmp <- read.csv("~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/results/tmp.csv")
View(tmp)
mean(tmp$mseBase>tmp$mseBayes)
mean(tmp$mseBase>tmp$mseBayesCorr)
mean(tmp$mseCombMint>tmp$mseBayes)
mean(tmp$mseCombMint>tmp$mseBayesCorr)
summary(tmp$mseBase/tmp$mseBayes)
summary(tmp$mseBase/tmp$mseBayesCorr)
summary(tmp$mseCombMint/tmp$mseBayes)
summary(tmp$mseCombMint/tmp$mseBayesCorr)
boxplot(tmp$mseBase tmp$mseCombMint tmp$mseBayes tmp$mseBayesCorr)
boxplot(cbind(tmp$mseBase tmp$mseCombMint tmp$mseBayes tmp$mseBayesCorr))
boxplot(cbind(tmp$mseBase, tmp$mseCombMint, tmp$mseBayes, tmp$mseBayesCorr))
mean(tmp$mseBayes > tmp$mseBayesCorr)
tourism <- tmp
tourism
tmpInfant <- read.csv("~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/results/tmpInfant.csv")
View(tmpInfant)
boxplot(cbind(tmpInfant$mseBase, tmpInfant$mseCombMint, tmpInfant$mseBayes, tmpInfant$mseBayesCorr))
mean(tmpInfant$mseBase>tmpInfant$mseBayes)
mean(tmpInfant$mseBase>tmpInfant$mseBayesCorr)
mean(tmpInfant$mseCombMint>tmpInfant$mseBayesCorr)
mean(tmpInfant$mseCombMint>tmpInfant$mseBayes)
mean(tmpInfant$mseBayes>tmpInfant$mseBayesCorr)
a <- rank(cbind(tmpInfant$mseBase, tmpInfant$mseCombMint, tmpInfant$mseBayes, tmpInfant$mseBayesCorr))
a
a <- rank(cbind(tmpInfant$mseBase, tmpInfant$mseCombMint, tmpInfant$mseBayes, tmpInfant$mseBayesCorr)[1,])
a
for (i in 1:dim(tmpInfant)[2]) {a[i,]<-rank(cbind(tmpInfant$mseBase, tmpInfant$mseCombMint, tmpInfant$mseBayes, tmpInfant$mseBayesCorr)[1,])}
a<-matrix()
for (i in 1:dim(tmpInfant)[2]) {a[i,]<-rank(cbind(tmpInfant$mseBase, tmpInfant$mseCombMint, tmpInfant$mseBayes, tmpInfant$mseBayesCorr)[1,])}
for (i in 1:dim(tmpInfant)[2]) {a[i,]<-rank(cbind(tmpInfant$mseBase, tmpInfant$mseCombMint, tmpInfant$mseBayes, tmpInfant$mseBayesCorr)[i,])}
rank(cbind(tmpInfant$mseBase, tmpInfant$mseCombMint, tmpInfant$mseBayes, tmpInfant$mseBayesCorr)[1,])
rank(cbind(tmpInfant$mseBase, tmpInfant$mseCombMint, tmpInfant$mseBayes, tmpInfant$mseBayesCorr)[2,])
rank(cbind(tmpInfant$mseBase, tmpInfant$mseCombMint, tmpInfant$mseBayes, tmpInfant$mseBayesCorr)[3,])
rank(cbind(tmpInfant$mseBase, tmpInfant$mseCombMint, tmpInfant$mseBayes, tmpInfant$mseBayesCorr)[4,])
rank(cbind(tmpInfant$mseBase, tmpInfant$mseCombMint, tmpInfant$mseBayes, tmpInfant$mseBayesCorr)[5,])
a[i,1] <- rank(cbind(tmpInfant$mseBase, tmpInfant$mseCombMint, tmpInfant$mseBayes, tmpInfant$mseBayesCorr)[5,])
a<-matrix(nrow = dim(tmpInfant)[2], ncol = 4)
for (i in 1:dim(tmpInfant)[2]) {a[i,]<-rank(cbind(tmpInfant$mseBase, tmpInfant$mseCombMint, tmpInfant$mseBayes, tmpInfant$mseBayesCorr)[i,])}
a
colMeans(a)
tourismTmpResults <- read.csv("~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/results/tourismTmpResults.csv")
View(tourismTmpResults)
mean(tmpInfant$mseBayes>tmpInfant$mseBayesCorr)
mean(tmpInfant$mseBase>tmpInfant$mseBayesCorr)
mean(tmpInfant$mseBase>tmpInfant$mseBayes)
mean(tmpInfant$mseCombMint>tmpInfant$mseBayes)
mean(tourismTmpResults$mseCombMint>tourismTmpResults$mseBayes)
mean(tourismTmpResults$mseCombMint>tourismTmpResults$mseBayeCorr)
mean(tourismTmpResults$mseBase>tourismTmpResults$mseBayeCorr)
mean(tourismTmpResults$mseBase>tourismTmpResults$mseBayes)
summary(tourismTmpResults$mseBase/tourismTmpResults$mseBayeCorr)
summary(tourismTmpResults$mseCombMint/tourismTmpResults$mseBayeCorr)
summary(tourismTmpResults$mseCombMint/tourismTmpResults$mseBayes)
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hierRec.R')
