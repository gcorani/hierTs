upperVar <- sigma[upperIdx]^2
Sigma_y <- diag(upperVar)
#this runs with full covariance matrix
if (correlation){
for (myRow in 1:nrow(priorCov))
for (myCol in 1:ncol(priorCov)){
if (i != j){
priorCov[myRow,myCol] <- sigma[myRow] * sigma[myCol] * cor(allTsTrain[,upperIdx[myRow]],allTsTrain[,upperIdx[myCol]])
}
for (myRow in 1:nrow(upperVar))
for (myCol in 1:ncol(upperVar)){
if (i != j){
priorCov[myRow,myCol] <- upperVar[myRow] * upperVar[myCol] * cor(allTsTrain[,myRow],allTsTrain[,myCol])
}
priorCov
priorCov[1,1]
priorCov[3,3]
#==updating
#A explains how to combin the bottom series in order to obtain the
# upper series
A <- t(S[upperIdx,])
correl <- priorCov %*% A %*%
solve (t(A) %*% priorCov %*% A + Sigma_y)
postMean <- priorMean + correl  %*%
(Y_vec - t(A) %*% priorMean)
bayesPreds <- buReconcile(postMean, S, predsAllTs = FALSE)
mseBayes =  mean  ( (allts(test)[h,] - bayesPreds)^2 )
mseBayes
mseBase
#we focus on mint only
# fcastBu             <- forecast(train, h = h, method = "bu", fmethod = fmethod)
# fcastComb           <- forecast(train, h = h, method = "comb", weights="ols", fmethod=fmethod)
# fcastCombWls        <- forecast(train, h = h, method = "comb", weights="wls", fmethod=fmethod)
fcastCombMint       <- forecast(train, h = h, method = "comb", weights="mint", fmethod=fmethod)
# mseBu        <- hierMse(fcastBu, test, h )
# mseComb      <- hierMse(fcastComb, test, h )
# mseCombWls   <- hierMse(fcastCombWls, test, h )
mseCombMint  <- hierMse(fcastCombMint, test,  h)
mseCombMint
correlation
correlation=TRUE
#prior covariance for the bottom time series
bottomVar <- sigma[bottomIdx]^2
priorCov <- diag(bottomVar)
#covariance for the upper time series
upperVar <- sigma[upperIdx]^2
Sigma_y <- diag(upperVar)
#this runs with full covariance matrix
if (correlation){
for (myRow in 1:nrow(priorCov))
for (myCol in 1:ncol(priorCov)){
if (i != j){
priorCov[myRow,myCol] <- sigma[myRow] * sigma[myCol] * cor(allTsTrain[,upperIdx[myRow]],allTsTrain[,upperIdx[myCol]])
}
for (myRow in 1:nrow(upperVar))
for (myCol in 1:ncol(upperVar)){
if (i != j){
priorCov[myRow,myCol] <- upperVar[myRow] * upperVar[myCol] * cor(allTsTrain[,myRow],allTsTrain[,myCol])
}
nrow(priorCov)
ncol(priorCov)
for (myRow in 1:nrow(priorCov))
for (myCol in 1:ncol(priorCov)){
if (i != j){
priorCov[myRow,myCol] <- sigma[myRow] * sigma[myCol] * cor(allTsTrain[,upperIdx[myRow]],allTsTrain[,upperIdx[myCol]])
}
upperVar
for (myRow in 1:nrow(Sigma_y))
for (myRow in 1:nrow(Sigma_y)){
for (myCol in 1:ncol(Sigma_y)){
if (i != j){
priorCov[myRow,myCol] <- upperVar[myRow] * upperVar[myCol] * cor(allTsTrain[,myRow],allTsTrain[,myCol])
}
for (myRow in 1:nrow(Sigma_y)){
for (myCol in 1:ncol(Sigma_y)){
if (i != j){
priorCov[myRow,myCol] <- upperVar[myRow] * upperVar[myCol] * cor(allTsTrain[,myRow],allTsTrain[,myCol])
}
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
#Bayesian reconciliation
bottomIdx <- seq( nrow(S) - ncol(S) +1, nrow(S))
bottomIdx
upperIdx <- setdiff(1:nrow(S),bottomIdx)
upperO
upperIdx
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
for (myRow in 1:nrow(priorCov))
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
for (myRow in 1:nrow(priorCov)){
for (myCol in 1:ncol(priorCov)){
if (i != j){
rowIdx <- bottomIdx[myRow]
colIdx <- bottomIdx[myCol]
priorCov[myRow,myCol] <- sigma[rowIdx] * sigma[colIdx] * cor(allTsTrain[,rowIdx],allTsTrain[,colIdx])
}
priorCov[2,3]
bottomIdx[2]
bottomIdx[3]
sigma(bottomIdx[2]) * sigma(bottomIdx[3])
sigma(bottomIdx[2])
sigma[bottomIdx[2]]
sigma[bottomIdx[2]] * sigma[bottomIdx[3]]
cor(allTsTrain[,bottomIdx[2]],allTsTrain[,bottomIdx[3]])
-0.2708366 * 22675.17
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
for (myRow in 1:nrow(Sigma_y)){
for (myCol in 1:ncol(Sigma_y)){
rowIdx <- upperIdx[myRow]
colIdx <- upperIdx[myCol]
if (i != j){
Sigma_y[myRow,myCol] <- sigma[rowIdx] * sigma[colIdx] * cor(allTsTrain[,rowIdx],allTsTrain[,colIdx])
}
Sigma_y
Sigma_y[4,5]
sigma[upperIdx[4]]
sigma[upperIdx[5]]
sigma[upperIdx[4]] * sigma[upperIdx[5]]
cor(allTsTrain[,upperIdx[4]],allTsTrain[,upperIdx[5]])
145513.3 *  0.6109823
#==updating
#A explains how to combin the bottom series in order to obtain the
# upper series
A <- t(S[upperIdx,])
correl <- priorCov %*% A %*%
solve (t(A) %*% priorCov %*% A + Sigma_y)
eig (t(A) %*% priorCov %*% A + Sigma_y)
eigen (t(A) %*% priorCov %*% A + Sigma_y)
correl <- priorCov %*% A %*%
solve (t(A) %*% priorCov %*% A + Sigma_y)
eigen (t(A) %*% priorCov %*% A + Sigma_y)
eigen (t(A) %*% priorCov %*% A + Sigma_y, only.values = TRUE)
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
#==updating
#A explains how to combin the bottom series in order to obtain the
# upper series
A <- t(S[upperIdx,])
M <- ncol ( t(A) %*% priorCov %*% A + Sigma_y )
correl <- priorCov %*% A %*%
solve (t(A) %*% priorCov %*% A + Sigma_y + 1e-8*diag(M))
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
correl <- priorCov %*% A %*%
solve (t(A) %*% priorCov %*% A + Sigma_y)
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
correl <- priorCov %*% A %*%
solve (t(A) %*% priorCov %*% A + Sigma_y + 1e-8*diag(M))
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
#==updating
#A explains how to combin the bottom series in order to obtain the
# upper series
A <- t(S[upperIdx,])
M <- ncol ( t(A) %*% priorCov %*% A + Sigma_y )
correl <- priorCov %*% A %*%
solve (t(A) %*% priorCov %*% A + Sigma_y + 1e-6*diag(M))
postMean <- priorMean + correl  %*%
(Y_vec - t(A) %*% priorMean)
bayesPreds <- buReconcile(postMean, S, predsAllTs = FALSE)
mseBayes =  mean  ( (allts(test)[h,] - bayesPreds)^2 )
mseBayes
library(hts)
?forecast
?forecast.gts
dset <- "tourism"
fmethod<-"ets"
library(hts)
source("loadTourism.R")
#The buReconcile function computes the bu prediction given the predictions (1 x tot time series) and the S matrix
#(tot time series X bottom time series)
#predsAllTs is a flag: is set to true, the input preds contains predictions for all the hierarchy
#and the function retrieves the bottom series; if set to false, this is not needed
#as preds only contains only bottom time series
buReconcile <- function (preds,S, predsAllTs = FALSE) {
bottomPreds <- preds
if (predsAllTs) {
#retrieves the bottom prediction from all predictions
upperIdx <- 1 : (nrow(S) - ncol(S))
bottomIdx <- setdiff (1:nrow(S), upperIdx)
bottomPreds <- preds [,bottomIdx]
}
buPreds <- preds
#nrow(S) is the total number of time series
for (i in 1:nrow(S)){
buPreds[i] <- S[i,] %*% bottomPreds
}
return (buPreds)
}
#check the calibration of the prediction interval with coverage (1-currentAlpha)
checkCalibration <- function(preds,sigmas,htsActual,coverage){
stdQuant <- abs(qnorm((1-coverage)/2))
included <- vector(length = length(preds))
actual <- allts(htsActual)[h,]
for (ii in seq_along(preds)){
upper <- preds[ii] + stdQuant * sigmas[ii]
lower <- preds[ii] - stdQuant * sigmas[ii]
included[ii] <- (actual[ii] > lower) &  (actual[ii] < upper)
}
return (mean(included))
}
hierMse <- function (htsPred, htsActual, h) {
#receives two hts objects, containing  forecast and actual value.
#computes the mse for the whole hierarchy.
mse <- mean  ( (allts(htsPred)[h,] - allts(htsActual)[h,])^2 )
return (mse)
}
#extract the time from the data set to then split into train / test (test set contains 25 or 5 time points)
set.seed(seed = 0)
if (dset=="tourism"){
hierTs <- loadTourism()
}
testSize <- 45
#if h=1, the possible preds are the whole test size lenght;
#if h=2, the possible preds are the (test size lenght -1); etc.
possiblePreds <- testSize - h + 1
iTest <- 2
timeIdx             <- time(hierTs$bts[,1])
endTrain            <- length(timeIdx) - h - (iTest - 1)
train               <- window(hierTs, start = timeIdx[1], end = timeIdx[endTrain] )
test                <- window(hierTs, start =timeIdx[endTrain +1], end=timeIdx[endTrain + h])
#we focus on mint only
# fcastBu             <- forecast(train, h = h, method = "bu", fmethod = fmethod)
# fcastComb           <- forecast(train, h = h, method = "comb", weights="ols", fmethod=fmethod)
# fcastCombWls        <- forecast(train, h = h, method = "comb", weights="wls", fmethod=fmethod)
fcastCombMint       <- forecast(train, h = h, method = "comb", weights="mint", fmethod=fmethod)
timeIdx             <- time(hierTs$bts[,1])
endTrain            <- length(timeIdx) - h - (iTest - 1)
train               <- window(hierTs, start = timeIdx[1], end = timeIdx[endTrain] )
timeIdx             <- time(hierTs$bts[,1])
endTrain            <- length(timeIdx) - h - (iTest - 1)
h<-1
endTrain            <- length(timeIdx) - h - (iTest - 1)
train               <- window(hierTs, start = timeIdx[1], end = timeIdx[endTrain] )
test                <- window(hierTs, start =timeIdx[endTrain +1], end=timeIdx[endTrain + h])
#we focus on mint only
# fcastBu             <- forecast(train, h = h, method = "bu", fmethod = fmethod)
# fcastComb           <- forecast(train, h = h, method = "comb", weights="ols", fmethod=fmethod)
# fcastCombWls        <- forecast(train, h = h, method = "comb", weights="wls", fmethod=fmethod)
fcastCombMint       <- forecast(train, h = h, method = "comb", weights="mint", fmethod=fmethod)
# mseBu        <- hierMse(fcastBu, test, h )
# mseComb      <- hierMse(fcastComb, test, h )
# mseCombWls   <- hierMse(fcastCombWls, test, h )
mseCombMint  <- hierMse(fcastCombMint, test,  h)
testSize <- 45
#if h=1, the possible preds are the whole test size lenght;
#if h=2, the possible preds are the (test size lenght -1); etc.
possiblePreds <- testSize - h + 1
iTest
#recompute predictions to be easily accessed by the Bayesian method
allTsTrain <- allts(train)
numTs <- ncol(allTsTrain)
alpha <- 0.2
sigma <- vector(length = numTs)
preds <- vector(length = numTs)
#compute, for each  ts, predictions and sigma (h-steps ahead)
for (i in 1:numTs){
if (fmethod=="ets"){
model <- ets(allTsTrain[,i])
tmp <- forecast(model, h=h, level=1-alpha)
# print(paste(as.character(i),"/",as.character(numTs)))
# print(model$components)
}
else if (fmethod=="arima"){
model <- auto.arima(allTsTrain[,i])
tmp <- forecast(model, h=h, level=1-alpha)
}
preds[i] <- tmp$mean[h]
sigma[i] <- abs ( (tmp$mean[h] - tmp$upper[h])  / (qnorm(alpha / 2)) )
}
mseBase =  mean  ( (allts(test)[h,] - preds)^2 )
mseBase
calibration50 <- checkCalibration(preds, sigma, test, coverage = 0.5)
calibration80 <- checkCalibration(preds, sigma, test, coverage = 0.8)
S <- smatrix(train)
#Bayesian reconciliation
bottomIdx <- seq( nrow(S) - ncol(S) +1, nrow(S))
upperIdx <- setdiff(1:nrow(S),bottomIdx)
#prior mean and covariance of the bottom time series
priorMean <- preds[bottomIdx]
#prior mean and covariance of the upper time series
Y_vec <- preds[upperIdx]
Sigma_y <- matrix(nrow = length(upperIdx), ncol = length(upperIdx))
#prior covariance for the bottom time series
bottomVar <- sigma[bottomIdx]^2
priorCov <- diag(bottomVar)
#covariance for the upper time series
upperVar <- sigma[upperIdx]^2
Sigma_y <- diag(upperVar)
#==updating
#A explains how to combin the bottom series in order to obtain the
# upper series
A <- t(S[upperIdx,])
M <- ncol ( t(A) %*% priorCov %*% A + Sigma_y )
correl <- priorCov %*% A %*%
solve (t(A) %*% priorCov %*% A + Sigma_y + 1e-6*diag(M))
postMean <- priorMean + correl  %*%
(Y_vec - t(A) %*% priorMean)
bayesPreds <- buReconcile(postMean, S, predsAllTs = FALSE)
mseBayes =  mean  ( (allts(test)[h,] - bayesPreds)^2 )
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
#==updating
#A explains how to combin the bottom series in order to obtain the
# upper series
A <- t(S[upperIdx,])
M <- ncol ( t(A) %*% priorCov %*% A + Sigma_y )
correl <- priorCov %*% A %*%
solve (t(A) %*% priorCov %*% A + Sigma_y + 1e-6*diag(M))
postMean <- priorMean + correl  %*%
(Y_vec - t(A) %*% priorMean)
bayesPreds <- buReconcile(postMean, S, predsAllTs = FALSE)
mseBayes =  mean  ( (allts(test)[h,] - bayesPreds)^2 )
mseBayes
mseBase
mseCombMint
#this runs with full covariance matrix
if (correlation){
for (myRow in 1:nrow(priorCov)){
for (myCol in (myRow+1):ncol(priorCov)){
if (i != j){
rowIdx <- bottomIdx[myRow]
colIdx <- bottomIdx[myCol]
priorCov[myRow,myCol] <- sigma[rowIdx] * sigma[colIdx] * cor(allTsTrain[,rowIdx],allTsTrain[,colIdx])
priorCov[myCol,myRow] <- priorCov[myRow,myCol]
}
for (myRow in 1:nrow(Sigma_y)){
for (myCol in (myRow+1):ncol(Sigma_y)){
rowIdx <- upperIdx[myRow]
colIdx <- upperIdx[myCol]
if (i != j){
Sigma_y[myRow,myCol] <- sigma[rowIdx] * sigma[colIdx] * cor(allTsTrain[,rowIdx],allTsTrain[,colIdx])
Sigma_y[myCol,myRow] <- Sigma_y[myRow,myCol]
}
correlation<-TRUE
#this runs with full covariance matrix
if (correlation){
for (myRow in 1:nrow(priorCov)){
for (myCol in (myRow+1):ncol(priorCov)){
if (i != j){
rowIdx <- bottomIdx[myRow]
colIdx <- bottomIdx[myCol]
priorCov[myRow,myCol] <- sigma[rowIdx] * sigma[colIdx] * cor(allTsTrain[,rowIdx],allTsTrain[,colIdx])
priorCov[myCol,myRow] <- priorCov[myRow,myCol]
}
for (myRow in 1:nrow(Sigma_y)){
for (myCol in (myRow+1):ncol(Sigma_y)){
rowIdx <- upperIdx[myRow]
colIdx <- upperIdx[myCol]
if (i != j){
Sigma_y[myRow,myCol] <- sigma[rowIdx] * sigma[colIdx] * cor(allTsTrain[,rowIdx],allTsTrain[,colIdx])
Sigma_y[myCol,myRow] <- Sigma_y[myRow,myCol]
}
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
#this runs with full covariance matrix
if (correlation){
for (myRow in 1:nrow(priorCov)){
for (myCol in (myRow+1):ncol(priorCov)){
if (myRow != myCol){
rowIdx <- bottomIdx[myRow]
colIdx <- bottomIdx[myCol]
priorCov[myRow,myCol] <- sigma[rowIdx] * sigma[colIdx] * cor(allTsTrain[,rowIdx],allTsTrain[,colIdx])
priorCov[myCol,myRow] <- priorCov[myRow,myCol]
}
for (myRow in 1:nrow(Sigma_y)){
for (myCol in (myRow+1):ncol(Sigma_y)){
rowIdx <- upperIdx[myRow]
colIdx <- upperIdx[myCol]
if (myRow != myCol) {
Sigma_y[myRow,myCol] <- sigma[rowIdx] * sigma[colIdx] * cor(allTsTrain[,rowIdx],allTsTrain[,colIdx])
Sigma_y[myCol,myRow] <- Sigma_y[myRow,myCol]
}
Sigma_y
Sigma_y[1,1]
rowIdx,-1
rowIdx<-1
colIdx<-1
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
sigma[rowIdx] * sigma[colIdx] * cor(allTsTrain[,rowIdx],allTsTrain[,colIdx])
#prior covariance for the bottom time series
bottomVar <- sigma[bottomIdx]^2
priorCov <- diag(bottomVar)
#covariance for the upper time series
upperVar <- sigma[upperIdx]^2
Sigma_y <- diag(upperVar)
rowIdx<-10
colIdx<-10
sigma[rowIdx] * sigma[colIdx] * cor(allTsTrain[,rowIdx],allTsTrain[,colIdx])
priorCov[10]
priorCov[10,10]
rowIdx
colIdx
#prior covariance for the bottom time series
bottomVar <- sigma[bottomIdx]^2
priorCov <- diag(bottomVar)
priorCov[10,10]
myRow
myRow<-10
myCol<-10
rowIdx <- bottomIdx[myRow]
colIdx <- bottomIdx[myCol]
sigma[rowIdx] * sigma[colIdx] * cor(allTsTrain[,rowIdx],allTsTrain[,colIdx])
#prior covariance for the bottom time series
bottomVar <- sigma[bottomIdx]^2
priorCov <- diag(bottomVar)
priorCovOLD <- priorCov
for (myRow in 1:nrow(priorCov)){
for (myCol in (myRow+1):ncol(priorCov)){
if (myRow != myCol){
rowIdx <- bottomIdx[myRow]
colIdx <- bottomIdx[myCol]
priorCov[myRow,myCol] <- sigma[rowIdx] * sigma[colIdx] * cor(allTsTrain[,rowIdx],allTsTrain[,colIdx])
priorCov[myCol,myRow] <- priorCov[myRow,myCol]
}
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
for (myRow in 1:nrow(priorCov)){
for (myCol in (myRow+1):ncol(priorCov)){
if (myRow != myCol){
rowIdx <- bottomIdx[myRow]
colIdx <- bottomIdx[myCol]
print("rowIdx",rowIdx,"colIdx",colIdx)
priorCov[myRow,myCol] <- sigma[rowIdx] * sigma[colIdx] * cor(allTsTrain[,rowIdx],allTsTrain[,colIdx])
priorCov[myCol,myRow] <- priorCov[myRow,myCol]
}
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
print(paste("rowIdx",rowIdx,"colIdx",colIdx))
for (myRow in 1:nrow(priorCov)){
for (myCol in (myRow+1):ncol(priorCov)){
if (myRow != myCol){
rowIdx <- bottomIdx[myRow]
colIdx <- bottomIdx[myCol]
print(paste("rowIdx",rowIdx,"colIdx",colIdx))
priorCov[myRow,myCol] <- sigma[rowIdx] * sigma[colIdx] * cor(allTsTrain[,rowIdx],allTsTrain[,colIdx])
priorCov[myCol,myRow] <- priorCov[myRow,myCol]
}
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
for (myRow in 1:(nrow(priorCov)-1)){
for (myCol in (myRow+1):ncol(priorCov)){
if (myRow != myCol){
rowIdx <- bottomIdx[myRow]
colIdx <- bottomIdx[myCol]
# print(paste("rowIdx",rowIdx,"colIdx",colIdx))
priorCov[myRow,myCol] <- sigma[rowIdx] * sigma[colIdx] * cor(allTsTrain[,rowIdx],allTsTrain[,colIdx])
priorCov[myCol,myRow] <- priorCov[myRow,myCol]
}
priorCov[10,10]
priorCovOLD[10,10]
priorCov[ncol(priorCov),]
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
for (myRow in 1:(nrow(Sigma_y)-1)){
for (myCol in (myRow+1):ncol(Sigma_y)){
rowIdx <- upperIdx[myRow]
colIdx <- upperIdx[myCol]
if (myRow != myCol) {
Sigma_y[myRow,myCol] <- sigma[rowIdx] * sigma[colIdx] * cor(allTsTrain[,rowIdx],allTsTrain[,colIdx])
Sigma_y[myCol,myRow] <- Sigma_y[myRow,myCol]
}
Sigma_y[ncol(Sigma_y),]
#==updating
#A explains how to combin the bottom series in order to obtain the
# upper series
A <- t(S[upperIdx,])
M <- ncol ( t(A) %*% priorCov %*% A + Sigma_y )
correl <- priorCov %*% A %*%
solve (t(A) %*% priorCov %*% A + Sigma_y + 1e-6*diag(M))
postMean <- priorMean + correl  %*%
(Y_vec - t(A) %*% priorMean)
bayesPreds <- buReconcile(postMean, S, predsAllTs = FALSE)
mseBayes =  mean  ( (allts(test)[h,] - bayesPreds)^2 )
mseBayes
Sigma_y <- diag(upperVar)
#==updating
#A explains how to combin the bottom series in order to obtain the
# upper series
A <- t(S[upperIdx,])
M <- ncol ( t(A) %*% priorCov %*% A + Sigma_y )
Sigma_y
#==updating
#A explains how to combin the bottom series in order to obtain the
# upper series
A <- t(S[upperIdx,])
M <- ncol ( t(A) %*% priorCov %*% A + Sigma_y )
correl <- priorCov %*% A %*%
solve (t(A) %*% priorCov %*% A + Sigma_y + 1e-6*diag(M))
postMean <- priorMean + correl  %*%
(Y_vec - t(A) %*% priorMean)
bayesPreds <- buReconcile(postMean, S, predsAllTs = FALSE)
mseBayes =  mean  ( (allts(test)[h,] - bayesPreds)^2 )
mseBayes
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
model <- ets(allTsTrain[,1])
a<-list()
a[[1]]<-"c"
a[[100]]<-"c"
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
modelList <-list()
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R', echo=TRUE)
#initialize the list to contains a number of models
modelList[[1]] <- ets(allTsTrain[,1])
modelList[[numTs]] <- ets(allTsTrain[,1])
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
fmethod
#compute, for each  ts, predictions and sigma (h-steps ahead)
for (i in 1:numTs){
if (fmethod=="ets"){
modelList[[i]] <- ets(allTsTrain[,i])
tmp <- forecast(model, h=h, level=1-alpha)
# print(paste(as.character(i),"/",as.character(numTs)))
# print(model$components)
}
else if (fmethod=="arima"){
modelList[[i]] <- auto.arima(allTsTrain[,i])
tmp <- forecast(model, h=h, level=1-alpha)
}
preds[i] <- tmp$mean[h]
sigma[i] <- abs ( (tmp$mean[h] - tmp$upper[h])  / (qnorm(alpha / 2)) )
}
