custom
outData[counter]$customer
outData$customer[1]
debugSource('~/Downloads/ff.R')
a <- dataConverter()
a
View(a)
a[1]
a$customer
a$customer[1]
a <- dataConverter()
outData$customer[1]
custom
as.character(custom)
class(custom)
outData$customer[counter]
outData$supplier[counter]
outData$qty[counter]
as.numeric(data[i,supply]
)
as.numeric(data[i,supply])
outData$customer[counter] <- "pippo"
a<-data.frame(s=numeric(1000))
a
a$s[100]<-5
a$pippo[100]<-5
debugSource('~/Downloads/ff.R')
a <- dataConverter()
debugSource('~/Downloads/ff.R')
a <- dataConverter()
outData$supplier[counter]
outData$customer[counter]
a <- dataConverter()
a
View(a)
View(Input)
source('~/Downloads/ff.R')
View(a)
a <- dataConverter()
source('~/Downloads/ff.R')
a <- dataConverter()
as.numeric(data[i,supply])
as.numeric(data[i,supply]) > 0
debugSource('~/Downloads/ff.R')
a <- dataConverter()
data[i,supply]
as.numeric(data[i,supply])
as.numeric(data[i,supply]) > 0
debugSource('~/Downloads/ff.R')
a <- dataConverter()
(as.numeric(data[i,supply])
)
data[i,supply]
is.numeric(data[i,supply])
debugSource('~/Downloads/ff.R')
a <- dataConverter()
a
View(a)
a <- dataConverter()
debugSource('~/Downloads/ff.R')
a <- dataConverter()
a
a <- dataConverter()
is.numeric(data[i,supply]))
is.numeric(data[i,supply])
data[i,supply]
as.numeric(data[i,supply])>0
as.numeric("a"])>0
as.numeric("a")>0
Input <- read_csv("~/Downloads/Input.csv",
col_types = cols(ACHEMA = col_number(),
ACRON = col_number(), ANVILL = col_number(),
BASF = col_number(), BOREALIS = col_number(),
BRENNTAG = col_number(), CF_INDUSTRIES = col_number(),
`CONC%` = col_number(), EUROCHEM = col_number(),
OCI=col_number(),
FERTIBERIA = col_number(), GRUPA_AZOTY = col_number(),
INEOS = col_number(), `OTHER EASTERN EUROPEAN` = col_number(),
`OTHERS (1) - SUPPLIER NAME` = col_character(),
`OTHERS (1) - VOLUME` = col_number(),
SEGMENT = col_character(), SKW = col_number(),
YARA = col_number()), na = "0")
a<-dataConverter()
debugSource('~/Downloads/ff.R')
a<-dataConverter()
debugSource('~/Downloads/ff.R')
a<-dataConverter()
debugSource('~/Downloads/ff.R')
a<-dataConverter()
library(readr)
Input <- read_csv("~/Downloads/Input.csv",
col_types = cols(ACHEMA = col_number(),
ACRON = col_number(), ANVILL = col_number(),
BASF = col_number(), BOREALIS = col_number(),
BRENNTAG = col_number(), CF_INDUSTRIES = col_number(),
`CONC%` = col_number(), EUROCHEM = col_number(),
OCI=col_number(),
FERTIBERIA = col_number(), GRUPA_AZOTY = col_number(),
INEOS = col_number(), `OTHER EASTERN EUROPEAN` = col_number(),
`OTHERS (1) - SUPPLIER NAME` = col_character(),
`OTHERS (1) - VOLUME` = col_number(),
SEGMENT = col_character(), SKW = col_number(),
YARA = col_number()), na = "0")
uniqueCustomer <- unique(Input$CUSTOMER)
n<-20000
outData <- data.frame(
qty=numeric(n)
)
suppliers <- colnames(Input)[10:27]
counter <- 1
for (custom in uniqueCustomer){
# print (paste("custom: ", custom))
idx  <- Input$CUSTOMER==custom
data <- Input[idx,]
for (i in 1:nrow(data)) {
for (supply in suppliers){
# print (paste("supply: ", supply))
if ( (! is.na(data[i,supply])) & (is.numeric(data[i,supply])) )
{
if (as.numeric(data[i,supply]) > 0)  {
outData$customer[counter] <- custom
outData$supplier[counter] <- supply
outData$qty[counter] <- as.numeric(data[i,supply])
counter <- counter + 1
}
View(outData)
debugSource('~/Downloads/ff.R')
?inv
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier(htseg2)
fcastBu
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier(htseg2)
priorCov %*% A %*%
solve (t(A) %*% priorCov %*% A + Sigma_y)
priorCov %*% A
dim(S)
dim(priorCov)
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier(htseg2)
priorCov %*% A
Sigma_y
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier(htseg2)
t(A) %*% priorCov %*% A + Sigma_y
t(A) %*% priorCov %*% A
dim(t(A) %*% priorCov %*% A)
dim(Sigma_y)
dim(priorCov)
hier(htseg2)
dim (priorCov)
dim(t(A) %*% priorCov %*% A )
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
a<- hier(htseg1)
a
summary(as.numeric(a$maeBayes - a$maeBayesOneShot))
b <- hier(htseg2)
b
mean(b$maeBayes<b$maeComb)
mean(b$maeBayesOneShot<b$maeComb)
mean(b$maeBayesOneShot<b$maeCombWls)
mean(b$maeBayes<b$maeCombWls)
mean(b$maeBayes<b$maeCombMint)
mean(b$maeBayesOneShot<b$maeCombMint)
c <- hier(infantgts)
View(c)
mean(c$maeBayesOneShot<c$maeCombMint)
mean(c$maeBayes<c$maeCombMint)
mean(c$maeBayesOneShot<c$maeComb)
mean(c$maeBayes<c$maeComb)
mean(c$maeBayesOneShot<c$maeCombWls)
mean(c$maeBayes<c$maeCombWls)
summary(as.numeric((c$maeBayes - c$maeBayesOneShot)/((c$maeBayes + c$maeBayesOneShot) / 2)))
boxplot(as.numeric((c$maeBayes - c$maeBayesOneShot)/((c$maeBayes + c$maeBayesOneShot) / 2)))
scatter.smooth(as.numeric(c$maeBayes),as.numeric(c$maeBayesOneShot))
?scatter.smooth
abline(0,1)
scatter.smooth(as.numeric(b$maeBayes),as.numeric(b$maeBayesOneShot))
abline(0,1)
scatter.smooth(as.numeric(a$maeBayes),as.numeric(a$maeBayesOneShot))
abline(0,1)
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier(htseg1)
a<-hier(htseg1)
b<-hier(htseg2)
load("~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/results.Rdata")
a
resultsHtseg1
resultsHtseg1[[4]]==a[[4]]
resultsHtseg2[[4]]==a[[4]]
a[[4]]
a<-hier(htseg2)
a
resultsHtseg1[[4]]
a[[4]]
a[[1]]
a[[2]]
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
a<-hier(htseg2)
maeBu[iTest,]
Sigma_y
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
a<-hier(htseg2)
Sigma_y
sigma
upperIdx
mean(sigma[upperIdx])
mean(sigma[bottomIdx])
upperIdx
sigma[upperIdx]
0.18043429^2
a
hier(htseg1)
preds
sigma
maeCombMint[iTest,]
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
a <- hier(htseg1)
a
a <- hier(infantgts)
a
View(a)
a$maeBayes
a <- hier(infantgts,h=4)
a
View(a)
infantgts$bts
dim(infantgts$bts)
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hierTs <- htseg1
library(hts)
hierTs <- htseg1
h=1
?forecast.gts
fmethod<-"rw"
#computes the bu prediction given the predictions (1 x tot time series) and the S matrix
#(tot time series X bottom time series)
#predsAllTs is a flag: is set to true, the input preds contains predictions for all the hierarchy
#and the function retrieves the bottom series; if set to false, this is not needed
#as preds only contains only bottom time series
buReconcile <- function (preds,S, predsAllTs = FALSE) {
bottomPreds <- preds
if (predsAllTs) {
#retrieves the bottom prediction from all predictions
upperIdx <- 1 : (nrow(S) - ncol(S))
bottomIdx <- setdiff (1:nrow(S), upperIdx)
bottomPreds <- preds [,bottomIdx]
}
buPreds <- preds
#nrow(S) is the total number of time series
for (i in 1:nrow(S)){
buPreds[i] <- S[i,] %*% bottomPreds
}
return (buPreds)
}
hierMae <- function (htsPred, htsActual) {
#receives two hts objects, containing  forecast and actual value.
#computes the mae for the relevant forecast horizon only
#Sets correctly the columns names currently not possible
maeHts <- abs (allts(htsPred) - allts(htsActual))[h,]
# colnames(maeHts) <- colnames(allts(htsPred))
return (maeHts)
}
#extract the time from the data set to then split into train / test (test set contains 25 or 5 time points)
testSize <- 25
if (length(hierTs$bts[,1]) < 25){
testSize <- 5
}
#if h=1, the possible preds are the whole test size lenght;
#if h=2, the possible preds are the (test size lenght -1); etc.
possiblePreds <- testSize - h + 1
totTs <- nrow(smatrix(hierTs))
maeBu <- matrix(nrow = possiblePreds, ncol = totTs)
maeComb <- matrix(nrow = possiblePreds, ncol = totTs)
maeCombWls <- matrix(nrow = possiblePreds, ncol = totTs)
maeCombMint <- matrix(nrow = possiblePreds, ncol = totTs)
maeBayes <- matrix(nrow = possiblePreds, ncol = totTs)
iTest <- 1
timeIdx <- time(hierTs$bts[,1])
endTrain <- length(timeIdx) - h - (iTest - 1)
train <- window(hierTs, start = timeIdx[1], end = timeIdx[endTrain] )
test <- window(hierTs, start =timeIdx[endTrain +1], end=timeIdx[endTrain + h])
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
fcastBu <- forecast(train, h = h, method = "bu", fmethod = fmethod)
fcastComb <- forecast(train, h = h, method = "comb", weights="ols", fmethod=fmethod)
fcastCombWls <- forecast(train, h = h, method = "comb", weights="wls", fmethod=fmethod)
fcastCombMint <- forecast(train, h = h, method = "comb", weights="mint", fmethod=fmethod)
fcastBu
fcastBu$method
fcastBu$fmethod
fcastBu$bts
hierTs$bts
ts(allTsTrain[,i])
i<-1
ts(allTsTrain[,i])
#recompute predictions to be easily accessed by the Bayesian method
allTsTrain <- allts(train)
numTs <- ncol(allTsTrain)
alpha <- 0.2
sigma <- vector(length = numTs)
preds <- vector(length = numTs)
ts(allTsTrain[,i])
?rw
?rwf
rwf(ts(allTsTrain[,i]),h=h)
a<-rwf(ts(allTsTrain[,i]),h=h)
class(a)
b<-auto.arima(ts(allTsTrain[,i]))
class(b)
model <- ets(ts(allTsTrain[,i]))
tmp <- forecast(model, h=h, level=1-alpha)
tmp
rwf(ts(allTsTrain[,i]))
rwf(ts(allTsTrain[,i]), h=1)
tmp <- forecast(model, h=h, level=1-alpha)
tmp
alpha
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
tmp <- rwf(ts(allTsTrain[,i]),h=h, level=1-alpha)
preds[i] <- tmp$mean[h]
sigma[i] <- abs ( (tmp$mean[h] - tmp$upper[h])  / (qnorm(alpha / 2)) )
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
load("~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/results.Rdata")
a <- hier(htseg1)
a
view(a)
iew(a)
View(a)
a
resultsHtseg1[[1]]
a[[1]]
a[[4]]
resultsHtseg1[[4]]
resultsHtseg1[[5]]
resultsHtseg1[[5]]==a[[5]]
resultsHtseg1[[4]]==a[[4]]
resultsHtseg1[[3]]==a[[3]]
resultsHtseg1[[5]]==a[[5]]
resultsHtseg1[[6]]==a[[6]]
resultsHtseg1[[6]]
a[[6]]
a
a[[6]]
resultsHtseg1[[6]]
a
a$maeBayes==resultsHtseg1$maeBayes
a$maeBu==resultsHtseg1$maeBu
a$maeComb==resultsHtseg1$maeComb
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
a <- hier(htseg2)
b <- hier(htseg2, fmethod = "arima")
c <- hier(htseg2, fmethod = "rw")
View(a)
View(b)
View(c)
a <- hier(infantgts, fmethod = "rw")
b <- hier(infantgts, fmethod = "rw", h=4)
View(a)
View(b)
a <- hier(infantgts, fmethod = "arima", h=1)
View(a)
a <- hier(infantgts, fmethod = "arima", h=4)
View(a)
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
a <- hier(htseg1, fmethod = "ets", h=4)
library(thief)
??thief
z <- thief(AEdemand[,12], usemodel='arima')
z
class(z)
z
?hts
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier(htseg1)
fcastComb
class(fcastComb)
fcastComb
fcastComb$bts
fcastComb$histy
fcastComb$labels
fcastComb$method
fcastComb$fmethod
fcastComb$nodes
install.packages(tsfeatures)
install.packages("tsfeatures")
library(tsfeatures)
devtools::install_github("robjhyndman/tsfeatures")
?hts
?forecast.gts
ally <- aggts(htseg1)
n <- nrow(ally)
p <- ncol(ally)
allf <- matrix(NA, nrow = h, ncol = p)
res <- matrix(NA, nrow = n, ncol = p)
h <- 1
ally <- aggts(htseg1)
n <- nrow(ally)
p <- ncol(ally)
allf <- matrix(NA, nrow = h, ncol = p)
res <- matrix(NA, nrow = n, ncol = p)
for(i in 1:p)
{
fit <- auto.arima(ally[, i])
allf[, i] <- forecast(fit, h = h)$mean
res[, i] <- na.omit(ally[, i] - fitted(fit))
}
allf <- ts(allf, start = 51)
y.f <- MinT(allf, get_nodes(htseg1), residual = res, covariance = "shr",
keep = "gts", algorithms = "lu")
y.f
y.f$bts
y.f$nodes
y.f$labels
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
y.f$labels
hier(0)
hier()
hier(htseg1)
y.f <- MinT(train, get_nodes(htseg1), residual = res, covariance = "shr",
keep = "gts", algorithms = "lu")
?gamma
?rgamma
hist(rgamma(10000,1,1))
?rgamma
hist(rgamma(10000,0.1,1))
hist(rgamma(100000,0.1,1))
hist(rgamma(100000,0.01,1))
?rgamma
hist(rgamma(100000,0.01,100))
libvrary(hts)
library(hts)
?hts
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier(htseg1)
allts(htseg1)
a<-allts(htseg1)
a
class(a)
class(htseg1)
htseg1$bts
htseg1$nodes
htseg1$labels
S
smatrix(htseg1)
maeBayes
htseg1$labels
htseg1$nodes
summary(htseg1)
htseg1$nodes
htseg1
htseg1$nodes
htseg1$labels
class(htseg1$labels)
length(htseg1$labels)
htseg1$labels[[1]]
htseg1$labels[[2]]
htseg1$labels[[3]]
htse1[[3]]
htseg1[[3]]
install.packages("MASS")
?MASS
library("MASS", lib.loc="/Library/Frameworks/R.framework/Versions/3.5/Resources/library")
install.packages("mvtnorm")
library(mtvnorm)
library("mvtnorm")
?mvtno
?mvtno rm
?mvtnorm
?v
?mvtnorm
?qmvnorm
qmvnorm(p, interval = NULL, tail = c("lower.tail",
"upper.tail", "both.tails"), mean = 0, corr = NULL,
sigma = NULL, algorithm = GenzBretz(),
ptol = 0.001, maxiter = 500, trace = FALSE, ...)
qmvnorm(.95, tail=("both.tails"), mean=c(0,0), sigma=matrix(data = c(1,0,0,1), nrow = 2))
qmvnorm(0.95, sigma = diag(2), tail = "both")
qmvnorm(0.95, sigma = diag(1), tail = "both")
diag(3)
a <- c(1,2,3)
diag(a)
diag(a^2)
?daig
?diaf
?diag
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier(htseg1)
m <- priorCov
priorCov <- matrix (nrow = p, ncol = p)
for (i in 1:p) {
priorCov[i,i] <- sigma[i]^2
}
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier(htseg1)
m <- priorCov
hier(htseg1)
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
source('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier(htseg1,1)
hier(htseg1)
p
priorCov
diag(sigma[i]^2)
sigma[i]^2
hier(htseg1)
sigma
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier(htseg1)
debugSource('~/switchDrive/hierTs/hierarchicalTimeSeries/code/hierTs/hier.R')
hier(htseg1)
